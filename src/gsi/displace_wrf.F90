#ifdef FCA_REF_MOD
module displace_wrf_m
  use fp_types_m, only: fp
  use core_disp_types_m, only: fca_gridded_disp, ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte
  use core_disp_func_m, only: apply_disp_2d, apply_vert
  implicit none
  private
  public :: displace_wrf_fields
  ! NOTE: The following only needed by displace_wrf_ad_m:
  public :: calc_ph_hyd_wrf, adj_wrf_derived, displace_theta_wrf, apply_disp_theta, sh2rh, rh2sh
  ! Physical constants specific to WRF physics routines (as in WRFV3/share/module_model_constants.F):
  real(fp), parameter, public :: t0 = 300.0  !Basic state potential temperature (K)
  real(fp), parameter, public :: p0 = 1E5  !basic state dry surface pressure
  real(fp), parameter, public :: gas_constant = 287.0     !dry air gas constant
  real(fp), parameter, public :: gas_constant_v = 461.6      !water vapor gas constant
  real(fp), parameter, public :: gravity = 9.81
  ! Copy to variable names used here
  real(fp), parameter, public :: grav=gravity !dry air gas constant 
  real(fp), parameter, public :: Rd=gas_constant !dry air gas constant 
  real(fp), parameter, public :: Rv=gas_constant_v !dry air gas constant 
  real(fp), parameter, public :: cp = 7.0*Rd/2.0 !dry air heat capacity at constant pressure
  real(fp), parameter, public :: kappa = Rd / cp !exponent used in computation of theta
  real(fp), parameter, public :: base_pres = p0 !equal to p0
  real(fp), parameter, public :: gamma=0.0065    !lapse rate used for SLP reduction

  contains
#else
#define TRACE_USE
#endif

subroutine displace_wrf_fields(th_compute, istep, &
       qv_ind, moist, nmoist, p, pb, t, ph, phb, u, v, w, hgt, mub, mu, psfc, znu, fcadisp,&
       needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)

    implicit none

    integer, intent(in) :: th_compute				! control parameter for theta computation/displacemnt
    integer, intent(in) :: istep				! control parameter for theta computation/displacemnt
    integer, intent(in) :: qv_ind				! index for qvapor
    integer, intent(in) :: nmoist ! number of moisture fields
    real(fp), intent(INOUT), dimension(ims:ime,jms:jme,kms:kme) :: p, pb, t, u, v, w
    real(fp), intent(inout), dimension(ims:ime,jms:jme,kms:kme) ::  ph, phb
    real(fp), intent(INOUT), dimension(ims:ime,jms:jme,kms:kme,1:nmoist) :: moist
    real(fp), intent(IN), dimension(ims:ime,jms:jme) :: hgt, mub
    real(fp), intent(INOUT), dimension(ims:ime,jms:jme) :: mu, psfc
    real(fp), intent(IN), dimension(kms:kme) :: znu
    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    integer, intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
    real(fp), intent(in) :: needed_wgts_out(:,:)
    integer, intent(in) :: interp_order

    real(fp), dimension(ims:ime,jms:jme,kms:kme) :: ph_hyd, ph_nl	! hydrostatic component for geopotential
    real(fp), dimension(ims:ime,jms:jme,2) :: work2d		! work space for 2d original/displaced fields
    integer :: i, status
    
#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("displace_wrf_fields")
#endif
    ! we need the nonhydrostatic component of the geopotential to apply after displacements to get the total PH
    ! Before doing anything with the displacements, get the hydrostatic component of the geopotential
    call calc_ph_hyd_wrf(moist(:,:,:,qv_ind),p,pb,t,hgt,mu,mub,znu,ph_hyd)
    ph_nl = (ph+phb) - ph_hyd ! save the nonhydrostatic component for later use
    
    ! Adjust fields which are to be directly displaced (momentum and hydrometeor mixing ratios)
    call apply_vert(u, 0, work2d, fcadisp,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    if (istep .le. 1) return
    call apply_vert(v, 0, work2d, fcadisp,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    if (istep .le. 2) return
    ! NOT: Only apply displacements to first kte levels, even for staggered variables w, ph_nl
    call apply_vert(w, 1, work2d, fcadisp,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    if (istep .le. 3) return
    call apply_vert(ph_nl, 1, work2d, fcadisp,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    if (istep .le. 4) return
    do i = 1, size(moist,4)
       if(i .ne. qv_ind) call apply_vert(moist(:,:,:,i), 0, work2d, fcadisp,&
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    end do
    if (istep .le. 5) return

    ! Recalculate secondary fields from the newly displaced ones
    call adj_wrf_derived(moist(:,:,:,qv_ind), p, pb, t, ph, phb, ph_nl, &
         hgt, mub, mu, psfc, znu, th_compute, fcadisp,istep,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)

#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("displace_wrf_fields")
#endif

end subroutine displace_wrf_fields

subroutine calc_ph_hyd_wrf(qvapor,p,pb,t,hgt,mu,mub,znu,ph_hyd)
    real(fp), intent(IN), dimension(ims:ime,jms:jme,kms:kme) :: qvapor, p, pb, t
    real(fp), intent(IN), dimension(ims:ime,jms:jme) :: hgt, mu, mub
    real(fp), intent(IN), dimension(kms:kme) :: znu
    real(fp), dimension(ims:ime,jms:jme,kms:kme), intent(out) :: ph_hyd		! nonhydrostatic component for geopotential

    integer :: i
    real(fp), dimension(ims:ime,jms:jme,kms:kme) :: rhod
    real(fp) :: dEta(kms:kme), znuw(kms:kme)			! model Eta vertical levels
    
#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("calc_ph_hyd_wrf")
#endif
    rhod(:,:,kts:kte) = (p(:,:,kts:kte)+pb(:,:,kts:kte))*(1-Rv/Rd*qvapor(:,:,kts:kte)) &
         / (Rd*(t(:,:,kts:kte)+t0)*((p(:,:,kts:kte)+pb(:,:,kts:kte))/p0)**(Rd/cp)) ! calculate dry air density
    ! get eta interface values and d(eta)
    znuw(kte+1) = 0
    znuw(kts) = 1
    do i = kts+1, kte
       znuw(i) = (znu(i-1)+znu(i))/2	! interface eta values
    end do
    do i = kts, kte
       dEta(i) = znuw(i) - znuw(i+1)	! d(eta)
    end do
    
    ! to start, store the hydrostatic geopotential in the hydrostatic result
    ph_hyd(:,:,kts) = grav*HGT
    do i = kts+1, kte+1
       ph_hyd(:,:,i) = ph_hyd(:,:,i-1)+(mu+mub)/rhod(:,:,i-1)*dEta(i-1)
    end do
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("calc_ph_hyd_wrf")
#endif

end subroutine calc_ph_hyd_wrf

subroutine adj_wrf_derived(qvapor, p, pb, t, ph, phb, ph_nl, hgt, mub, mu, psfc, znu, th_compute,fcadisp,istep,&
     needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    
    ! Compute secondary fields from adjusted fields
    ! Requires surface pressure and water vapor increments
    implicit none
    real(fp), intent(INOUT), dimension(ims:ime, jms:jme, kms:kme) :: qvapor, p, pb, t, ph
    real(fp), intent(IN), dimension(ims:ime, jms:jme, kms:kme) :: ph_nl, phb
    real(fp), intent(IN), dimension(ims:ime, jms:jme) :: hgt, mub
    real(fp), intent(INOUT), dimension(ims:ime, jms:jme) :: mu, psfc
    real(fp), intent(IN), dimension(kms:kme) :: znu

    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    integer, intent(in) :: th_compute				! control parameter for theta computation/displacemnt
    integer, intent(in) :: istep
    integer, intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
    real(fp), intent(in) :: needed_wgts_out(:,:)
    integer, intent(in) :: interp_order
    integer :: i, j, k, q_ind, numvars=1
    real(fp), dimension(ims:ime, jms:jme, kms:kme) :: TK, Ptot, p_inc, q_inc
    real(fp), dimension(ims:ime, jms:jme, kms:kme) :: ph_temp
    real(fp) :: dEta(kms:kme), znuw(kms:kme)			! model Eta vertical levels
    real(fp), dimension(ims:ime, jms:jme) :: sum1, sum2
    real(fp), dimension(ims:ime, jms:jme,2) :: work2d
    real(fp), dimension(ims:ime, jms:jme) :: Tbl, Ts, Tm, Zl, Tslv, Pslv, ps_inc, mu_inc
    
#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("adj_wrf_derived")
#endif
    Ptot(:,:,kts:kte) = (p(:,:,kts:kte)+pb(:,:,kts:kte))
    TK(:,:,kts:kte) = (T(:,:,kts:kte)+t0)*(Ptot(:,:,kts:kte)/p0)**(Rd/Cp)	! Use un-displaced temperature (K) for all conversions below
    if(th_compute == 1) then 			! displace and overwite theta
       call displace_theta_wrf(t,ph,phb,fcadisp,&
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    else
       ! alternatively just stupidly displace the temperature along model surfaces (not recommended)
       call apply_vert(t,0,work2d,fcadisp,&
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    end if
    if (istep .le. 6) return
    ! Find the temperature 100 mb AGL
    do i = ims, ime
       do j = jms, jme
          ! first check if top model level is top of PBL -- very unlikely but included for robustness
          if(Ptot(i,j,kte) == (Psfc(i,j)-100E2)) Tbl(i,j) = TK(i,j,kte)
          do k = kts, kte-1 ! make sure that a 3D field was last loaded (not PSFC)
             if(Ptot(i,j,k+1) == (Psfc(i,j)-100E2)) then
                Tbl(i,j) = TK(i,j,k+1)
             elseif( (Ptot(i,j,k) > (Psfc(i,j)-100E2)) .and. (Ptot(i,j,k+1) < (Psfc(i,j)-100E2)) ) then
                Tbl(i,j) = ( TK(i,j,k+1)*log(Ptot(i,j,k)/(Psfc(i,j)-100E2)) + &
                     TK(i,j,k)*log((Psfc(i,j)-100E2)/Ptot(i,j,k+1)) ) / log(Ptot(i,j,k)/Ptot(i,j,k+1))
             end if
          end do
       end do
    end do
    
    Ts = Tbl*(Psfc/(Psfc-100E2))**(Rd*gamma/grav) !surface temperature from 100 mb AGL
    Tm = (Tbl+Ts)/2.                                  !mean 100mb layer temperature
    Zl = HGT - Rd/grav*log((Psfc-100E2)/Psfc)*Tm !Height AGL for 100mb AGL
    Tslv = Tbl + gamma*Zl ! Temperature at sea level using lapse rate gamma (6.5K/km)
    Pslv = Psfc*exp(grav*HGT/(Rd*(Ts+Tslv)/2.)) !sea-level pressure
    ! Now perform displacement of sea level pressure
    call apply_disp_2d(Pslv,work2d(:,:,1),fcadisp,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    work2d(:,:,2) = work2d(:,:,1)/exp(grav*HGT/(Rd*(Ts+Tslv)/2.))	! compute the new Psfc
    ps_inc = work2d(:,:,2) - Psfc			! get the surface pressure increment
    Psfc = work2d(:,:,2)                            ! Store the new Psfc
    if (istep .le. 7) return
    
    do k = kts, kte
       work2d(:,:,1) = sh2rh(qvapor(:,:,k),TK(:,:,k),Ptot(:,:,k))
       ! displace RH
       call apply_disp_2d(work2d(:,:,1),q_inc(:,:,k),fcadisp,&
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
       ! q_inc should now contain the displace relative humidity (bg in work2d)
       ! calculate q from the adjusted RH
       q_inc(:,:,k) = rh2sh(q_inc(:,:,k),TK(:,:,k),Ptot(:,:,k))
       ! convert to q increments
       q_inc(:,:,k) = q_inc(:,:,k) - qvapor(:,:,k)
    end do
    qvapor(:,:,:) = qvapor(:,:,:) + q_inc ! apply qvapor increments
    if (istep .le. 8) return
    
    ! get eta interface values and d(eta)
    znuw(kte+1) = 0
    znuw(kts) = 1
    do i = kts+1, kte
       znuw(i) = (znu(i-1)+znu(i))/2	! interface eta values
    end do
    do i = kts, kte
       dEta(i) = znuw(i) - znuw(i+1)	! d(eta)
    end do

    ! Below we use the updated qvapor field
    ! Find dry mass increments
    sum1 = 0 ; sum2 = 0
    do i = kte, kts, -1 ! don't use Nz as it is clobbered!
       sum1 = sum1 + q_inc(:,:,i)*dEta(i)
       sum2 = sum2 + (1+qvapor(:,:,i))*dEta(i)
    end do
    mu_inc = (ps_inc-(mu+mub)*sum1)/sum2
    mu = mu + mu_inc	! Update the dry air mass
    if (istep .le. 9) return

    ! Update the pressure field
    do i = kte, kts, -1
       p_inc(:,:,i) = (mu_inc*(1+qvapor(:,:,i))+(mu+mub)*q_inc(:,:,i))*dEta(i)
       if(i < kte) then
          p_inc(:,:,i) = p_inc(:,:,i) +  p_inc(:,:,i+1)
       end if
    end do
    p = p + p_inc
    if (istep .le. 10) return
    
    ! update the geopotential
    call calc_ph_hyd_wrf(qvapor,p,pb,t,hgt,mu,mub,znu,ph_temp) 	! get the hydrostatic geopotential
    ph_temp = ph_temp + ph_nl			! add the saved nonhydrostatic component
    ph = ph_temp - phb		! remove the base component
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("adj_wrf_derived")
#endif
end subroutine adj_wrf_derived

subroutine displace_theta_wrf(t,ph,phb,fcadisp,&
     needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
     
    ! Displace potential temperature field while accounting for the environmental lapse rate
    implicit none
    real(fp), intent(INOUT), dimension(ims:ime,jms:jme,kms:kme) :: t
    real(fp), intent(IN), dimension(ims:ime,jms:jme,kms:(kme+1)) :: ph, phb
    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    integer, intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
    real(fp), intent(in) :: needed_wgts_out(:,:)
    integer, intent(in) :: interp_order
    real(fp), dimension(ims:ime, jms:jme, kms:kme) :: ph_tot
    real(fp), dimension(ims:ime, jms:jme, kms:kme) :: TKnew, znew, zlvl
    integer :: k

#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("displace_theta_wrf")
#endif
    ph_tot = ph+phb
    do k = kts, kte ! find vertical displacement of theta mass level   
       zlvl(:,:,k) = (ph_tot(:,:,k)+ph_tot(:,:,k+1))/2/grav
       call apply_disp_2d(zlvl(:,:,k),znew(:,:,k),fcadisp,&
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    end do
    ! displace theta
    call apply_disp_theta(fcadisp,T,zlvl,znew,TKnew,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    ! save the new theta to the old grid
    T = TKnew
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("displace_theta_wrf")
#endif
end subroutine displace_theta_wrf

subroutine apply_disp_theta(fcadisp,TK,zlvl,znew,TKnew, &
     needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)

    ! purpose:
    ! apply displacements to the 3d theta field
    ! input: original field in TK, displacements in disp, 
    !        original and displaced (new) height values in zlvl and znew
    ! output: displaced theta in TKnew
    implicit none
    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    real(fp), dimension(ims:ime, jms:jme, kms:kme), intent(in) :: znew, TK, zlvl
    real(fp), dimension(ims:ime, jms:jme, kms:kme), intent(out) :: TKnew
    integer, intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
    real(fp), intent(in) :: needed_wgts_out(:,:)
    integer, intent(in) :: interp_order
    integer :: i, j, k, l
    integer :: ibot, itop
    real(fp), dimension(ims:ime, jms:jme,2) :: T_bot_top ! theta above and below level for interpolation

#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("apply_disp_theta")
#endif
    TKnew = -999 ! initialize TKnew as missing
    ibot=1
    ! Compute new theta at bottom level
    call apply_disp_2d(TK(:,:,1),T_bot_top(:,:,ibot),fcadisp, &
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)

    itop=1
    do l= kts, kte-1
       ! switch top and bottom index
       ibot=itop
       if (ibot .eq. 1) then
          itop=2
       else
          itop=1
       end if
       ! Compute new theta at top level
       call apply_disp_2d(TK(:,:,l+1),T_bot_top(:,:,itop),fcadisp, &
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)

       do k = kts, kte
!!$          n_within=count(zlvl(:,:,k) > znew(:,:,l) .and. &
!!$               zlvl(:,:,k) <= znew(:,:,l+1))
!!$          write (*,*) 'l,k,n_within=',l,k,n_within
          ! Linearly interpolate vertically between bottom and top levels
          where (zlvl(:,:,k) > znew(:,:,l) .and. &
               zlvl(:,:,k) <= znew(:,:,l+1))
             TKnew(:,:,k) = T_bot_top(:,:,itop) * (zlvl(:,:,k)-znew(:,:,l))/(znew(:,:,l+1) - znew(:,:,l)) &
                  +  T_bot_top(:,:,ibot) * (1-(zlvl(:,:,k)-znew(:,:,l))/(znew(:,:,l+1) - znew(:,:,l)))
          end where
          if (l == kts) then
             ! For grid points with height at or below bottom-most znew (origin) level:
!!$             n_below=count(zlvl(:,:,k) <= znew(:,:,l))
!!$             write (*,*) 'k=',k,', n_below=',n_below
             where (zlvl(:,:,k) <= znew(:,:,l))
                TKnew(:,:,k) = T_bot_top(:,:,ibot)
             end where
          elseif (l == kte-1) then
             ! For grid points with new height at or above top-most level:
!!$             n_above=count(zlvl(:,:,k) >= znew(:,:,l+1))
!!$             write (*,*) 'k=',k,', n_above=',n_above
             where (zlvl(:,:,k) >= znew(:,:,l+1))
                TKnew(:,:,k) = T_bot_top(:,:,itop)
             end where
          end if
       end do
    end do
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("apply_disp_theta")
#endif
end subroutine apply_disp_theta

function sh2rh(hum,t,parr)
    ! Convert mixing ratio (kg/kg) (hum on input) to relative humidity (%)
    ! Formulas and constants from WRFV3.2.1 (module_initialize_real.F, Registry.EM) and generic/R/src/meteorology.r)
    implicit none
    real(fp), dimension(ims:ime, jms:jme), intent(in) :: hum, t, parr
    real(fp), dimension(ims:ime, jms:jme) :: sh2rh

    integer :: i,j
    real(fp) :: r, e, esat, p
    real(fp) :: rdorv, ew, t1

    ! From module_intialize_real.F:
    real(fp),         parameter     :: t_ref       = 0.0
    real(fp),         parameter     :: mw_air      = 28.966
    real(fp),         parameter     :: mw_vap      = 18.0152

    real(fp),         parameter     :: a0       = 6.107799961
    real(fp),         parameter     :: a1       = 4.436518521e-01
    real(fp),         parameter     :: a2       = 1.428945805e-02
    real(fp),         parameter     :: a3       = 2.650648471e-04
    real(fp),         parameter     :: a4       = 3.031240396e-06
    real(fp),         parameter     :: a5       = 2.034080948e-08
    real(fp),         parameter     :: a6       = 6.136820929e-11

    real(fp),         parameter     :: es0 = 6.1121

    real(fp),         parameter     :: c1       = 9.09718
    real(fp),         parameter     :: c2       = 3.56654
    real(fp),         parameter     :: c3       = 0.876793
    real(fp),         parameter     :: eis      = 6.1071
    real(fp)                        :: rhs
    real(fp),         parameter     :: tf       = 273.16
    real(fp)                        :: tk

    rdorv = mw_vap/mw_air
    do j= jms, jme
       do i= ims, ime
          p=parr(i,j)
          r = hum(i,j)
          e = (p*r)/(rdorv + r)
          ! real formulas wrt liquid/ice:
          t1 = t(i,j) - 273.16
          if ( ( t1 .ge. t_ref ) .and. ( t1 .ge. -47.) ) then    ! liq phase eslo
             ew = a0 + t1 * (a1 + t1 * (a2 + t1 * (a3 + t1 * (a4 + t1 * (a5 + t1 * a6)))))
          else if ( ( t1 .ge. t_ref ) .and. ( t1 .lt. -47. ) ) then !liq phas poor es
             ew = es0 * exp(17.67 * t1 / ( t1 + 243.5))
          else
             tk = t(i,j)
             rhs = -c1 * (tf / tk - 1.) - c2 * log10(tf / tk) +  &
                  c3 * (1. - tk / tf) +      log10(eis)
             ew = 10. ** rhs
          end if
          ! factor of 100. to convert from mb (hPa) to Pa:
          esat = 100.*ew
          sh2rh(i,j) = 100*e/esat
          if (sh2rh(i,j) .gt. 100.) then
             sh2rh(i,j) = 100.
          end if
       end do
    end do
end function sh2rh

function rh2sh(rh,t,parr)
    ! Convert relative humidity (%) to specific (kg/kg)
    ! Formulas and constants from WRFV3.2.1 (module_initialize_real.F, Registry.EM) and generic/R/src/meteorology.r)
    implicit none
    real(fp), dimension(ims:ime, jms:jme), intent(in) :: rh, t, parr
    real(fp), dimension(ims:ime, jms:jme) :: rh2sh

    integer :: i,j
    real(fp) :: e, esat, p
    real(fp) :: rdorv, ew, t1

    ! From module_intialize_real.F:
    real(fp),         parameter     :: t_ref       = 0.0
    real(fp),         parameter     :: mw_air      = 28.966
    real(fp),         parameter     :: mw_vap      = 18.0152

    real(fp),         parameter     :: a0       = 6.107799961
    real(fp),         parameter     :: a1       = 4.436518521e-01
    real(fp),         parameter     :: a2       = 1.428945805e-02
    real(fp),         parameter     :: a3       = 2.650648471e-04
    real(fp),         parameter     :: a4       = 3.031240396e-06
    real(fp),         parameter     :: a5       = 2.034080948e-08
    real(fp),         parameter     :: a6       = 6.136820929e-11

    real(fp),         parameter     :: es0 = 6.1121

    real(fp),         parameter     :: c1       = 9.09718
    real(fp),         parameter     :: c2       = 3.56654
    real(fp),         parameter     :: c3       = 0.876793
    real(fp),         parameter     :: eis      = 6.1071
    real(fp)                        :: rhs
    real(fp),         parameter     :: tf       = 273.16
    real(fp)                        :: tk

    rdorv = mw_vap/mw_air
    do j= jms, jme
       do i= ims,ime
          ! real formulas wrt liquid/ice:
          t1 = t(i,j) - 273.16
          if ( ( t1 .ge. t_ref ) .and. ( t1 .ge. -47.) ) then    ! liq phase eslo
             ew = a0 + t1 * (a1 + t1 * (a2 + t1 * (a3 + t1 * (a4 + t1 * (a5 + t1 * a6)))))
          else if ( ( t1 .ge. t_ref ) .and. ( t1 .lt. -47. ) ) then !liq phas poor es
             ew = es0 * exp(17.67 * t1 / ( t1 + 243.5))
          else
             tk = t(i,j)
             rhs = -c1 * (tf / tk - 1.) - c2 * log10(tf / tk) +  &
                  c3 * (1. - tk / tf) +      log10(eis)
             ew = 10. ** rhs
          end if
          esat = 100.*ew	! factor of 100. to convert from mb (hPa) to Pa
          p=parr(i,j)		! total pressure
          e = esat*rh(i,j)/100.	! vapor pressure ; scale percent RH to decimal
          rh2sh(i,j) = rdorv*e/(p-e)	! mixing ratio
       end do
    end do
end function rh2sh

#ifdef FCA_REF_MOD
end module displace_wrf_m
#endif
