

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!  This file 'AssertArraysInternalassertGreaterThan.F90' is automatically generated by
!  'GenerateAssertsOnArrays.py'.  Changes made here will be
!  overwritten the next time that script is run.
!
!  2013-0722 MLR Michael.L.Rilee-1@nasa.gov
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module AssertArraysInternalassertGreaterThan_mod

   use Params_mod
   use AssertBasic_mod
   use Exception_mod
   use SourceLocation_mod
   use StringConversionUtilities_mod


   implicit none
   private



   integer, parameter :: L_INFINITY_NORM = 0
   integer, parameter :: L1_NORM         = 1
   integer, parameter :: L2_NORM         = 2

   integer, parameter :: MAXLEN_SHAPE = 80


interface differenceReport

   module procedure differenceReport_integer3232
   module procedure differenceReport_integer3264
   module procedure differenceReport_integer6432
   module procedure differenceReport_integer6464
   module procedure differenceReport_real3232
   module procedure differenceReport_real3264
   module procedure differenceReport_real6432
   module procedure differenceReport_real6464
   module procedure differenceReport_complex3232
   module procedure differenceReport_complex3264
   module procedure differenceReport_complex6432
   module procedure differenceReport_complex6464

end interface differenceReport


interface valuesReport

   module procedure valuesReport_integerinteger3232
   module procedure valuesReport_integerinteger6432
   module procedure valuesReport_integerinteger3264
   module procedure valuesReport_integerinteger6464
   module procedure valuesReport_realinteger3232
   module procedure valuesReport_realinteger6432
   module procedure valuesReport_realinteger3264
   module procedure valuesReport_realinteger6464
   module procedure valuesReport_integerreal3232
   module procedure valuesReport_integerreal6432
   module procedure valuesReport_integerreal3264
   module procedure valuesReport_integerreal6464
   module procedure valuesReport_realreal3232
   module procedure valuesReport_realreal3264
   module procedure valuesReport_realreal6464
   module procedure valuesReport_integercomplex3232
   module procedure valuesReport_integercomplex6432
   module procedure valuesReport_integercomplex3264
   module procedure valuesReport_integercomplex6464
   module procedure valuesReport_realcomplex3232
   module procedure valuesReport_realcomplex3264
   module procedure valuesReport_realcomplex6464
   module procedure valuesReport_complexcomplex3232
   module procedure valuesReport_complexcomplex3264
   module procedure valuesReport_complexcomplex6464

end interface valuesReport


interface vectorNorm

   module procedure vectorNorm_0D_real32
   module procedure vectorNorm_0D_real64
   module procedure vectorNorm_1D_real32
   module procedure vectorNorm_1D_real64
   module procedure vectorNorm_2D_real32
   module procedure vectorNorm_2D_real64
   module procedure vectorNorm_3D_real32
   module procedure vectorNorm_3D_real64
   module procedure vectorNorm_4D_real32
   module procedure vectorNorm_4D_real64
   module procedure vectorNorm_5D_real32
   module procedure vectorNorm_5D_real64
   module procedure vectorNorm_0D_complex32
   module procedure vectorNorm_0D_complex64
   module procedure vectorNorm_1D_complex32
   module procedure vectorNorm_1D_complex64
   module procedure vectorNorm_2D_complex32
   module procedure vectorNorm_2D_complex64
   module procedure vectorNorm_3D_complex32
   module procedure vectorNorm_3D_complex64
   module procedure vectorNorm_4D_complex32
   module procedure vectorNorm_4D_complex64
   module procedure vectorNorm_5D_complex32
   module procedure vectorNorm_5D_complex64
   module procedure vectorNorm_0D_integer32
   module procedure vectorNorm_0D_integer64
   module procedure vectorNorm_1D_integer32
   module procedure vectorNorm_1D_integer64
   module procedure vectorNorm_2D_integer32
   module procedure vectorNorm_2D_integer64
   module procedure vectorNorm_3D_integer32
   module procedure vectorNorm_3D_integer64
   module procedure vectorNorm_4D_integer32
   module procedure vectorNorm_4D_integer64
   module procedure vectorNorm_5D_integer32
   module procedure vectorNorm_5D_integer64

end interface vectorNorm


interface isWithinTolerance

   module procedure isWithinTolerance_0D_real32
   module procedure isWithinTolerance_0D_real64
   module procedure isWithinTolerance_1D_real32
   module procedure isWithinTolerance_1D_real64
   module procedure isWithinTolerance_2D_real32
   module procedure isWithinTolerance_2D_real64
   module procedure isWithinTolerance_3D_real32
   module procedure isWithinTolerance_3D_real64
   module procedure isWithinTolerance_4D_real32
   module procedure isWithinTolerance_4D_real64
   module procedure isWithinTolerance_5D_real32
   module procedure isWithinTolerance_5D_real64
   module procedure isWithinTolerance_0D_complex32
   module procedure isWithinTolerance_0D_complex64
   module procedure isWithinTolerance_1D_complex32
   module procedure isWithinTolerance_1D_complex64
   module procedure isWithinTolerance_2D_complex32
   module procedure isWithinTolerance_2D_complex64
   module procedure isWithinTolerance_3D_complex32
   module procedure isWithinTolerance_3D_complex64
   module procedure isWithinTolerance_4D_complex32
   module procedure isWithinTolerance_4D_complex64
   module procedure isWithinTolerance_5D_complex32
   module procedure isWithinTolerance_5D_complex64
   module procedure isWithinTolerance_0D_integer32
   module procedure isWithinTolerance_0D_integer64
   module procedure isWithinTolerance_1D_integer32
   module procedure isWithinTolerance_1D_integer64
   module procedure isWithinTolerance_2D_integer32
   module procedure isWithinTolerance_2D_integer64
   module procedure isWithinTolerance_3D_integer32
   module procedure isWithinTolerance_3D_integer64
   module procedure isWithinTolerance_4D_integer32
   module procedure isWithinTolerance_4D_integer64
   module procedure isWithinTolerance_5D_integer32
   module procedure isWithinTolerance_5D_integer64

end interface isWithinTolerance


!interface assertGreaterThan_internal

   public :: assertGreaterThan_e0_integer32_f0_integer32_tol32_
   public :: assertGreaterThan_e1_integer32_f0_integer32_tol32_
   public :: assertGreaterThan_e0_integer32_f1_integer32_tol32_
   public :: assertGreaterThan_e1_integer32_f1_integer32_tol32_
   public :: assertGreaterThan_e0_integer64_f0_integer32_tol64_
   public :: assertGreaterThan_e1_integer64_f0_integer32_tol64_
   public :: assertGreaterThan_e0_integer64_f1_integer32_tol64_
   public :: assertGreaterThan_e1_integer64_f1_integer32_tol64_
   public :: assertGreaterThan_e0_integer32_f0_integer64_tol64_
   public :: assertGreaterThan_e1_integer32_f0_integer64_tol64_
   public :: assertGreaterThan_e0_integer32_f1_integer64_tol64_
   public :: assertGreaterThan_e1_integer32_f1_integer64_tol64_
   public :: assertGreaterThan_e0_integer64_f0_integer64_tol64_
   public :: assertGreaterThan_e1_integer64_f0_integer64_tol64_
   public :: assertGreaterThan_e0_integer64_f1_integer64_tol64_
   public :: assertGreaterThan_e1_integer64_f1_integer64_tol64_
   public :: assertGreaterThan_e0_real32_f0_integer32_tol32_
   public :: assertGreaterThan_e1_real32_f0_integer32_tol32_
   public :: assertGreaterThan_e0_real32_f1_integer32_tol32_
   public :: assertGreaterThan_e1_real32_f1_integer32_tol32_
   public :: assertGreaterThan_e0_real64_f0_integer32_tol64_
   public :: assertGreaterThan_e1_real64_f0_integer32_tol64_
   public :: assertGreaterThan_e0_real64_f1_integer32_tol64_
   public :: assertGreaterThan_e1_real64_f1_integer32_tol64_
   public :: assertGreaterThan_e0_real32_f0_integer64_tol64_
   public :: assertGreaterThan_e1_real32_f0_integer64_tol64_
   public :: assertGreaterThan_e0_real32_f1_integer64_tol64_
   public :: assertGreaterThan_e1_real32_f1_integer64_tol64_
   public :: assertGreaterThan_e0_real64_f0_integer64_tol64_
   public :: assertGreaterThan_e1_real64_f0_integer64_tol64_
   public :: assertGreaterThan_e0_real64_f1_integer64_tol64_
   public :: assertGreaterThan_e1_real64_f1_integer64_tol64_
   public :: assertGreaterThan_e0_integer32_f0_real32_tol32_
   public :: assertGreaterThan_e1_integer32_f0_real32_tol32_
   public :: assertGreaterThan_e0_integer32_f1_real32_tol32_
   public :: assertGreaterThan_e1_integer32_f1_real32_tol32_
   public :: assertGreaterThan_e0_integer64_f0_real32_tol64_
   public :: assertGreaterThan_e1_integer64_f0_real32_tol64_
   public :: assertGreaterThan_e0_integer64_f1_real32_tol64_
   public :: assertGreaterThan_e1_integer64_f1_real32_tol64_
   public :: assertGreaterThan_e0_integer32_f0_real64_tol64_
   public :: assertGreaterThan_e1_integer32_f0_real64_tol64_
   public :: assertGreaterThan_e0_integer32_f1_real64_tol64_
   public :: assertGreaterThan_e1_integer32_f1_real64_tol64_
   public :: assertGreaterThan_e0_integer64_f0_real64_tol64_
   public :: assertGreaterThan_e1_integer64_f0_real64_tol64_
   public :: assertGreaterThan_e0_integer64_f1_real64_tol64_
   public :: assertGreaterThan_e1_integer64_f1_real64_tol64_
   public :: assertGreaterThan_e0_real32_f0_real32_tol32_
   public :: assertGreaterThan_e1_real32_f0_real32_tol32_
   public :: assertGreaterThan_e0_real32_f1_real32_tol32_
   public :: assertGreaterThan_e1_real32_f1_real32_tol32_
   public :: assertGreaterThan_e0_real32_f0_real64_tol64_
   public :: assertGreaterThan_e1_real32_f0_real64_tol64_
   public :: assertGreaterThan_e0_real32_f1_real64_tol64_
   public :: assertGreaterThan_e1_real32_f1_real64_tol64_
   public :: assertGreaterThan_e0_real64_f0_real64_tol64_
   public :: assertGreaterThan_e1_real64_f0_real64_tol64_
   public :: assertGreaterThan_e0_real64_f1_real64_tol64_
   public :: assertGreaterThan_e1_real64_f1_real64_tol64_
   public :: assertGreaterThan_e0_integer32_f0_complex32_tol32_
   public :: assertGreaterThan_e1_integer32_f0_complex32_tol32_
   public :: assertGreaterThan_e0_integer32_f1_complex32_tol32_
   public :: assertGreaterThan_e1_integer32_f1_complex32_tol32_
   public :: assertGreaterThan_e0_integer64_f0_complex32_tol64_
   public :: assertGreaterThan_e1_integer64_f0_complex32_tol64_
   public :: assertGreaterThan_e0_integer64_f1_complex32_tol64_
   public :: assertGreaterThan_e1_integer64_f1_complex32_tol64_
   public :: assertGreaterThan_e0_integer32_f0_complex64_tol64_
   public :: assertGreaterThan_e1_integer32_f0_complex64_tol64_
   public :: assertGreaterThan_e0_integer32_f1_complex64_tol64_
   public :: assertGreaterThan_e1_integer32_f1_complex64_tol64_
   public :: assertGreaterThan_e0_integer64_f0_complex64_tol64_
   public :: assertGreaterThan_e1_integer64_f0_complex64_tol64_
   public :: assertGreaterThan_e0_integer64_f1_complex64_tol64_
   public :: assertGreaterThan_e1_integer64_f1_complex64_tol64_
   public :: assertGreaterThan_e0_real32_f0_complex32_tol32_
   public :: assertGreaterThan_e1_real32_f0_complex32_tol32_
   public :: assertGreaterThan_e0_real32_f1_complex32_tol32_
   public :: assertGreaterThan_e1_real32_f1_complex32_tol32_
   public :: assertGreaterThan_e0_real32_f0_complex64_tol64_
   public :: assertGreaterThan_e1_real32_f0_complex64_tol64_
   public :: assertGreaterThan_e0_real32_f1_complex64_tol64_
   public :: assertGreaterThan_e1_real32_f1_complex64_tol64_
   public :: assertGreaterThan_e0_real64_f0_complex64_tol64_
   public :: assertGreaterThan_e1_real64_f0_complex64_tol64_
   public :: assertGreaterThan_e0_real64_f1_complex64_tol64_
   public :: assertGreaterThan_e1_real64_f1_complex64_tol64_
   public :: assertGreaterThan_e0_complex32_f0_complex32_tol32_
   public :: assertGreaterThan_e1_complex32_f0_complex32_tol32_
   public :: assertGreaterThan_e0_complex32_f1_complex32_tol32_
   public :: assertGreaterThan_e1_complex32_f1_complex32_tol32_
   public :: assertGreaterThan_e0_complex32_f0_complex64_tol64_
   public :: assertGreaterThan_e1_complex32_f0_complex64_tol64_
   public :: assertGreaterThan_e0_complex32_f1_complex64_tol64_
   public :: assertGreaterThan_e1_complex32_f1_complex64_tol64_
   public :: assertGreaterThan_e0_complex64_f0_complex64_tol64_
   public :: assertGreaterThan_e1_complex64_f0_complex64_tol64_
   public :: assertGreaterThan_e0_complex64_f1_complex64_tol64_
   public :: assertGreaterThan_e1_complex64_f1_complex64_tol64_

!end interface assertGreaterThan_internal

contains
! interface differenceReport implementations

    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_integer3232(difference, tolerance) result(differenceReport)
     integer(kind=i32), intent(in) :: difference
     real(kind=r32), intent(in) :: tolerance
!     real(kind=r32), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(difference) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(difference)) // &
      & '| '
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_integer3264(difference, tolerance) result(differenceReport)
     integer(kind=i32), intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(difference) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(difference)) // &
      & '| '
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_integer6432(difference, tolerance) result(differenceReport)
     integer(kind=i64), intent(in) :: difference
     real(kind=r32), intent(in) :: tolerance
!     real(kind=r32), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(difference) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(difference)) // &
      & '| '
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_integer6464(difference, tolerance) result(differenceReport)
     integer(kind=i64), intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(difference) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(difference)) // &
      & '| '
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_real3232(difference, tolerance) result(differenceReport)
     real(kind=r32), intent(in) :: difference
     real(kind=r32), intent(in) :: tolerance
!     real(kind=r32), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(real(difference,kind=r32)) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(real(difference,kind=r32))) // &
      & '| '// trim(rel) //' tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_real3264(difference, tolerance) result(differenceReport)
     real(kind=r32), intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(real(difference,kind=r32)) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(real(difference,kind=r32))) // &
      & '| '// trim(rel) //' tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_real6432(difference, tolerance) result(differenceReport)
     real(kind=r64), intent(in) :: difference
     real(kind=r32), intent(in) :: tolerance
!     real(kind=r32), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(real(difference,kind=r32)) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(real(difference,kind=r32))) // &
      & '| '// trim(rel) //' tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_real6464(difference, tolerance) result(differenceReport)
     real(kind=r64), intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(real(difference,kind=r32)) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(real(difference,kind=r32))) // &
      & '| '// trim(rel) //' tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_complex3232(difference, tolerance) result(differenceReport)
     complex(kind=r32), intent(in) :: difference
     real(kind=r32), intent(in) :: tolerance
!     real(kind=r32), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(cmplx(difference,kind=c32)) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(cmplx(difference,kind=c32))) // &
      & '| '// trim(rel) //' tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_complex3264(difference, tolerance) result(differenceReport)
     complex(kind=r32), intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(cmplx(difference,kind=c32)) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(cmplx(difference,kind=c32))) // &
      & '| '// trim(rel) //' tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_complex6432(difference, tolerance) result(differenceReport)
     complex(kind=r64), intent(in) :: difference
     real(kind=r32), intent(in) :: tolerance
!     real(kind=r32), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(cmplx(difference,kind=c32)) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(cmplx(difference,kind=c32))) // &
      & '| '// trim(rel) //' tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_complex6464(difference, tolerance) result(differenceReport)
     complex(kind=r64), intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
     character(len=2) rel
     if (abs(cmplx(difference,kind=c32)) .gt. tolerance) then
        rel = '> '
     else
        rel = '<='
     end if
     differenceReport = ' difference: |' // trim(toString(cmplx(difference,kind=c32))) // &
      & '| '// trim(rel) //' tolerance:' // trim(toString(tolerance))
    end function 

! end interface differenceReport implementations
! interface valuesReport implementations

      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerinteger3232 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i32), intent(in) :: expected
        integer(kind=i32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(found)) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerinteger6432 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i64), intent(in) :: expected
        integer(kind=i32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(found)) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerinteger3264 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i32), intent(in) :: expected
        integer(kind=i64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(found)) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerinteger6464 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i64), intent(in) :: expected
        integer(kind=i64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(found)) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realinteger3232 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r32), intent(in) :: expected
        integer(kind=i32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(found)) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realinteger6432 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r64), intent(in) :: expected
        integer(kind=i32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(found)) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realinteger3264 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r32), intent(in) :: expected
        integer(kind=i64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(found)) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realinteger6464 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r64), intent(in) :: expected
        integer(kind=i64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(found)) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerreal3232 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i32), intent(in) :: expected
        real(kind=r32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerreal6432 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i64), intent(in) :: expected
        real(kind=r32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerreal3264 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i32), intent(in) :: expected
        real(kind=r64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerreal6464 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i64), intent(in) :: expected
        real(kind=r64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realreal3232 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r32), intent(in) :: expected
        real(kind=r32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realreal3264 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r32), intent(in) :: expected
        real(kind=r64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realreal6464 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r64), intent(in) :: expected
        real(kind=r64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integercomplex3232 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i32), intent(in) :: expected
        complex(kind=c32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integercomplex6432 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i64), intent(in) :: expected
        complex(kind=c32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integercomplex3264 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i32), intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integercomplex6464 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer(kind=i64), intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(expected)) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realcomplex3232 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r32), intent(in) :: expected
        complex(kind=c32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realcomplex3264 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r32), intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realcomplex6464 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r64), intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_complexcomplex3232 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        complex(kind=c32), intent(in) :: expected
        complex(kind=c32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_complexcomplex3264 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        complex(kind=c32), intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_complexcomplex6464 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        complex(kind=c64), intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

! end interface valuesReport implementations
! interface vectorNorm implementations

  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x(:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_1D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x(:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_1D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x(:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_2D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x(:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_2D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x(:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_3D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x(:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_3D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x(:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_4D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x(:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_4D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x(:,:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_5D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x(:,:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_5D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x(:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_1D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x(:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_1D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x(:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_2D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x(:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_2D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x(:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_3D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x(:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_3D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x(:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_4D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x(:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_4D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x(:,:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_5D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x(:,:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_5D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_integer32(x, norm) result(y)
    integer(kind=i32), intent(in) :: x
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_integer32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_integer64(x, norm) result(y)
    integer(kind=i64), intent(in) :: x
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_integer64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_integer32(x, norm) result(y)
    integer(kind=i32), intent(in) :: x(:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_1D_integer32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_integer64(x, norm) result(y)
    integer(kind=i64), intent(in) :: x(:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_1D_integer64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_integer32(x, norm) result(y)
    integer(kind=i32), intent(in) :: x(:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_2D_integer32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_integer64(x, norm) result(y)
    integer(kind=i64), intent(in) :: x(:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_2D_integer64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_integer32(x, norm) result(y)
    integer(kind=i32), intent(in) :: x(:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_3D_integer32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_integer64(x, norm) result(y)
    integer(kind=i64), intent(in) :: x(:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_3D_integer64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_integer32(x, norm) result(y)
    integer(kind=i32), intent(in) :: x(:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_4D_integer32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_integer64(x, norm) result(y)
    integer(kind=i64), intent(in) :: x(:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_4D_integer64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_integer32(x, norm) result(y)
    integer(kind=i32), intent(in) :: x(:,:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_5D_integer32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_integer64(x, norm) result(y)
    integer(kind=i64), intent(in) :: x(:,:,:,:,:)
    integer :: norm
! mlr 2013-0908 Maybe we change the range of VECTOR_NORM to include integer & logical.
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_5D_integer64

! end interface vectorNorm implementations
! interface isWithinTolerance implementations

   logical function isWithinTolerance_0D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x
     real(kind=r32), intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_real32

   
   logical function isWithinTolerance_0D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x
     real(kind=r64), intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_real64

   
   logical function isWithinTolerance_1D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x(:)
     real(kind=r32), intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_real32

   
   logical function isWithinTolerance_1D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x(:)
     real(kind=r64), intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_real64

   
   logical function isWithinTolerance_2D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x(:,:)
     real(kind=r32), intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_real32

   
   logical function isWithinTolerance_2D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x(:,:)
     real(kind=r64), intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_real64

   
   logical function isWithinTolerance_3D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x(:,:,:)
     real(kind=r32), intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_real32

   
   logical function isWithinTolerance_3D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x(:,:,:)
     real(kind=r64), intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_real64

   
   logical function isWithinTolerance_4D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x(:,:,:,:)
     real(kind=r32), intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_real32

   
   logical function isWithinTolerance_4D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x(:,:,:,:)
     real(kind=r64), intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_real64

   
   logical function isWithinTolerance_5D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x(:,:,:,:,:)
     real(kind=r32), intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_real32

   
   logical function isWithinTolerance_5D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x(:,:,:,:,:)
     real(kind=r64), intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_real64

   
   logical function isWithinTolerance_0D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x
     complex(kind=c32), intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_complex32

   
   logical function isWithinTolerance_0D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x
     complex(kind=c64), intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_complex64

   
   logical function isWithinTolerance_1D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x(:)
     complex(kind=c32), intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_complex32

   
   logical function isWithinTolerance_1D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x(:)
     complex(kind=c64), intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_complex64

   
   logical function isWithinTolerance_2D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x(:,:)
     complex(kind=c32), intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_complex32

   
   logical function isWithinTolerance_2D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x(:,:)
     complex(kind=c64), intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_complex64

   
   logical function isWithinTolerance_3D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x(:,:,:)
     complex(kind=c32), intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_complex32

   
   logical function isWithinTolerance_3D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x(:,:,:)
     complex(kind=c64), intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_complex64

   
   logical function isWithinTolerance_4D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x(:,:,:,:)
     complex(kind=c32), intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_complex32

   
   logical function isWithinTolerance_4D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x(:,:,:,:)
     complex(kind=c64), intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_complex64

   
   logical function isWithinTolerance_5D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x(:,:,:,:,:)
     complex(kind=c32), intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_complex32

   
   logical function isWithinTolerance_5D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x(:,:,:,:,:)
     complex(kind=c64), intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_complex64

   
   logical function isWithinTolerance_0D_integer32(x, tolerance, norm)
!     integer (kind=r32), intent(in) :: x
     integer(kind=i32), intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_integer32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_integer32

   
   logical function isWithinTolerance_0D_integer64(x, tolerance, norm)
!     integer (kind=r64), intent(in) :: x
     integer(kind=i64), intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_integer64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_integer64

   
   logical function isWithinTolerance_1D_integer32(x, tolerance, norm)
!     integer (kind=r32), intent(in) :: x(:)
     integer(kind=i32), intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_integer32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_integer32

   
   logical function isWithinTolerance_1D_integer64(x, tolerance, norm)
!     integer (kind=r64), intent(in) :: x(:)
     integer(kind=i64), intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_integer64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_integer64

   
   logical function isWithinTolerance_2D_integer32(x, tolerance, norm)
!     integer (kind=r32), intent(in) :: x(:,:)
     integer(kind=i32), intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_integer32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_integer32

   
   logical function isWithinTolerance_2D_integer64(x, tolerance, norm)
!     integer (kind=r64), intent(in) :: x(:,:)
     integer(kind=i64), intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_integer64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_integer64

   
   logical function isWithinTolerance_3D_integer32(x, tolerance, norm)
!     integer (kind=r32), intent(in) :: x(:,:,:)
     integer(kind=i32), intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_integer32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_integer32

   
   logical function isWithinTolerance_3D_integer64(x, tolerance, norm)
!     integer (kind=r64), intent(in) :: x(:,:,:)
     integer(kind=i64), intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_integer64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_integer64

   
   logical function isWithinTolerance_4D_integer32(x, tolerance, norm)
!     integer (kind=r32), intent(in) :: x(:,:,:,:)
     integer(kind=i32), intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_integer32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_integer32

   
   logical function isWithinTolerance_4D_integer64(x, tolerance, norm)
!     integer (kind=r64), intent(in) :: x(:,:,:,:)
     integer(kind=i64), intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_integer64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_integer64

   
   logical function isWithinTolerance_5D_integer32(x, tolerance, norm)
!     integer (kind=r32), intent(in) :: x(:,:,:,:,:)
     integer(kind=i32), intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_integer32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_integer32

   
   logical function isWithinTolerance_5D_integer64(x, tolerance, norm)
!     integer (kind=r64), intent(in) :: x(:,:,:,:,:)
     integer(kind=i64), intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_integer64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_integer64

! end interface isWithinTolerance implementations
! interface assertGreaterThan_internal implementations

    subroutine assertGreaterThan_e0_integer32_f0_integer32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    integer(kind=i32), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_integer32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_integer32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f0_integer32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f0_integer32_tol32_

       


   
    subroutine assertGreaterThan_e1_integer32_f0_integer32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    integer(kind=i32), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_integer32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_integer32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f0_integer32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f0_integer32_tol32_

       


   
    subroutine assertGreaterThan_e0_integer32_f1_integer32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    integer(kind=i32), dimension(product(fShape)), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_integer32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_integer32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f1_integer32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f1_integer32_tol32_

       


   
    subroutine assertGreaterThan_e1_integer32_f1_integer32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    integer(kind=i32), dimension(product(fShape)), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_integer32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_integer32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f1_integer32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f1_integer32_tol32_

       


   
    subroutine assertGreaterThan_e0_integer64_f0_integer32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    integer(kind=i32), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_integer32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_integer32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f0_integer32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f0_integer32_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f0_integer32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    integer(kind=i32), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_integer32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_integer32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f0_integer32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f0_integer32_tol64_

       


   
    subroutine assertGreaterThan_e0_integer64_f1_integer32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    integer(kind=i32), dimension(product(fShape)), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_integer32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_integer32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f1_integer32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f1_integer32_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f1_integer32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    integer(kind=i32), dimension(product(fShape)), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_integer32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_integer32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f1_integer32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f1_integer32_tol64_

       


   
    subroutine assertGreaterThan_e0_integer32_f0_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    integer(kind=i64), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f0_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f0_integer64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer32_f0_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    integer(kind=i64), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f0_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f0_integer64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer32_f1_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    integer(kind=i64), dimension(product(fShape)), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f1_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f1_integer64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer32_f1_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    integer(kind=i64), dimension(product(fShape)), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f1_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f1_integer64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer64_f0_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    integer(kind=i64), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f0_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f0_integer64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f0_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    integer(kind=i64), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f0_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f0_integer64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer64_f1_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    integer(kind=i64), dimension(product(fShape)), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f1_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f1_integer64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f1_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    integer(kind=i64), dimension(product(fShape)), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f1_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f1_integer64_tol64_

       


   
    subroutine assertGreaterThan_e0_real32_f0_integer32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    integer(kind=i32), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_integer32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_integer32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f0_integer32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f0_integer32_tol32_

       


   
    subroutine assertGreaterThan_e1_real32_f0_integer32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    integer(kind=i32), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_integer32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_integer32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f0_integer32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f0_integer32_tol32_

       


   
    subroutine assertGreaterThan_e0_real32_f1_integer32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    integer(kind=i32), dimension(product(fShape)), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_integer32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_integer32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f1_integer32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f1_integer32_tol32_

       


   
    subroutine assertGreaterThan_e1_real32_f1_integer32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    integer(kind=i32), dimension(product(fShape)), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_integer32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_integer32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f1_integer32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f1_integer32_tol32_

       


   
    subroutine assertGreaterThan_e0_real64_f0_integer32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    integer(kind=i32), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f0_integer32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f0_integer32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real64_f0_integer32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real64_f0_integer32_tol64_

       


   
    subroutine assertGreaterThan_e1_real64_f0_integer32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    integer(kind=i32), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f0_integer32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f0_integer32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real64_f0_integer32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real64_f0_integer32_tol64_

       


   
    subroutine assertGreaterThan_e0_real64_f1_integer32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    integer(kind=i32), dimension(product(fShape)), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f1_integer32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f1_integer32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real64_f1_integer32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real64_f1_integer32_tol64_

       


   
    subroutine assertGreaterThan_e1_real64_f1_integer32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    integer(kind=i32), dimension(product(fShape)), intent(in) :: found
    integer(kind=i32) :: found_
    integer(kind=i32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f1_integer32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f1_integer32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real64_f1_integer32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real64_f1_integer32_tol64_

       


   
    subroutine assertGreaterThan_e0_real32_f0_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    integer(kind=i64), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f0_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f0_integer64_tol64_

       


   
    subroutine assertGreaterThan_e1_real32_f0_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    integer(kind=i64), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f0_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f0_integer64_tol64_

       


   
    subroutine assertGreaterThan_e0_real32_f1_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    integer(kind=i64), dimension(product(fShape)), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f1_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f1_integer64_tol64_

       


   
    subroutine assertGreaterThan_e1_real32_f1_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    integer(kind=i64), dimension(product(fShape)), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f1_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f1_integer64_tol64_

       


   
    subroutine assertGreaterThan_e0_real64_f0_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    integer(kind=i64), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f0_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f0_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real64_f0_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real64_f0_integer64_tol64_

       


   
    subroutine assertGreaterThan_e1_real64_f0_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    integer(kind=i64), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f0_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f0_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real64_f0_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real64_f0_integer64_tol64_

       


   
    subroutine assertGreaterThan_e0_real64_f1_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    integer(kind=i64), dimension(product(fShape)), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f1_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f1_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real64_f1_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real64_f1_integer64_tol64_

       


   
    subroutine assertGreaterThan_e1_real64_f1_integer64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    integer(kind=i64), dimension(product(fShape)), intent(in) :: found
    integer(kind=i64) :: found_
    integer(kind=i64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f1_integer64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f1_integer64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real64_f1_integer64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real64_f1_integer64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer32_f0_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    real(kind=r32), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_real32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_real32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f0_real32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f0_real32_tol32_

       


   
    subroutine assertGreaterThan_e1_integer32_f0_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    real(kind=r32), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_real32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_real32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f0_real32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f0_real32_tol32_

       


   
    subroutine assertGreaterThan_e0_integer32_f1_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    real(kind=r32), dimension(product(fShape)), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_real32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_real32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f1_real32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f1_real32_tol32_

       


   
    subroutine assertGreaterThan_e1_integer32_f1_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    real(kind=r32), dimension(product(fShape)), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_real32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_real32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f1_real32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f1_real32_tol32_

       


   
    subroutine assertGreaterThan_e0_integer64_f0_real32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    real(kind=r32), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_real32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_real32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f0_real32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f0_real32_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f0_real32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    real(kind=r32), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_real32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_real32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f0_real32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f0_real32_tol64_

       


   
    subroutine assertGreaterThan_e0_integer64_f1_real32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    real(kind=r32), dimension(product(fShape)), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_real32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_real32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f1_real32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f1_real32_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f1_real32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    real(kind=r32), dimension(product(fShape)), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_real32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_real32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f1_real32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f1_real32_tol64_

       


   
    subroutine assertGreaterThan_e0_integer32_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f0_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f0_real64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer32_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f0_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f0_real64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer32_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f1_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f1_real64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer32_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f1_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f1_real64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer64_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f0_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f0_real64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f0_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f0_real64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer64_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f1_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f1_real64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f1_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f1_real64_tol64_

       


   
    subroutine assertGreaterThan_e0_real32_f0_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r32), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_real32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_real32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f0_real32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f0_real32_tol32_

       


   
    subroutine assertGreaterThan_e1_real32_f0_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r32), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_real32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_real32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f0_real32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f0_real32_tol32_

       


   
    subroutine assertGreaterThan_e0_real32_f1_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r32), dimension(product(fShape)), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_real32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_real32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f1_real32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f1_real32_tol32_

       


   
    subroutine assertGreaterThan_e1_real32_f1_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r32), dimension(product(fShape)), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_real32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_real32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f1_real32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f1_real32_tol32_

       


   
    subroutine assertGreaterThan_e0_real32_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f0_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f0_real64_tol64_

       


   
    subroutine assertGreaterThan_e1_real32_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f0_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f0_real64_tol64_

       


   
    subroutine assertGreaterThan_e0_real32_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f1_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f1_real64_tol64_

       


   
    subroutine assertGreaterThan_e1_real32_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f1_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f1_real64_tol64_

       


   
    subroutine assertGreaterThan_e0_real64_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f0_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f0_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real64_f0_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real64_f0_real64_tol64_

       


   
    subroutine assertGreaterThan_e1_real64_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f0_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f0_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real64_f0_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real64_f0_real64_tol64_

       


   
    subroutine assertGreaterThan_e0_real64_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f1_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f1_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real64_f1_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real64_f1_real64_tol64_

       


   
    subroutine assertGreaterThan_e1_real64_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f1_real64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f1_real64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (GEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LTP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (LEP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real64_f1_real64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real64_f1_real64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer32_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f0_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f0_complex32_tol32_

       


   
    subroutine assertGreaterThan_e1_integer32_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f0_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f0_complex32_tol32_

       


   
    subroutine assertGreaterThan_e0_integer32_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f1_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f1_complex32_tol32_

       


   
    subroutine assertGreaterThan_e1_integer32_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f1_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f1_complex32_tol32_

       


   
    subroutine assertGreaterThan_e0_integer64_f0_complex32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_complex32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_complex32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f0_complex32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f0_complex32_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f0_complex32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_complex32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_complex32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f0_complex32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f0_complex32_tol64_

       


   
    subroutine assertGreaterThan_e0_integer64_f1_complex32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_complex32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_complex32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f1_complex32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f1_complex32_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f1_complex32_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_complex32_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_complex32_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f1_complex32_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f1_complex32_tol64_

       


   
    subroutine assertGreaterThan_e0_integer32_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer32_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer32_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), intent(in) :: expected
    integer(kind=i32) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer32_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer32_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer32_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer32_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i32), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i32) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer32_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer32_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer32_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer64_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_integer64_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), intent(in) :: expected
    integer(kind=i64) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_integer64_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_integer64_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_integer64_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_integer64_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer(kind=i64), dimension(product(eShape)), intent(in) :: expected
    integer(kind=i64) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_integer64_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_integer64_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_integer64_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_real32_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f0_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f0_complex32_tol32_

       


   
    subroutine assertGreaterThan_e1_real32_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f0_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f0_complex32_tol32_

       


   
    subroutine assertGreaterThan_e0_real32_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f1_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f1_complex32_tol32_

       


   
    subroutine assertGreaterThan_e1_real32_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f1_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f1_complex32_tol32_

       


   
    subroutine assertGreaterThan_e0_real32_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_real32_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_real32_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real32_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real32_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real32_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_real32_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real32_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real32_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real32_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_real64_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real64_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real64_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_real64_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real64_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real64_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_real64_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_real64_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_real64_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_real64_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_real64_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_real64_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_real64_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_real64_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_complex32_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex32_f0_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex32_f0_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_complex32_f0_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_complex32_f0_complex32_tol32_

       


   
    subroutine assertGreaterThan_e1_complex32_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex32_f0_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex32_f0_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_complex32_f0_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_complex32_f0_complex32_tol32_

       


   
    subroutine assertGreaterThan_e0_complex32_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex32_f1_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex32_f1_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_complex32_f1_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_complex32_f1_complex32_tol32_

       


   
    subroutine assertGreaterThan_e1_complex32_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex32_f1_complex32_tol32_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex32_f1_complex32_tol32_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_complex32_f1_complex32_tol32_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_complex32_f1_complex32_tol32_

       


   
    subroutine assertGreaterThan_e0_complex32_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex32_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex32_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_complex32_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_complex32_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_complex32_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex32_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex32_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_complex32_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_complex32_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_complex32_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex32_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex32_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_complex32_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_complex32_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_complex32_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex32_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex32_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_complex32_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_complex32_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_complex64_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r64), intent(in) :: expected
    complex(kind=r64) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if ((expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex64_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex64_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_complex64_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_complex64_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_complex64_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r64), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r64) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex64_f0_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex64_f0_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_complex64_f0_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_complex64_f0_complex64_tol64_

       


   
    subroutine assertGreaterThan_e0_complex64_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r64), intent(in) :: expected
    complex(kind=r64) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex64_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e0_complex64_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e0_complex64_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e0_complex64_f1_complex64_tol64_

       


   
    subroutine assertGreaterThan_e1_complex64_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringConversionUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r64), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r64) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
! mlr 2013-0908 Note:  Perhaps have tolerance_ with a type depending on found... incl. logical or int.
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray
    real :: denominator

    ! Return immediately if the two are precisely equal.
    ! This is necessary to deal with identical infinities, which cannot be
    ! subtracted.
    if (comparison .eq. EQP) then
       if (all(expected == found)) return
    end if
    ! Note:  The above begs the question about how to handle Inf for non-.eq. cases...

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
!    
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
! mlr 2013-0908 Other comparisons:  tolerance-less integer comparison... logical...
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex64_f1_complex64_tol64_ select-error-1'
              OK = .false.
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              ! This case should not occur for this type-kind-rank.
              print *,'internal: assertGreaterThan_e1_complex64_f1_complex64_tol64_ select-error-2'
              OK = .false.
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & appendWithSpace(message, &
       & 'NOT: '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & unlessScalar(fShape,';  first equality at element '//trim(locationInArray))//'.'), &
       & location = location &
       ) 
    case (RELEQP)
       if (expected_ .eq. 0) then
          denominator = expected_
       else
          denominator = 1.0
       end if 
       call throw( &
       & appendWithSpace(message, &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='RELEQ: expected', &
       &   fPrefix='to be near:')) // &
       & '; '//trim(differenceReport( &
       &   abs(found_ - expected_)/denominator, tolerance_)) // &
       & unlessScalar(fShape,';  first difference at element '//trim(locationInArray))//'.'), &
       & location = location &
       )
    case default
       ! This case should not occur for this type-kind-rank.
       print *,'internal: assertGreaterThan_e1_complex64_f1_complex64_tol64_ select-error-3'
       call throw( &
       & appendWithSpace(message, &
       & 'pFUnit internal error:  unexpected comparison given type-kind-rank'), &
       & location = location &
       & )
    end select

    end if

    end subroutine assertGreaterThan_e1_complex64_f1_complex64_tol64_

       


! end interface assertGreaterThan_internal implementations
end module AssertArraysInternalassertGreaterThan_mod