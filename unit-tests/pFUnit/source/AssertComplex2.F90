

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!  This file 'AssertComplex2.F90' is automatically generated by
!  'GenerateAssertsOnArrays.py'.  Changes made here will be
!  overwritten the next time that script is run.
!
!  2013-0722 MLR Michael.L.Rilee-1@nasa.gov
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module AssertComplex2_mod

   use Params_mod
   use AssertBasic_mod
   use Exception_mod
   use SourceLocation_mod
   use StringConversionUtilities_mod
   use AssertArraysSupport_mod
   use AssertArraysInternalassertNotEqual_mod
   use AssertArraysInternalassertEqual_mod
   use AssertArraysInternalassertRelativelyEqual_mod


   implicit none
   private

   public :: assertNotEqual
   public :: assertEqual
   public :: assertRelativelyEqual


   integer, parameter :: L_INFINITY_NORM = 0
   integer, parameter :: L1_NORM         = 1
   integer, parameter :: L2_NORM         = 2

   integer, parameter :: MAXLEN_SHAPE = 80


interface assertNotEqual

   module procedure assertNotEqual_int32_0D_c32_2D_tol32
   module procedure assertNotEqual_int32_0D_c32_2D_tol32_WOTol
   module procedure assertNotEqual_r32_0D_c32_2D_tol32
   module procedure assertNotEqual_r32_0D_c32_2D_tol32_WOTol
   module procedure assertNotEqual_c32_0D_c32_2D_tol32
   module procedure assertNotEqual_c32_0D_c32_2D_tol32_WOTol
   module procedure assertNotEqual_int32_2D_c32_2D_tol32
   module procedure assertNotEqual_int32_2D_c32_2D_tol32_WOTol
   module procedure assertNotEqual_r32_2D_c32_2D_tol32
   module procedure assertNotEqual_r32_2D_c32_2D_tol32_WOTol
   module procedure assertNotEqual_c32_2D_c32_2D_tol32
   module procedure assertNotEqual_c32_2D_c32_2D_tol32_WOTol
   module procedure assertNotEqual_int32_0D_c64_2D_tol64
   module procedure assertNotEqual_int32_0D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_r32_0D_c64_2D_tol64
   module procedure assertNotEqual_r32_0D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_c32_0D_c64_2D_tol64
   module procedure assertNotEqual_c32_0D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_int64_0D_c64_2D_tol64
   module procedure assertNotEqual_int64_0D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_r64_0D_c64_2D_tol64
   module procedure assertNotEqual_r64_0D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_c64_0D_c64_2D_tol64
   module procedure assertNotEqual_c64_0D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_int32_2D_c64_2D_tol64
   module procedure assertNotEqual_int32_2D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_r32_2D_c64_2D_tol64
   module procedure assertNotEqual_r32_2D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_c32_2D_c64_2D_tol64
   module procedure assertNotEqual_c32_2D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_int64_2D_c64_2D_tol64
   module procedure assertNotEqual_int64_2D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_r64_2D_c64_2D_tol64
   module procedure assertNotEqual_r64_2D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_c64_2D_c64_2D_tol64
   module procedure assertNotEqual_c64_2D_c64_2D_tol64_WOTol
   module procedure assertNotEqual_int64_0D_r32_2D_tol64
   module procedure assertNotEqual_int64_0D_r32_2D_tol64_WOTol
   module procedure assertNotEqual_int64_2D_r32_2D_tol64
   module procedure assertNotEqual_int64_2D_r32_2D_tol64_WOTol
   module procedure assertNotEqual_int64_0D_c32_2D_tol64
   module procedure assertNotEqual_int64_0D_c32_2D_tol64_WOTol
   module procedure assertNotEqual_int64_2D_c32_2D_tol64
   module procedure assertNotEqual_int64_2D_c32_2D_tol64_WOTol

end interface assertNotEqual


interface assertEqual

   module procedure assertEqual_int32_0D_c32_2D_tol32
   module procedure assertEqual_int32_0D_c32_2D_tol32_WOTol
   module procedure assertEqual_r32_0D_c32_2D_tol32
   module procedure assertEqual_r32_0D_c32_2D_tol32_WOTol
   module procedure assertEqual_c32_0D_c32_2D_tol32
   module procedure assertEqual_c32_0D_c32_2D_tol32_WOTol
   module procedure assertEqual_int32_2D_c32_2D_tol32
   module procedure assertEqual_int32_2D_c32_2D_tol32_WOTol
   module procedure assertEqual_r32_2D_c32_2D_tol32
   module procedure assertEqual_r32_2D_c32_2D_tol32_WOTol
   module procedure assertEqual_c32_2D_c32_2D_tol32
   module procedure assertEqual_c32_2D_c32_2D_tol32_WOTol
   module procedure assertEqual_int32_0D_c64_2D_tol64
   module procedure assertEqual_int32_0D_c64_2D_tol64_WOTol
   module procedure assertEqual_r32_0D_c64_2D_tol64
   module procedure assertEqual_r32_0D_c64_2D_tol64_WOTol
   module procedure assertEqual_c32_0D_c64_2D_tol64
   module procedure assertEqual_c32_0D_c64_2D_tol64_WOTol
   module procedure assertEqual_int64_0D_c64_2D_tol64
   module procedure assertEqual_int64_0D_c64_2D_tol64_WOTol
   module procedure assertEqual_r64_0D_c64_2D_tol64
   module procedure assertEqual_r64_0D_c64_2D_tol64_WOTol
   module procedure assertEqual_c64_0D_c64_2D_tol64
   module procedure assertEqual_c64_0D_c64_2D_tol64_WOTol
   module procedure assertEqual_int32_2D_c64_2D_tol64
   module procedure assertEqual_int32_2D_c64_2D_tol64_WOTol
   module procedure assertEqual_r32_2D_c64_2D_tol64
   module procedure assertEqual_r32_2D_c64_2D_tol64_WOTol
   module procedure assertEqual_c32_2D_c64_2D_tol64
   module procedure assertEqual_c32_2D_c64_2D_tol64_WOTol
   module procedure assertEqual_int64_2D_c64_2D_tol64
   module procedure assertEqual_int64_2D_c64_2D_tol64_WOTol
   module procedure assertEqual_r64_2D_c64_2D_tol64
   module procedure assertEqual_r64_2D_c64_2D_tol64_WOTol
   module procedure assertEqual_c64_2D_c64_2D_tol64
   module procedure assertEqual_c64_2D_c64_2D_tol64_WOTol
   module procedure assertEqual_int64_0D_r32_2D_tol64
   module procedure assertEqual_int64_0D_r32_2D_tol64_WOTol
   module procedure assertEqual_int64_2D_r32_2D_tol64
   module procedure assertEqual_int64_2D_r32_2D_tol64_WOTol
   module procedure assertEqual_int64_0D_c32_2D_tol64
   module procedure assertEqual_int64_0D_c32_2D_tol64_WOTol
   module procedure assertEqual_int64_2D_c32_2D_tol64
   module procedure assertEqual_int64_2D_c32_2D_tol64_WOTol

end interface assertEqual


interface assertRelativelyEqual

   module procedure assertRelativelyEqual_int32_0D_c32_2D_tol32
   module procedure assertRelativelyEqual_int32_0D_c32_2D_tol32_WOTol
   module procedure assertRelativelyEqual_r32_0D_c32_2D_tol32
   module procedure assertRelativelyEqual_r32_0D_c32_2D_tol32_WOTol
   module procedure assertRelativelyEqual_c32_0D_c32_2D_tol32
   module procedure assertRelativelyEqual_c32_0D_c32_2D_tol32_WOTol
   module procedure assertRelativelyEqual_int32_2D_c32_2D_tol32
   module procedure assertRelativelyEqual_int32_2D_c32_2D_tol32_WOTol
   module procedure assertRelativelyEqual_r32_2D_c32_2D_tol32
   module procedure assertRelativelyEqual_r32_2D_c32_2D_tol32_WOTol
   module procedure assertRelativelyEqual_c32_2D_c32_2D_tol32
   module procedure assertRelativelyEqual_c32_2D_c32_2D_tol32_WOTol
   module procedure assertRelativelyEqual_int32_0D_c64_2D_tol64
   module procedure assertRelativelyEqual_int32_0D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_r32_0D_c64_2D_tol64
   module procedure assertRelativelyEqual_r32_0D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_c32_0D_c64_2D_tol64
   module procedure assertRelativelyEqual_c32_0D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_int64_0D_c64_2D_tol64
   module procedure assertRelativelyEqual_int64_0D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_r64_0D_c64_2D_tol64
   module procedure assertRelativelyEqual_r64_0D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_c64_0D_c64_2D_tol64
   module procedure assertRelativelyEqual_c64_0D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_int32_2D_c64_2D_tol64
   module procedure assertRelativelyEqual_int32_2D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_r32_2D_c64_2D_tol64
   module procedure assertRelativelyEqual_r32_2D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_c32_2D_c64_2D_tol64
   module procedure assertRelativelyEqual_c32_2D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_int64_2D_c64_2D_tol64
   module procedure assertRelativelyEqual_int64_2D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_r64_2D_c64_2D_tol64
   module procedure assertRelativelyEqual_r64_2D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_c64_2D_c64_2D_tol64
   module procedure assertRelativelyEqual_c64_2D_c64_2D_tol64_WOTol
   module procedure assertRelativelyEqual_int64_0D_r32_2D_tol64
   module procedure assertRelativelyEqual_int64_0D_r32_2D_tol64_WOTol
   module procedure assertRelativelyEqual_int64_2D_r32_2D_tol64
   module procedure assertRelativelyEqual_int64_2D_r32_2D_tol64_WOTol
   module procedure assertRelativelyEqual_int64_0D_c32_2D_tol64
   module procedure assertRelativelyEqual_int64_0D_c32_2D_tol64_WOTol
   module procedure assertRelativelyEqual_int64_2D_c32_2D_tol64
   module procedure assertRelativelyEqual_int64_2D_c32_2D_tol64_WOTol

end interface assertRelativelyEqual

contains
! interface assertNotEqual implementations

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int32_0D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_integer32_f1_complex32_tol32_
     call assertNotEqual_e0_integer32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int32_0D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_int32_0D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r32_0D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_real32_f1_complex32_tol32_
     call assertNotEqual_e0_real32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r32_0D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_r32_0D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c32_0D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_complex32_f1_complex32_tol32_
     call assertNotEqual_e0_complex32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c32_0D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_c32_0D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int32_2D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_integer32_f1_complex32_tol32_
     call assertNotEqual_e1_integer32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int32_2D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_int32_2D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r32_2D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_real32_f1_complex32_tol32_
     call assertNotEqual_e1_real32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r32_2D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_r32_2D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c32_2D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_complex32_f1_complex32_tol32_
     call assertNotEqual_e1_complex32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c32_2D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_c32_2D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int32_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_integer32_f1_complex64_tol64_
     call assertNotEqual_e0_integer32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int32_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_int32_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r32_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_real32_f1_complex64_tol64_
     call assertNotEqual_e0_real32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r32_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_r32_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c32_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_complex32_f1_complex64_tol64_
     call assertNotEqual_e0_complex32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c32_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_c32_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_integer64_f1_complex64_tol64_
     call assertNotEqual_e0_integer64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_int64_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r64_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_real64_f1_complex64_tol64_
     call assertNotEqual_e0_real64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r64_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_r64_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c64_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_complex64_f1_complex64_tol64_
     call assertNotEqual_e0_complex64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c64_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_c64_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int32_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_integer32_f1_complex64_tol64_
     call assertNotEqual_e1_integer32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int32_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_int32_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r32_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_real32_f1_complex64_tol64_
     call assertNotEqual_e1_real32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r32_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_r32_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c32_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_complex32_f1_complex64_tol64_
     call assertNotEqual_e1_complex32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c32_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_c32_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_integer64_f1_complex64_tol64_
     call assertNotEqual_e1_integer64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_int64_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r64_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_real64_f1_complex64_tol64_
     call assertNotEqual_e1_real64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_r64_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_r64_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c64_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_complex64_f1_complex64_tol64_
     call assertNotEqual_e1_complex64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_c64_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_c64_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_0D_r32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_integer64_f1_real32_tol64_
     call assertNotEqual_e0_integer64_f1_real32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_0D_r32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_int64_0D_r32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_2D_r32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     real(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_integer64_f1_real32_tol64_
     call assertNotEqual_e1_integer64_f1_real32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_2D_r32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     real(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_int64_2D_r32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_0D_c32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e0_integer64_f1_complex32_tol64_
     call assertNotEqual_e0_integer64_f1_complex32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_0D_c32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_int64_0D_c32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_2D_c32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertNotEqual_e1_integer64_f1_complex32_tol64_
     call assertNotEqual_e1_integer64_f1_complex32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, NEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertNotEqual_int64_2D_c32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertNotEqual_int64_2D_c32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

! end interface assertNotEqual implementations
! interface assertEqual implementations

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int32_0D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_integer32_f1_complex32_tol32_
     call assertEqual_e0_integer32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int32_0D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int32_0D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_real32_f1_complex32_tol32_
     call assertEqual_e0_real32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c32_0D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_complex32_f1_complex32_tol32_
     call assertEqual_e0_complex32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c32_0D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_c32_0D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int32_2D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_integer32_f1_complex32_tol32_
     call assertEqual_e1_integer32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int32_2D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int32_2D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_2D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_real32_f1_complex32_tol32_
     call assertEqual_e1_real32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_2D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_2D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c32_2D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_complex32_f1_complex32_tol32_
     call assertEqual_e1_complex32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c32_2D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_c32_2D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int32_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_integer32_f1_complex64_tol64_
     call assertEqual_e0_integer32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int32_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int32_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_real32_f1_complex64_tol64_
     call assertEqual_e0_real32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c32_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_complex32_f1_complex64_tol64_
     call assertEqual_e0_complex32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c32_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_c32_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_integer64_f1_complex64_tol64_
     call assertEqual_e0_integer64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int64_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_real64_f1_complex64_tol64_
     call assertEqual_e0_real64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c64_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_complex64_f1_complex64_tol64_
     call assertEqual_e0_complex64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c64_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_c64_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int32_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_integer32_f1_complex64_tol64_
     call assertEqual_e1_integer32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int32_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int32_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_real32_f1_complex64_tol64_
     call assertEqual_e1_real32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c32_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_complex32_f1_complex64_tol64_
     call assertEqual_e1_complex32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c32_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_c32_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_integer64_f1_complex64_tol64_
     call assertEqual_e1_integer64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int64_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_real64_f1_complex64_tol64_
     call assertEqual_e1_real64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c64_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_complex64_f1_complex64_tol64_
     call assertEqual_e1_complex64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_c64_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_c64_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_0D_r32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_integer64_f1_real32_tol64_
     call assertEqual_e0_integer64_f1_real32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_0D_r32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int64_0D_r32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_2D_r32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     real(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_integer64_f1_real32_tol64_
     call assertEqual_e1_integer64_f1_real32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_2D_r32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     real(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int64_2D_r32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_0D_c32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e0_integer64_f1_complex32_tol64_
     call assertEqual_e0_integer64_f1_complex32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_0D_c32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int64_0D_c32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_2D_c32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertEqual_e1_integer64_f1_complex32_tol64_
     call assertEqual_e1_integer64_f1_complex32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int64_2D_c32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int64_2D_c32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

! end interface assertEqual implementations
! interface assertRelativelyEqual implementations

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int32_0D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_integer32_f1_complex32_tol32_
     call assertRelativelyEqual_e0_integer32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int32_0D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_int32_0D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r32_0D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_real32_f1_complex32_tol32_
     call assertRelativelyEqual_e0_real32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r32_0D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_r32_0D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c32_0D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_complex32_f1_complex32_tol32_
     call assertRelativelyEqual_e0_complex32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c32_0D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_c32_0D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int32_2D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_integer32_f1_complex32_tol32_
     call assertRelativelyEqual_e1_integer32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int32_2D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_int32_2D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r32_2D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_real32_f1_complex32_tol32_
     call assertRelativelyEqual_e1_real32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r32_2D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_r32_2D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c32_2D_c32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_complex32_f1_complex32_tol32_
     call assertRelativelyEqual_e1_complex32_f1_complex32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c32_2D_c32_2D_tol32_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_c32_2D_c32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int32_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_integer32_f1_complex64_tol64_
     call assertRelativelyEqual_e0_integer32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int32_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_int32_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r32_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_real32_f1_complex64_tol64_
     call assertRelativelyEqual_e0_real32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r32_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_r32_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c32_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_complex32_f1_complex64_tol64_
     call assertRelativelyEqual_e0_complex32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c32_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_c32_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_integer64_f1_complex64_tol64_
     call assertRelativelyEqual_e0_integer64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_int64_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r64_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_real64_f1_complex64_tol64_
     call assertRelativelyEqual_e0_real64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r64_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_r64_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c64_0D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_complex64_f1_complex64_tol64_
     call assertRelativelyEqual_e0_complex64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c64_0D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r64), intent(in) :: expected
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_c64_0D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int32_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_integer32_f1_complex64_tol64_
     call assertRelativelyEqual_e1_integer32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int32_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_int32_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r32_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_real32_f1_complex64_tol64_
     call assertRelativelyEqual_e1_real32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r32_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_r32_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c32_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_complex32_f1_complex64_tol64_
     call assertRelativelyEqual_e1_complex32_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c32_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r32), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_c32_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_integer64_f1_complex64_tol64_
     call assertRelativelyEqual_e1_integer64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_int64_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r64_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_real64_f1_complex64_tol64_
     call assertRelativelyEqual_e1_real64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_r64_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_r64_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c64_2D_c64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     complex(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_complex64_f1_complex64_tol64_
     call assertRelativelyEqual_e1_complex64_f1_complex64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_c64_2D_c64_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     complex(kind=r64), intent(in) :: expected(:,:)
     complex(kind=r64), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_c64_2D_c64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_0D_r32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_integer64_f1_real32_tol64_
     call assertRelativelyEqual_e0_integer64_f1_real32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_0D_r32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_int64_0D_r32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_2D_r32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     real(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_integer64_f1_real32_tol64_
     call assertRelativelyEqual_e1_integer64_f1_real32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_2D_r32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     real(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_int64_2D_r32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_0D_c32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e0_integer64_f1_complex32_tol64_
     call assertRelativelyEqual_e0_integer64_f1_complex32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_0D_c32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_int64_0D_c32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_2D_c32_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), message=message_, location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
! 2014-0414 Call interface here instead of internal subroutine name, if possible. mlr
! assertRelativelyEqual_e1_integer64_f1_complex32_tol64_
     call assertRelativelyEqual_e1_integer64_f1_complex32_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, RELEQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertRelativelyEqual_int64_2D_c32_2D_tol64_WOTol( &
   &  expected, found, message, location )
     implicit none
     integer(kind=i64), intent(in) :: expected(:,:)
     complex(kind=r32), intent(in) :: found(:,:)

     character(len=*), optional, intent(in) :: message 
     type (SourceLocation), optional, intent(in) :: location

     call assertRelativelyEqual_int64_2D_c32_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

! end interface assertRelativelyEqual implementations
end module AssertComplex2_mod