diff -urN ../src/enkf/controlvec.f90 enkf/controlvec.f90
--- controlvec.f90	2017-05-22 19:30:35.050754000 +0000
+++ controlvec.f90	2017-06-07 16:01:16.126803000 +0000
@@ -14,7 +14,7 @@
 !  controlvec_cleanup: deallocate allocatable arrays.
 !
 ! Public Variables:
-!  nanals: (integer scalar) number of ensemble members (from module params)
+!  nanals2: (integer scalar) number of ensemble members (from module params)
 !  nlevs: number of analysis vertical levels (from module params).
 !  nbackgrounds:  number of time levels in background
 !
@@ -47,7 +47,7 @@
 use gridinfo,  only: getgridinfo, gridinfo_cleanup,                    &
                      npts, vars3d_supported, vars2d_supported
 use params,    only: nlevs, nbackgrounds, fgfileprefixes, reducedgrid, &
-                     nanals, pseudo_rh, use_qsatensmean, nlons, nlats
+                     nanals, nanals1, nanals2, nanalsorig, pseudo_rh, use_qsatensmean, nlons, nlats
 use kinds,     only: r_kind, i_kind, r_double, r_single
 use mpeu_util, only: gettablesize, gettable, getindex
 use constants, only: max_varname_length
@@ -191,8 +191,8 @@
 integer(i_kind) :: ierr
 
 ! must at least nanals tasks allocated.
-if (numproc < nanals) then
-  print *,'need at least nanals =',nanals,'MPI tasks, exiting ...'
+if (numproc < nanals2) then
+  print *,'need at least nanals2 =',nanals2,'MPI tasks, exiting ...'
   call mpi_barrier(mpi_comm_world,ierr)
   call mpi_finalize(ierr)
 end if
@@ -204,7 +204,7 @@
 
 ! read in whole control vector on i/o procs - keep in memory 
 ! (needed in write_ensemble)
-if (nproc <= nanals-1) then
+if (nproc <= nanals2-1) then
    allocate(grdin(npts,ncdim,nbackgrounds))
    allocate(qsat(npts,nlevs,nbackgrounds))
    nanal = nproc + 1
@@ -218,7 +218,7 @@
           call mpi_allreduce(mpi_in_place,qsat(1,nlev,nb),npts,mpi_real8,mpi_sum,mpi_comm_io,ierr)
        enddo
        enddo
-       qsat = qsat/real(nanals)
+       qsat = qsat/real(nanals2)
        !print *,'min/max qsat ensmean',nanal,'=',minval(qsat),maxval(qsat)
    endif
    if (nproc == 0) then
@@ -242,7 +242,7 @@
 
 subroutine write_control()
 ! write out each ensemble member to a separate file.
-! for now, first nanals tasks are IO tasks.
+! for now, first nanals2 tasks are IO tasks.
 implicit none
 real(r_double)  :: t1,t2
 integer(i_kind) :: nanal
@@ -250,7 +250,7 @@
 integer(i_kind) :: q_ind, ierr
 real(r_single), allocatable, dimension(:,:) :: grdin_mean
 
-if (nproc <= nanals-1) then
+if (nproc <= nanals2-1) then
    nanal = nproc + 1
    t1 = mpi_wtime()
    q_ind = getindex(cvars3d, 'q')
@@ -261,7 +261,10 @@
          grdin(:,(q_ind-1)*nlevs+1:q_ind*nlevs,nb)*qsat(:,:,nb)
       enddo
    end if
-   call writegriddata(nanal,cvars3d,cvars2d,nc3d,nc2d,clevels,ncdim,grdin)
+   ! only write out 1st nanalsorig (unmodulated) ensemble members
+   if (nanal <= nanalsorig) then
+       call writegriddata(nanal,cvars3d,cvars2d,nc3d,nc2d,clevels,ncdim,grdin)
+   endif
    if (nproc == 0) then
      t2 = mpi_wtime()
      print *,'time in writegriddata on root',t2-t1,'secs'
@@ -281,7 +284,7 @@
       call mpi_reduce(grdin(:,:,nb), grdin_mean, npts*ncdim, mpi_real4,   &
                       mpi_sum,0,mpi_comm_io,ierr)
       if (nproc == 0) then
-         grdin_mean = grdin_mean/real(nanals)
+         grdin_mean = grdin_mean/real(nanals2)
          do nvar=1,nc3d
             print *,'ens. mean anal. increment min/max ', cvars3d(nvar),   &
                 minval(grdin_mean(:,clevels(nvar-1)+1:clevels(nvar))),     &
@@ -309,8 +312,8 @@
 if (allocated(cvars3d)) deallocate(cvars3d)
 if (allocated(cvars2d)) deallocate(cvars2d)
 if (allocated(index_pres)) deallocate(index_pres)
-if (nproc <= nanals-1 .and. allocated(grdin)) deallocate(grdin)
-if (nproc <= nanals-1 .and. allocated(qsat)) deallocate(qsat)
+if (nproc <= nanals2-1 .and. allocated(grdin)) deallocate(grdin)
+if (nproc <= nanals2-1 .and. allocated(qsat)) deallocate(qsat)
 call gridinfo_cleanup()
 end subroutine controlvec_cleanup
 
diff -urN ../src/enkf/enkf.f90 enkf/enkf.f90
--- enkf.f90	2017-05-22 19:30:34.674582000 +0000
+++ enkf.f90	2017-06-08 02:53:25.601713000 +0000
@@ -112,7 +112,8 @@
                   biasprednorm, oberrvar_orig, probgrosserr, prpgerr,&
                   corrlengthsq,lnsigl,obtimel,obloclat,obloclon,obpress,stattype
 use constants, only: pi, one, zero
-use params, only: sprd_tol, paoverpb_thresh, datapath, nanals,&
+use params, only: sprd_tol, paoverpb_thresh, datapath, &
+                  nanals, nanals1, nanals2, nanalsorig, &
                   iassim_order,sortinc,deterministic,numiter,nlevs,&
                   zhuberleft,zhuberright,varqc,lupd_satbiasc,huber,univaroz,&
                   covl_minfact,covl_efold,nbackgrounds,nhr_anal,fhr_assim,&
@@ -139,16 +140,16 @@
 ! local variables.
 integer(i_kind) nob,nob1,nob2,nob3,npob,nf,nf2,ii,nobx,nskip,&
                 niter,i,nrej,npt,nuse,ncount,nb
-integer(i_kind) indxens1(nanals),indxens2(nanals)
-real(r_single) hxpost(nanals),hxprior(nanals),hxinc(nanals),&
+integer(i_kind) indxens1(nanalsorig),indxens2(nanalsorig)
+real(r_single) hxpost(nanalsorig),hxprior(nanalsorig),hxinc(nanalsorig),&
              dist,lnsig,obt,&
              sqrtoberr,corrlengthinv,lnsiglinv,obtimelinv
 real(r_single) corrsqr,covl_fact
 real(r_double) :: t1,t2,t3,t4,t5,t6,tbegin,tend
 real(r_single) kfgain,hpfht,hpfhtoberrinv,r_nanals,r_nanalsm1,hpfhtcon
-real(r_single) anal_obtmp(nanals),obinc_tmp,obens(nanals),obganl(nanals)
+real(r_single) anal_obtmp(nanals2),obinc_tmp,obens(nanalsorig),obganl(nanalsorig)
 real(r_single) normdepart, pnge, width
-real(r_single) buffer(nanals+2)
+real(r_single) buffer(nanals2+2)
 real(r_single),allocatable, dimension(:,:) :: anal_obchunk
 real(r_single),dimension(nobstot):: oberrvaruse
 real(r_single) r,paoverpb
@@ -166,7 +167,7 @@
 logical lastiter, kdgrid, kdobs
 
 ! allocate temporary arrays.
-allocate(anal_obchunk(nanals,nobs_max))
+allocate(anal_obchunk(nanals2,nobs_max))
 allocate(sresults1(numptsperproc(nproc+1)),taper_disgrd(numptsperproc(nproc+1)))
 allocate(sresults2(numobsperproc(nproc+1)),taper_disob(numobsperproc(nproc+1)))
 allocate(buffertmp(nobstot))
@@ -397,8 +398,8 @@
       ! send to other processors.
       if (nproc == npob) then
           nob1 = indxob_chunk(nob); 
-          hpfht = sum(anal_obchunk(:,nob1)**2)*r_nanalsm1
-          buffer(1:nanals) = anal_obchunk(:,nob1)
+          hpfht = sum(anal_obchunk(nanals1:nanals2,nob1)**2)*r_nanalsm1
+          buffer(1:nanals2) = anal_obchunk(1:nanals2,nob1)
           buffer(nanals+1) = ob(nob)-ensmean_obchunk(nob1)
           buffer(nanals+2) = hpfht
       end if
@@ -407,7 +408,7 @@
       t2 = t2 + mpi_wtime() - t1
       t1 = mpi_wtime()
 
-      anal_obtmp = buffer(1:nanals)
+      anal_obtmp = buffer(1:nanals2)
       obinc_tmp = buffer(nanals+1)
       hpfht = buffer(nanals+2)
 
@@ -431,31 +432,31 @@
 
       if (deterministic) then
          ! EnSRF.
-         obganl = -anal_obtmp/(one+sqrt(oberrvaruse(nob)*hpfhtoberrinv))
+         obganl = -anal_obtmp(1:nanalsorig)/(one+sqrt(oberrvaruse(nob)*hpfhtoberrinv))
       else
          ! perturbed obs EnKF.
          sqrtoberr=sqrt(oberrvaruse(nob))
-         do nanal=1,nanals
+         do nanal=1,nanalsorig
              obens(nanal) = sqrtoberr*rnorm()
          enddo
          ! make sure mean is zero
-         obens = obens - sum(obens)*r_nanals
+         obens = obens - sum(obens)/float(nanalsorig)
          if (sortinc) then
            ! To minimize regression errors, sort to minimize increments.
            ! ref - Anderson (2003) "A Least-Squares Framework for Ensemble Filtering"
            ! April issue, pages 634-642.
            kfgain = hpfht*hpfhtoberrinv
-           hxprior = anal_obtmp
-           hxpost = hxprior+kfgain*(obens-hxprior)
-           call quicksort(nanals, hxprior, indxens1)
-           call quicksort(nanals, hxpost, indxens2)
-           do nanal=1,nanals
+           hxprior = anal_obtmp(1:nanalsorig)
+           hxpost = hxprior(1:nanalsorig)+kfgain*(obens-hxprior)
+           call quicksort(nanalsorig, hxprior, indxens1)
+           call quicksort(nanalsorig, hxpost, indxens2)
+           do nanal=1,nanalsorig
               hxinc(indxens1(nanal)) = hxpost(indxens2(nanal)) - hxprior(indxens1(nanal))
            end do
            ! re-order ob perturbations to minimize increments.
            obens = hxinc/kfgain + hxprior
          end if
-         obganl = obens - anal_obtmp
+         obganl = obens - anal_obtmp(1:nanalsorig)
       end if
 
       t3 = t3 + mpi_wtime() - t1
@@ -572,11 +573,11 @@
                 if (taperv(nnn) > zero) then
                     ! gain includes covariance localization.
                     ! update all time levels
-                    kfgain=taperv(nnn)*sum(anal_chunk(:,i,nn,nb)*anal_obtmp)
+                    kfgain=taperv(nnn)*sum(anal_chunk(nanals1:nanals2,i,nn,nb)*anal_obtmp(nanals1:nanals2))
                     ! update mean.
                     ensmean_chunk(i,nn,nb) = ensmean_chunk(i,nn,nb) + kfgain*obinc_tmp
                     ! update perturbations.
-                    anal_chunk(:,i,nn,nb) = anal_chunk(:,i,nn,nb) + kfgain*obganl(:)
+                    anal_chunk(1:nanalsorig,i,nn,nb) = anal_chunk(1:nanalsorig,i,nn,nb) + kfgain*obganl
                 end if
              end do
           end do ! end loop over background time levels. 
@@ -601,18 +602,19 @@
                ! gain includes covariance localization.
                kfgain = taper_disob(nob1)* &
                         taper(lnsig*lnsiglinv)*taper(obt*obtimelinv)* &
-                        sum(anal_obchunk(:,nob2)*anal_obtmp)*hpfhtcon
+                        sum(anal_obchunk(nanals1:nanals2,nob2)*anal_obtmp(nanals1:nanals2))*hpfhtcon
                ! update mean.
                ensmean_obchunk(nob2) = ensmean_obchunk(nob2) + kfgain*obinc_tmp
                ! update perturbations.
-               anal_obchunk(:,nob2) = anal_obchunk(:,nob2) + kfgain*obganl
+               anal_obchunk(1:nanalsorig,nob2) = anal_obchunk(1:nanalsorig,nob2) + &
+               kfgain*obganl
                nob3 = indxproc_obs(nproc+1,nob2) ! index in 1,....,nobstot
                ! recompute ob space spread ratio  for unassimlated obs
                if (iassim_order == 2 .and. niter == 1) then
                  if (indxassim2(nob3) /= 0) then
                    paoverpb_chunk(nob2) = &
                    oberrvar(nob3)/(oberrvar(nob3)+&
-                   sum(anal_obchunk(:,nob2)**2)*r_nanalsm1)
+                   sum(anal_obchunk(nanals1:nanals2,nob2)**2)*r_nanalsm1)
                  else
                    paoverpb_chunk(nob2) = 1.e10
                  endif
@@ -636,8 +638,8 @@
      do npt=1,npts_max
         do nb=1,nbackgrounds
            do i=1,ncdim
-              anal_chunk(1:nanals,npt,i,nb) = anal_chunk(1:nanals,npt,i,nb)-&
-              sum(anal_chunk(1:nanals,npt,i,nb),1)*r_nanals
+              anal_chunk(1:nanalsorig,npt,i,nb) = anal_chunk(1:nanalsorig,npt,i,nb)-&
+              sum(anal_chunk(1:nanalsorig,npt,i,nb),1)/float(nanalsorig)
            end do
         end do
      enddo
@@ -645,8 +647,8 @@
   endif
   !$omp parallel do schedule(dynamic) private(nob)
   do nob=1,nobs_max
-     anal_obchunk(1:nanals,nob) = anal_obchunk(1:nanals,nob)-&
-     sum(anal_obchunk(1:nanals,nob),1)*r_nanals
+     anal_obchunk(1:nanalsorig,nob) = anal_obchunk(1:nanalsorig,nob)-&
+     sum(anal_obchunk(1:nanalsorig,nob),1)/float(nanalsorig)
   enddo
   !$omp end parallel do
 
@@ -704,7 +706,7 @@
 buffertmp=zero
 do nob1=1,numobsperproc(nproc+1)
   nob2=indxproc_obs(nproc+1,nob1)
-  buffertmp(nob2) = sum(anal_obchunk(:,nob1)**2)*r_nanalsm1
+  buffertmp(nob2) = sum(anal_obchunk(nanals1:nanals2,nob1)**2)*r_nanalsm1
 end do
 call mpi_allreduce(buffertmp,obsprd_post,nobstot,mpi_real4,mpi_sum,mpi_comm_world,ierr)
 if (nproc == 0) print *,'time to broadcast obsprd_post = ',mpi_wtime()-t1
diff -urN ../src/enkf/enkf_main.f90 enkf/enkf_main.f90
--- enkf_main.f90	2017-05-22 19:30:34.818153000 +0000
+++ enkf_main.f90	2017-06-07 16:02:30.215690000 +0000
@@ -32,7 +32,7 @@
 ! program history log:
 !   2009-02-23  Initial version.
 !   2011-06-03  Added the option for LETKF.
-!   2016-02-01  Initialize mpi communicator for IO tasks (1st nanals tasks).
+!   2016-02-01  Initialize mpi communicator for IO tasks (1st nanals2 tasks).
 !   2016-05-02  shlyaeva: Modification for reading state vector from table
 !   2016-11-29  shlyaeva: Initialize state vector separately from control; 
 !               separate routines for scatter and gather chunks; write out diag files
@@ -74,7 +74,8 @@
  use kinds, only: r_kind,r_double,i_kind
  ! reads namelist parameters.
  use params, only : read_namelist,letkf_flag,readin_localization,lupd_satbiasc,&
-                    numiter, nanals, lupd_obspace_serial, write_spread_diag,   &
+                    numiter, nanals, nanals1, nanals2, nanalsorig, &
+                    lupd_obspace_serial, write_spread_diag,   &
                     lobsdiag_forenkf
  ! mpi functions and variables.
  use mpisetup, only:  mpi_initialize, mpi_initialize_io, mpi_cleanup, nproc, &
@@ -121,7 +122,7 @@
  call read_namelist()
 
  ! initialize MPI communicator for IO tasks.
- call mpi_initialize_io(nanals)
+ call mpi_initialize_io(nanals2)
 
  ! Initialize derived radinfo variables
  call init_rad_vars()
diff -urN ../src/enkf/enkf_obsmod.f90 enkf/enkf_obsmod.f90
--- enkf_obsmod.f90	2017-05-22 19:30:34.800373000 +0000
+++ enkf_obsmod.f90	2017-06-08 02:56:47.834188000 +0000
@@ -97,7 +97,7 @@
 use kinds, only : r_kind, r_double, i_kind, r_single
 use constants, only: zero, one, deg2rad, rad2deg, rd, cp, pi
 use params, only: & 
-      datestring,datapath,sprd_tol,nanals,saterrfact, &
+      datestring,datapath,sprd_tol,nanals,nanals1,nanals2,nanalsorig,saterrfact, &
       lnsigcutoffnh, lnsigcutoffsh, lnsigcutofftr, corrlengthnh,&
       corrlengthtr, corrlengthsh, obtimelnh, obtimeltr, obtimelsh,&
       lnsigcutoffsatnh, lnsigcutoffsatsh, lnsigcutoffsattr,&
@@ -196,7 +196,7 @@
                 obsprd_prior, ensmean_obnobc, ensmean_ob, ob,                 &
                 oberrvar, obloclon, obloclat, obpress,                        &
                 obtime, oberrvar_orig, stattype, obtype, biaspreds, diagused, &
-                anal_ob,indxsat,nanals)
+                anal_ob,indxsat,nanals1,nanals2)
 
 tdiff = mpi_wtime()-t1
 call mpi_reduce(tdiff,tdiffmax,1,mpi_real4,mpi_max,0,mpi_comm_world,ierr)
diff -urN ../src/enkf/letkf.F90 enkf/letkf.F90
--- letkf.F90	2017-05-22 19:30:34.989722000 +0000
+++ letkf.F90	2017-06-16 19:25:07.858092000 +0000
@@ -93,12 +93,13 @@
                   iassim_order,sortinc,deterministic,nlevs,&
                   zhuberleft,zhuberright,varqc,lupd_satbiasc,huber,letkf_novlocal,&
                   lupd_obspace_serial,corrlengthnh,corrlengthtr,corrlengthsh,&
-                  nbackgrounds,nobsl_max
+                  nbackgrounds,nobsl_max,neigv,denkf,nanals1,nanals2,nanalsorig,dfs_sort
 use radinfo, only: npred,nusis,nuchan,jpch_rad,predx
 use radbias, only: apply_biascorr, update_biascorr
 use gridinfo, only: nlevs_pres,lonsgrd,latsgrd,logp,npts,gridloc
 use kdtree2_module, only: kdtree2, kdtree2_create, kdtree2_destroy, &
                           kdtree2_result, kdtree2_n_nearest, kdtree2_r_nearest
+use sorting, only: quicksort, isort
 
 implicit none
 
@@ -118,9 +119,9 @@
                 nobslocal_min,nobslocal_max, &
                 nobslocal_minall,nobslocal_maxall
 integer(i_kind),allocatable,dimension(:) :: oindex
-real(r_single) :: deglat, dist, corrsq
+real(r_single) :: deglat, dist, corrsq, oberrfact, gain
 real(r_double) :: t1,t2,t3,t4,t5,tbegin,tend,tmin,tmax,tmean
-real(r_kind) r_nanals,r_nanalsm1,r_scalefact
+real(r_kind) r_nanals,r_nanalsm1
 real(r_kind) normdepart, pnge, width
 real(r_kind),dimension(nobstot):: oberrvaruse
 real(r_kind) vdist
@@ -130,12 +131,13 @@
 ! For LETKF core processes
 real(r_kind),allocatable,dimension(:,:) :: hxens
 real(r_single),allocatable,dimension(:,:) :: obperts,obens
-real(r_single),allocatable,dimension(:) :: kfgain
-real(r_kind),allocatable,dimension(:) :: rdiag,dep,rloc
+real(r_single),allocatable,dimension(:) :: kfgain, dfs
+real(r_kind),allocatable,dimension(:) :: rdiag,dep,rloc,statesprd_prior
 real(r_kind),dimension(nanals,nanals) :: trans
 real(r_kind),dimension(nanals) :: work,work2
 ! kdtree stuff
 type(kdtree2_result),dimension(:),allocatable :: sresults
+integer(i_kind), dimension(:), allocatable :: indxassim, indxob
 #ifdef MPI3
 ! pointers used for MPI-3 shared memory manipulations.
 real(r_single), pointer, dimension(:,:) :: anal_ob_fp ! Fortran pointer
@@ -143,7 +145,7 @@
 real(r_single), pointer, dimension(:,:) :: obperts_fp ! Fortran pointer
 type(c_ptr)                             :: obperts_cp ! C pointer
 integer disp_unit, shm_win, shm_win2
-integer(MPI_ADDRESS_KIND) :: win_size, nsize
+integer(MPI_ADDRESS_KIND) :: win_size, nsize, win_size2, nsize2
 integer(MPI_ADDRESS_KIND) :: segment_size
 #endif
 real(r_single), allocatable, dimension(:) :: buffer
@@ -156,21 +158,21 @@
 ! define a few frequently used parameters
 r_nanals=one/float(nanals)
 r_nanalsm1=one/float(nanals-1)
-r_scalefact = sqrt(float(nanals)/float(nanals-1))
 
 ! create random numbers for perturbed obs on root task.
 if (.not. deterministic .and. nproc .eq. 0) then
+   ! nanalsorig is original (un-modulated) ensemble size
    call set_random_seed(iseed_perturbed_obs,nproc)
-   allocate(obperts(nanals, nobstot))
+   allocate(obperts(nanalsorig, nobstot))
    do nob=1,nobstot
       sqrtoberr=sqrt(oberrvar(nob))
-      do nanal=1,nanals
+      do nanal=1,nanalsorig
          obperts(nanal,nob) = sqrtoberr*rnorm()
       enddo
       ! make mean/variance are exact.
-      obperts(1:nanals,nob) = obperts(1:nanals,nob) - &
-                              sum(obperts(:,nob))*r_nanals
-      obperts(1:nanals,nob) = obperts(1:nanals,nob)*sqrtoberr/(sqrt(sum(obperts(:,nob)**2)*r_nanalsm1))
+      obperts(:,nob) = obperts(:,nob) - &
+                       sum(obperts(:,nob))/float(nanalsorig)
+      obperts(:,nob) = obperts(:,nob)*sqrtoberr/(sqrt(sum(obperts(:,nob)**2)/float(nanalsorig-1)))
    enddo
 endif
 
@@ -181,27 +183,30 @@
 ! shared window size will be zero except on root task of
 ! shared memory group on each node.
 disp_unit = num_bytes_for_r_single ! anal_ob is r_single
-nsize = nobstot*nanals
+nsize = nobstot*nanals2
+nsize2 = nobstot*nanalsorig
 if (nproc_shm == 0) then
    win_size = nsize*disp_unit
+   win_size2 = nsize2*disp_unit
 else
    win_size = 0
+   win_size2 = 0
 endif
 call MPI_Win_allocate_shared(win_size, disp_unit, MPI_INFO_NULL,&
                              mpi_comm_shmem, anal_ob_cp, shm_win, ierr)
 if (.not. deterministic) then
-   call MPI_Win_allocate_shared(win_size, disp_unit, MPI_INFO_NULL,&
+   call MPI_Win_allocate_shared(win_size2, disp_unit, MPI_INFO_NULL,&
                                 mpi_comm_shmem, obperts_cp, shm_win2, ierr)
 endif
 if (nproc_shm == 0) then
    ! create shared memory segment on each shared mem comm
    call MPI_Win_lock(MPI_LOCK_EXCLUSIVE,0,MPI_MODE_NOCHECK,shm_win,ierr)
-   call c_f_pointer(anal_ob_cp, anal_ob_fp, [nanals, nobstot])
+   call c_f_pointer(anal_ob_cp, anal_ob_fp, [nanals2, nobstot])
    ! bcast entire obs prior ensemble from root task 
    ! to a single task on each node, assign to shared memory window.
    ! send one ensemble member at a time.
    allocate(buffer(nobstot))
-   do nanal=1,nanals
+   do nanal=1,nanals2
       if (nproc == 0) buffer(1:nobstot) = anal_ob(nanal,1:nobstot)
       if (nproc_shm == 0) then
          call mpi_bcast(buffer,nobstot,mpi_real4,0,mpi_comm_shmemroot,ierr)
@@ -210,8 +215,8 @@
    end do
    if (.not. deterministic) then
       call MPI_Win_lock(MPI_LOCK_EXCLUSIVE,0,MPI_MODE_NOCHECK,shm_win2,ierr)
-      call c_f_pointer(obperts_cp, obperts_fp, [nanals, nobstot])
-      do nanal=1,nanals
+      call c_f_pointer(obperts_cp, obperts_fp, [nanalsorig, nobstot])
+      do nanal=1,nanalsorig
          if (nproc == 0) buffer(1:nobstot) = obperts(nanal,1:nobstot)
          if (nproc_shm == 0) then
             call mpi_bcast(buffer,nobstot,mpi_real4,0,mpi_comm_shmemroot,ierr)
@@ -237,26 +242,26 @@
 ! associate fortran pointer with c pointer to shared memory 
 ! segment (containing observation prior ensemble) on each task.
 call MPI_Win_shared_query(shm_win, 0, segment_size, disp_unit, anal_ob_cp, ierr)
-call c_f_pointer(anal_ob_cp, anal_ob_fp, [nanals, nobstot])
+call c_f_pointer(anal_ob_cp, anal_ob_fp, [nanals2, nobstot])
 if (.not. deterministic) then
    call MPI_Win_shared_query(shm_win2, 0, segment_size, disp_unit, obperts_cp, ierr)
-   call c_f_pointer(obperts_cp, obperts_fp, [nanals, nobstot])
+   call c_f_pointer(obperts_cp, obperts_fp, [nanalsorig, nobstot])
 endif
 #else
 ! if MPI3 not available, need anal_ob on every MPI task
 ! broadcast observation prior ensemble from root one ensemble member at a time.
 allocate(buffer(nobstot))
 ! allocate anal_ob on non-root tasks
-if (nproc .ne. 0) allocate(anal_ob(nanals,nobstot))
+if (nproc .ne. 0) allocate(anal_ob(nanals2,nobstot))
 ! bcast anal_ob from root one member at a time.
-do nanal=1,nanals
+do nanal=1,nanals2
    buffer(1:nobstot) = anal_ob(nanal,1:nobstot)
    call mpi_bcast(buffer,nobstot,mpi_real4,0,mpi_comm_world,ierr)
    if (nproc .ne. 0) anal_ob(nanal,1:nobstot) = buffer(1:nobstot)
 end do
 if (.not. deterministic) then
-   if (nproc .ne. 0) allocate(obperts(nanals,nobstot))
-   do nanal=1,nanals
+   if (nproc .ne. 0) allocate(obperts(nanalsorig,nobstot))
+   do nanal=1,nanalsorig
       buffer(1:nobstot) = obperts(nanal,1:nobstot)
       call mpi_bcast(buffer,nobstot,mpi_real4,0,mpi_comm_world,ierr)
       if (nproc .ne. 0) obperts(nanal,1:nobstot) = buffer(1:nobstot)
@@ -347,12 +352,16 @@
 nobslocal_max = -999
 nobslocal_min = nobstot
 
+if (nobsl_max > 0 .and. dfs_sort) then
+    allocate(statesprd_prior(ncdim))
+endif
+
 ! Update ensemble on model grid.
 ! Loop for each horizontal grid points on this task.
 !$omp parallel do schedule(dynamic) private(npt,nob,nobsl, &
-!$omp                  nobsl2,ngrd1,corrlength, &
-!$omp                  nf,vdist,kfgain,obens, &
-!$omp                  nn,hxens,rdiag,dep,rloc,i,work,work2,trans, &
+!$omp                  gain,nobsl2,oberrfact,ngrd1,corrlength, &
+!$omp                  nf,vdist,kfgain,obens,indxassim,indxob, &
+!$omp                  nn,hxens,dfs,rdiag,dep,rloc,i,work,work2,trans, &
 !$omp                  oindex,deglat,dist,corrsq,nb,sresults) &
 !$omp  reduction(+:t1,t2,t3,t4,t5) &
 !$omp  reduction(max:nobslocal_max) &
@@ -366,14 +375,61 @@
    deglat = latsgrd(ngrd1)*rad2deg
    corrlength=latval(deglat,corrlengthnh,corrlengthtr,corrlengthsh)
    corrsq = corrlength**2
+   allocate(sresults(nobstot))
    ! kd-tree fixed range search
    if (nobsl_max > 0) then ! only use nobsl_max nearest obs (sorted by distance).
-       allocate(sresults(nobsl_max))
-       call kdtree2_n_nearest(tp=kdtree_obs2,qv=grdloc_chunk(:,npt),nn=nobsl_max,&
-            results=sresults)
-       nobsl = nobsl_max
+       if (dfs_sort) then ! sort by DFS instead of distance.
+          do i=1,ncdim ! state space ensemble spread for column being updated
+             statesprd_prior(i) =  &
+             sqrt(sum(anal_chunk(nanals1:nanals2,npt,i,(nbackgrounds/2)+1)**2)*r_nanalsm1)
+          enddo
+          allocate(dfs(nobstot))
+          allocate(rloc(nobstot))
+          allocate(indxob(nobstot))
+          ! calculate integrated DFS for each ob in local volume
+          nobsl = 0
+          do nob=1,nobstot
+             rloc(nob) = sum((obloc(:,nob)-grdloc_chunk(:,npt))**2,1)
+             dist = sqrt(rloc(nob)/corrlengthsq(nob))
+             if (dist < 1.0 - tiny(dist) .and. &
+                 oberrvaruse(nob) < 1.e10_r_single) then
+                nobsl = nobsl + 1
+                dfs(nobsl) = 0.
+                indxob(nobsl) = nob
+                oberrfact = taper(dist)
+                do i=1,ncdim
+#ifdef MPI3
+                    gain = sum(anal_chunk(nanals1:nanals2,npt,i,(nbackgrounds/2)+1)*anal_ob_fp(nanals1:nanals2,nob))*r_nanalsm1
+#else
+                    gain = sum(anal_chunk(nanals1:nanals2,npt,i,(nbackgrounds/2)+1)*anal_ob(nanals1:nanals2,nob))*r_nanalsm1
+#endif
+! DFS is estimated increment normalized by spread, summed over all variables in column, for middle of window
+                    gain = gain/(obsprd_prior(nob) + oberrvaruse(nob)/oberrfact)
+                    gain = gain/statesprd_prior(i)
+                    dfs(nobsl) = dfs(nobsl)+abs(gain*(ob(nob)-ensmean_ob(nob)))
+                enddo
+             endif
+          enddo
+          ! sort on DFS
+          allocate(indxassim(nobsl))
+          call quicksort(nobsl,dfs(1:nobsl),indxassim)
+          nf = 0 ! results ordered by DFS, largest to smallest
+          nobsl2 = min(nobsl_max,nobsl)
+          do nob=nobsl,nobsl-nobsl2+1,-1
+             nf = nf + 1
+             sresults(nf)%dis = rloc(indxob(indxassim(nob)))
+             sresults(nf)%idx = indxob(indxassim(nob))
+             !if (nproc == 0 .and. npt == 1) &
+             !print *,nf,sresults(nf)%idx,dfs(indxassim(nob)),sqrt(sresults(nf)%dis/corrlengthsq(sresults(nf)%idx)),obtype(sresults(nf)%idx)
+          enddo
+          deallocate(rloc,dfs,indxassim,indxob)
+          nobsl = nobsl2
+       else
+          call kdtree2_n_nearest(tp=kdtree_obs2,qv=grdloc_chunk(:,npt),nn=nobsl_max,&
+               results=sresults)
+          nobsl = nobsl_max
+       endif
    else ! find all obs within localization radius (sorted by distance).
-       allocate(sresults(nobstot))
        call kdtree2_r_nearest(tp=kdtree_obs2,qv=grdloc_chunk(:,npt),r2=corrsq,&
             nfound=nobsl,nalloc=nobstot,results=sresults)
    endif
@@ -420,9 +476,9 @@
       do nob=1,nobsl2
          nf=oindex(nob)
 #ifdef MPI3
-         hxens(1:nanals,nob)=anal_ob_fp(1:nanals,nf) 
+         hxens(1:nanals,nob)=anal_ob_fp(nanals1:nanals2,nf) 
 #else
-         hxens(1:nanals,nob)=anal_ob(1:nanals,nf) 
+         hxens(1:nanals,nob)=anal_ob(nanals1:nanals2,nf) 
 #endif
          rdiag(nob)=one/oberrvaruse(nf)
          dep(nob)=ob(nf)-ensmean_ob(nf)
@@ -432,15 +488,15 @@
       t1 = mpi_wtime()
 
       if (.not. deterministic) then
-         allocate(kfgain(nobsl2),obens(nobsl2,nanals))
+         allocate(kfgain(nobsl2),obens(nobsl2,nanalsorig))
          ! add ob perts to observation priors
          do nob=1,nobsl2
             nf = oindex(nob)
-            obens(nob,1:nanals) = &
+            obens(nob,1:nanalsorig) = &
 #ifdef MPI3
-            obperts_fp(1:nanals,nf) + anal_ob_fp(1:nanals,nf) 
+            obperts_fp(1:nanalsorig,nf) + anal_ob_fp(1:nanalsorig,nf) 
 #else
-            obperts(1:nanals,nf) + anal_ob(1:nanals,nf) 
+            obperts(1:nanalsorig,nf) + anal_ob(1:nanalsorig,nf) 
 #endif
          enddo
       endif
@@ -464,7 +520,7 @@
          ! if not vlocal, update all state variables in column.
          if(vlocal .and. index_pres(i) /= nn) cycle
          if (deterministic) then
-            work(1:nanals) = anal_chunk(1:nanals,npt,i,nb)
+            work(1:nanals) = anal_chunk(nanals1:nanals2,npt,i,nb)
             work2(1:nanals) = ensmean_chunk(npt,i,nb)
             if(r_kind == kind(1.d0)) then
                call dgemv('t',nanals,nanals,1.d0,trans,nanals,work,1,1.d0, &
@@ -474,16 +530,31 @@
                     & work2,1)
             end if
             ensmean_chunk(npt,i,nb) = sum(work2(1:nanals)) * r_nanals
-            anal_chunk(1:nanals,npt,i,nb) = work2(1:nanals)-ensmean_chunk(npt,i,nb)
-         else ! perturbed obs using LETKF gain.
+            anal_chunk(nanals1:nanals2,npt,i,nb) = work2(1:nanals)-ensmean_chunk(npt,i,nb)
+         else ! use K/2 to update perts, or K with perturbed obs.
             do nob=1,nobsl2
-               kfgain(nob) = sum(hxens(:,nob)*anal_chunk(:,npt,i,nb))
+               kfgain(nob) = sum(hxens(nanals1:nanals2,nob)*anal_chunk(nanals1:nanals2,npt,i,nb))
             enddo
             ensmean_chunk(npt,i,nb) = ensmean_chunk(npt,i,nb) + sum(kfgain*dep)
-            do nanal=1,nanals
-               anal_chunk(nanal,npt,i,nb) = anal_chunk(nanal,npt,i,nb) - &
-               sum(kfgain*obens(:,nanal))
-            enddo
+            if (denkf) then
+               if (neigv > 0) then
+                  ! modulated ensemble, only update original ensemble
+                  do nanal=1,nanalsorig
+                     anal_chunk(nanal,npt,i,nb) = anal_chunk(nanal,npt,i,nb) - &
+                     sum(0.5*kfgain*obens(:,nanal))
+                  enddo
+               else 
+                  do nanal=1,nanalsorig
+                     anal_chunk(nanal,npt,i,nb) = anal_chunk(nanal,npt,i,nb) - &
+                     sum(0.5*kfgain*obens(:,nanal))
+                  enddo
+               endif
+            else
+               do nanal=1,nanalsorig
+                  anal_chunk(nanal,npt,i,nb) = anal_chunk(nanal,npt,i,nb) - &
+                  sum(kfgain*obens(:,nanal))
+               enddo
+            endif
          endif
       enddo
       enddo
@@ -500,14 +571,16 @@
 end do grdloop
 !$omp end parallel do
 
+if (allocated(statesprd_prior)) deallocate(statesprd_prior)
+
 ! make sure posterior perturbations still have zero mean.
 ! (roundoff errors can accumulate)
 !$omp parallel do schedule(dynamic) private(npt,nb,i)
 do npt=1,npts_max
    do nb=1,nbackgrounds
       do i=1,ncdim
-         anal_chunk(1:nanals,npt,i,nb) = anal_chunk(1:nanals,npt,i,nb)-&
-         sum(anal_chunk(1:nanals,npt,i,nb),1)*r_nanals
+         anal_chunk(1:nanalsorig,npt,i,nb) = anal_chunk(1:nanalsorig,npt,i,nb)-&
+         sum(anal_chunk(1:nanalsorig,npt,i,nb),1)/float(nanalsorig)
       end do
    end do
 enddo
diff -urN ../src/enkf/loadbal.f90 enkf/loadbal.f90
--- loadbal.f90	2017-05-22 19:30:35.324090000 +0000
+++ loadbal.f90	2017-06-07 16:06:04.211261000 +0000
@@ -61,7 +61,7 @@
 !  obtime_chunk(nobs_max): (serial enkf only) real array of ob times of ob priors
 !   being updated on this task (expressed as an offset from the analysis time in
 !   hours).
-!  anal_obchunk_prior(nanals,nobs_max): (serial enkf only) real array of observation prior 
+!  anal_obchunk_prior(nanals2,nobs_max): (serial enkf only) real array of observation prior 
 !   ensemble perturbations to be updated on this task (not used in LETKF).
 !  kdtree_grid: pointer to kd-tree structure used for nearest neighbor searches
 !   for model grid points (only searches grid points assigned to this task).
@@ -69,9 +69,9 @@
 !   for observations (only searches ob locations assigned to this task).
 !  kdtree_obs2: (LETKF only) pointer to kd-tree structure used for nearest neighbor searches
 !   for observations (searches all observations)
-!  anal_chunk(nanals,npts_max,ncdim,nbackgrounds): real array of ensemble perturbations
+!  anal_chunk(nanals2,npts_max,ncdim,nbackgrounds): real array of ensemble perturbations
 !   updated on each task.
-!  anal_chunk_prior(nanals,npts_max,ncdim,nbackgrounds): real array of prior ensemble
+!  anal_chunk_prior(nanals2,npts_max,ncdim,nbackgrounds): real array of prior ensemble
 !   perturbations.  Before analysis anal_chunk=anal_chunk_prior, after
 !   analysis anal_chunk contains posterior perturbations.
 !  ensmean_chunk(npts_max,ncdim,nbackgrounds): real array containing pieces of ensemble
@@ -97,7 +97,7 @@
 !$$$
 
 use mpisetup
-use params, only: datapath, nanals, simple_partition, letkf_flag,&
+use params, only: datapath, nanals2, simple_partition, letkf_flag,&
                   corrlengthnh, corrlengthsh, corrlengthtr, lupd_obspace_serial
 use enkf_obsmod, only: nobstot, obloc, oblnp, ensmean_ob, obtime, anal_ob, corrlengthsq
 use kinds, only: r_kind, i_kind, r_double, r_single
@@ -286,32 +286,32 @@
        print *,'time to do ob space decomp = ',mpi_wtime()-t1
    end if
    ! for serial enkf, send out observation priors to be updated on each processor.
-   allocate(anal_obchunk_prior(nanals,nobs_max))
+   allocate(anal_obchunk_prior(nanals2,nobs_max))
    if(nproc == 0) then
       print *,'sending out observation prior ensemble perts from root ...'
       totsize = nobstot
-      totsize = totsize*nanals
-      print *,'nobstot*nanals',totsize
+      totsize = totsize*nanals2
+      print *,'nobstot*nanals2',totsize
       t1 = mpi_wtime()
       ! send one big message to each task.
       do np=1,numproc-1
          do nob1=1,numobsperproc(np+1)
             nob2 = indxproc_obs(np+1,nob1)
-            anal_obchunk_prior(1:nanals,nob1) = anal_ob(1:nanals,nob2)
+            anal_obchunk_prior(1:nanals2,nob1) = anal_ob(1:nanals2,nob2)
          end do
-         call mpi_send(anal_obchunk_prior,nobs_max*nanals,mpi_real4,np, &
+         call mpi_send(anal_obchunk_prior,nobs_max*nanals2,mpi_real4,np, &
               1,mpi_comm_world,ierr)
       end do
       ! anal_obchunk_prior on root (no send necessary)
       do nob1=1,numobsperproc(1)
          nob2 = indxproc_obs(1,nob1)
-         anal_obchunk_prior(1:nanals,nob1) = anal_ob(1:nanals,nob2)
+         anal_obchunk_prior(1:nanals2,nob1) = anal_ob(1:nanals2,nob2)
       end do
       ! now we don't need anal_ob anymore for serial EnKF.
       if (.not. lupd_obspace_serial) deallocate(anal_ob)
    else
       ! recv one large message on each task.
-      call mpi_recv(anal_obchunk_prior,nobs_max*nanals,mpi_real4,0, &
+      call mpi_recv(anal_obchunk_prior,nobs_max*nanals2,mpi_real4,0, &
            1,mpi_comm_world,mpi_status,ierr)
    end if
    call mpi_barrier(mpi_comm_world, ierr)
@@ -368,7 +368,7 @@
 do np=0,numproc-1
    displs(np) = np*npts_max*ncdim
 enddo
-if (nproc <= nanals-1) then
+if (nproc <= nanals2-1) then
    scounts = npts_max*ncdim
 else
    scounts = 0
@@ -377,7 +377,7 @@
 ! on
 ! task np.
 do np=0,numproc-1
-   if (np <= nanals-1) then
+   if (np <= nanals2-1) then
       rcounts(np) = npts_max*ncdim
    else
       rcounts(np) = 0
@@ -385,10 +385,10 @@
 enddo
 
 ! allocate array to hold pieces of state vector on each proc.
-allocate(anal_chunk(nanals,npts_max,ncdim,nbackgrounds))
+allocate(anal_chunk(nanals2,npts_max,ncdim,nbackgrounds))
 if (nproc == 0) print *,'anal_chunk size = ',size(anal_chunk)
 
-allocate(anal_chunk_prior(nanals,npts_max,ncdim,nbackgrounds))
+allocate(anal_chunk_prior(nanals2,npts_max,ncdim,nbackgrounds))
 allocate(ensmean_chunk(npts_max,ncdim,nbackgrounds))
 allocate(ensmean_chunk_prior(npts_max,ncdim,nbackgrounds))
 ensmean_chunk = 0.
@@ -398,7 +398,7 @@
 ! send and receive buffers.
 do nb=1,nbackgrounds ! loop over time levels in background
 
-if (nproc <= nanals-1) then
+if (nproc <= nanals2-1) then
    ! fill up send buffer.
    do np=1,numproc
      do nn=1,ncdim
@@ -416,14 +416,15 @@
 !$omp parallel do schedule(dynamic,1)  private(nn,i,nanal,n)
 do nn=1,ncdim
    do i=1,numptsperproc(nproc+1)
-      do nanal=1,nanals
+      do nanal=1,nanals2
          n = ((nanal-1)*ncdim + (nn-1))*npts_max + i
          anal_chunk(nanal,i,nn,nb) = recvbuf(n)
       enddo
-      ensmean_chunk(i,nn,nb) = sum(anal_chunk(:,i,nn,nb))/float(nanals)
+      ensmean_chunk(i,nn,nb) = sum(anal_chunk(:,i,nn,nb))/float(nanals2)
       ensmean_chunk_prior(i,nn,nb) = ensmean_chunk(i,nn,nb)
 ! remove mean from ensemble.
-      do nanal=1,nanals
+! when neigv>0,  mean of 1:nanals1 must be the same as mean of nanals1:nanals2!
+      do nanal=1,nanals2
          anal_chunk(nanal,i,nn,nb) = anal_chunk(nanal,i,nn,nb)-ensmean_chunk(i,nn,nb)
          anal_chunk_prior(nanal,i,nn,nb)=anal_chunk(nanal,i,nn,nb)
       end do
@@ -455,14 +456,14 @@
 ! scounts is number of data elements to send to processor np.
 ! rcounts is number of data elements to recv from processor np.
 ! displs is displacement into send array for data to go to proc np
-if (nproc <= nanals-1) then
+if (nproc <= nanals2-1) then
    rcounts = npts_max*ncdim
 else
    rcounts = 0
 endif
 do np=0,numproc-1
    displs(np) = np*npts_max*ncdim
-   if (np <= nanals-1) then
+   if (np <= nanals2-1) then
       scounts(np) = npts_max*ncdim
    else
       scounts(np) = 0
@@ -474,7 +475,7 @@
 do nb=1,nbackgrounds ! loop over time levels in background
   do nn=1,ncdim
    do i=1,numptsperproc(nproc+1)
-    do nanal=1,nanals
+    do nanal=1,nanals2
       n = ((nanal-1)*ncdim + (nn-1))*npts_max + i
       ! add ensemble mean back in.
       sendbuf(n) = anal_chunk(nanal,i,nn,nb)+ensmean_chunk(i,nn,nb)
@@ -485,7 +486,7 @@
   enddo
   call mpi_alltoallv(sendbuf, scounts, displs, mpi_real4, recvbuf, rcounts, displs,&
                      mpi_real4, mpi_comm_world, ierr)
-  if (nproc <= nanals-1) then
+  if (nproc <= nanals2-1) then
      do np=1,numproc
       do nn=1,ncdim
        do i=1,numptsperproc(np)
diff -urN ../src/enkf/Makefile.dependency.gfs enkf/Makefile.dependency.gfs
--- Makefile.dependency.gfs	2017-05-22 19:30:35.035924000 +0000
+++ Makefile.dependency.gfs	2017-06-15 18:54:17.319142000 +0000
@@ -9,7 +9,7 @@
 inflation.o : inflation.f90 smooth_gfs.o loadbal.o gridinfo_gfs.o controlvec.o covlocal.o  params.o mpisetup.o 
 innovstats.o : innovstats.f90   params.o enkf_obsmod.o 
 kdtree2.o : kdtree2.f90 
-letkf.o : letkf.F90 gridinfo_gfs.o radbias.o  params.o  enkf_obsmod.o controlvec.o loadbal.o covlocal.o mpisetup.o 
+letkf.o : letkf.F90 gridinfo_gfs.o radbias.o  params.o  enkf_obsmod.o controlvec.o loadbal.o covlocal.o mpisetup.o sorting.o
 loadbal.o : loadbal.f90 rnorm.o gridinfo_gfs.o kdtree2.o enkf_obsmod.o params.o mpisetup.o controlvec.o
 mpi_readobs.o : mpi_readobs.f90 mpisetup.o readozobs.o readsatobs.o readconvobs.o  params.o 
 mpisetup.o : mpisetup.F90  
diff -urN ../src/enkf/mpi_readobs.f90 enkf/mpi_readobs.f90
--- mpi_readobs.f90	2017-05-22 19:30:35.184229000 +0000
+++ mpi_readobs.f90	2017-06-08 02:57:00.830981000 +0000
@@ -51,7 +51,7 @@
                       sprd_ob, ensmean_ob, ensmean_obbc, ob, &
                       oberr, oblon, oblat, obpress, &
                       obtime, oberrorig, obcode, obtype, &
-                      biaspreds, diagused,  anal_ob, indxsat, nanals)
+                      biaspreds, diagused,  anal_ob, indxsat, nanals1, nanals2)
     character*500, intent(in) :: obspath
     character*10, intent(in) :: datestring
     character(len=10) :: id,id2
@@ -60,14 +60,14 @@
     integer(i_kind), allocatable, dimension(:) :: diagused
     real(r_single), allocatable, dimension(:,:) :: biaspreds
     real(r_single), allocatable, dimension(:,:) :: anal_ob
-    real(r_single), allocatable, dimension(:)      :: mem_ob 
-    real(r_single) :: analsi,analsim1
+    real(r_single), allocatable, dimension(:)   :: mem_ob 
+    real(r_single) :: analsim1
     real(r_double) t1,t2
     character(len=20), allocatable,  dimension(:) ::  obtype
     integer(i_kind) nob, ierr, iozproc, isatproc, &
             nobs_conv, nobs_oz, nobs_sat, nobs_tot, nanal
     integer(i_kind) :: nobs_convdiag, nobs_ozdiag, nobs_satdiag, nobs_totdiag
-    integer(i_kind), intent(in) :: nanals
+    integer(i_kind), intent(in) :: nanals1,nanals2
     iozproc=max(0,min(1,numproc-1))
     isatproc=max(0,min(2,numproc-2))
 ! get total number of conventional and sat obs for ensmean.
@@ -89,7 +89,7 @@
     if (nobs_tot > 0) then
        if (nproc == 0) then
           ! this array only needed on root.
-          allocate(anal_ob(nanals,nobs_tot))
+          allocate(anal_ob(nanals2,nobs_tot))
        end if
        ! these arrays needed on all processors.
        allocate(mem_ob(nobs_tot)) 
@@ -107,7 +107,7 @@
     nanal = nproc+1
     id = 'ensmean'
     id2 = id
-    if (nanal <= nanals) then
+    if (nanal <= nanals2) then
        write(id2,'(a3,(i3.3))') 'mem',nanal
     endif
 ! read obs.
@@ -183,11 +183,11 @@
 
 ! use mpi_send/mpi_recv to gather ob prior ensemble on root.
 ! a bit slower, but does not require large temporary array like mpi_gather.
-    if (nproc <= nanals-1) then
+    if (nproc <= nanals2-1) then
      if (nproc == 0) then
         t1 = mpi_wtime()
         anal_ob(1,:) = mem_ob(:)
-        do nanal=2,nanals
+        do nanal=2,nanals2
            call mpi_recv(mem_ob,nobs_tot,mpi_real4,nanal-1, &
                          1,mpi_comm_io,mpi_status,ierr)
            anal_ob(nanal,:) = mem_ob(:)
@@ -199,19 +199,18 @@
         ! send to root.
         call mpi_send(mem_ob,nobs_tot,mpi_real4,0,1,mpi_comm_io,ierr)
      end if 
-    end if ! nanal <= nanals
+    end if ! nanal <= nanals2
 
 ! make anal_ob contain ob prior ensemble *perturbations*
     if (nproc == 0) then
-        analsi=1._r_single/float(nanals)
-        analsim1=1._r_single/float(nanals-1)
+        analsim1=1._r_single/float(nanals2-nanals1+1)
 !$omp parallel do private(nob,nanal)
         do nob=1,nobs_tot
 ! remove ensemble mean from each member.
 ! ensmean_ob is unbiascorrected ensemble mean (anal_ob
            anal_ob(:,nob) = anal_ob(:,nob)-ensmean_ob(nob)
 ! compute sprd
-           sprd_ob(nob) = sum(anal_ob(:,nob)**2)*analsim1
+           sprd_ob(nob) = sum(anal_ob(nanals1:nanals2,nob)**2)*analsim1
         enddo
 !$omp end parallel do
        print *, 'prior spread conv: ', minval(sprd_ob(1:nobs_conv)), maxval(sprd_ob(1:nobs_conv))
diff -urN ../src/enkf/params.f90 enkf/params.f90
--- params.f90	2017-05-22 19:30:34.690671000 +0000
+++ params.f90	2017-06-15 16:12:46.020618000 +0000
@@ -78,6 +78,7 @@
 logical, public :: deterministic, sortinc, pseudo_rh, &
                    varqc, huber, cliptracers, readin_localization
 integer(i_kind),public ::  iassim_order,nlevs,nanals,numiter,&
+                           nanals1,nanals2,nanalsorig,&
                            nlons,nlats,nbackgrounds,nstatefields
 integer(i_kind),public :: nsats_rad,nsats_oz
 ! random seed for perturbed obs (deterministic=.false.)
@@ -107,6 +108,10 @@
 ! localization radius will be used. Ignored
 ! if letkf_flag = .false.
 integer,public :: nobsl_max = -1
+! for modulated ensemble, neigv is the number of
+! eigenvectors of the vertical localization matrix
+! if neigv=0, ob space localization is used
+integer,public :: neigv = 0
 logical,public :: params_initialized = .true.
 logical,public :: save_inflation = .false.
 ! do sat bias correction update.
@@ -129,6 +134,10 @@
 ! next two are no longer used, instead they are inferred from anavinfo
 logical,public :: massbal_adjust = .false. 
 logical,public :: nvars = -1 
+! Use Sakov's 'deterministic EnKF' approx. (K/2 used for pert update)
+logical,public :: denkf = .false.
+! sort obs in LETKF in order of decreasing DFS
+logical,public :: dfs_sort = .false.
 ! if true, use ensemble mean qsat in definition of
 ! normalized humidity analysis variable (instead of
 ! qsat for each member, which is the default behavior
@@ -158,7 +167,7 @@
                    newpc4pred,nmmb,nhr_anal,nhr_state, fhr_assim,nbackgrounds,nstatefields, &
                    save_inflation,nobsl_max,lobsdiag_forenkf,&
                    letkf_flag,massbal_adjust,use_edges,emiss_bc,iseed_perturbed_obs,npefiles,&
-                   write_spread_diag
+                   neigv,denkf,write_spread_diag,dfs_sort,write_spread_diag
 namelist /nam_wrf/arw,nmm
 namelist /satobs_enkf/sattypes_rad,dsis
 namelist /ozobs_enkf/sattypes_oz
@@ -320,6 +329,21 @@
 latboundmm=-latbound-p5delat
 delatinv=1.0_r_single/delat
 
+! if neigv > 0, use modulated ensemble to compute Kalman gain (but use
+! this K to update original only ensemble).
+! first nanals members are original ensemble, last neigv*nanals are modulated
+! members.
+if (neigv > 0) then
+   nanals1 = nanals + 1 ! starting member for ensemble used to calculate covariances
+   nanals2 = nanals*(neigv + 1) ! ending member for ensemble used to calc cov
+   nanalsorig = nanals ! original ensemble size
+   nanals = nanals2-nanals1+1 ! nanals*neigv: total number of members in ens used to calc cov (modulated ensemble)
+else
+   nanals1 = 1
+   nanals2 = nanals
+   nanalsorig = nanals
+endif
+
 ! have to do ob space update for serial filter (not for LETKF).
 if ((.not. letkf_flag .or. lupd_obspace_serial) .and. numiter < 1) numiter = 1
 
@@ -337,9 +361,9 @@
       print *,nlons,nlats,nlevs,nanals
       call stop2(19)
    end if
-   if (numproc .lt. nanals) then
-      print *,'total number of mpi tasks must be >= nanals'
-      print *,'tasks, nanals = ',numproc,nanals
+   if (numproc .lt. nanals2) then
+      print *,'total number of mpi tasks must be >= nanals2'
+      print *,'tasks, nanals2 = ',numproc,nanals2
       call stop2(19)
    endif
    if (datapath == ' ') then
@@ -361,7 +385,13 @@
    
    print *, trim(adjustl(datapath))
    if (datestring .ne. '0000000000') print *, 'analysis time ',datestring
-   print *, nanals,' members'
+   if (neigv > 0) then
+      print *,nanalsorig,' (unmodulated) members'
+      print *,neigv,' eigenvectors for vertical localization'
+      print *,nanals,' modulated ensemble members'
+   else
+      print *,nanals,' members'
+   endif
 
 ! check for deprecated namelist variables
    if (nvars > 0 .or. massbal_adjust) then
diff -urN ../src/enkf/readconvobs.f90 enkf/readconvobs.f90
--- readconvobs.f90	2017-05-22 19:30:35.420446000 +0000
+++ readconvobs.f90	2017-06-07 16:08:32.084946000 +0000
@@ -213,7 +213,7 @@
                             x_lon, x_lat, x_press, x_time, x_code,         &
                             x_errorig, x_type, x_used, id, nanal)
   use sparsearr, only: sparr2, sparr, readarray, delete, assignment(=), size
-  use params, only: nanals, lobsdiag_forenkf
+  use params, only: nanals2, lobsdiag_forenkf
   use statevec, only: state_d
   use mpisetup, only: nproc, mpi_wtime
   use observer_enkf, only: calc_linhx
@@ -267,9 +267,9 @@
   iunit = 7
   iunit2 = 17
 
-  twofiles = (.not. lobsdiag_forenkf) .and. (nanal <= nanals)
+  twofiles = (.not. lobsdiag_forenkf) .and. (nanal <= nanals2)
   id2 = 'ensmean'
-  if (nanal <= nanals) then
+  if (nanal <= nanals2) then
      write(id2,'(a3,(i3.3))') 'mem',nanal
   endif
 
@@ -445,7 +445,7 @@
           if (obtype == ' rw')   x_type(nob) = '  u'
 
           ! get Hx
-          if (nanal <= nanals) then
+          if (nanal <= nanals2) then
              ! read full Hx from file
              if (.not. lobsdiag_forenkf) then
                 if (obtype == 'gps') then
@@ -524,7 +524,7 @@
              x_type(nob)  = '  v'
 
              ! run linearized hx
-             if (nanal <= nanals) then
+             if (nanal <= nanals2) then
                 ! read full Hx
                 if (.not. lobsdiag_forenkf) then
                    hx(nob) = rdiagbuf(20,n)-rdiagbuf2(22,n)
@@ -608,7 +608,7 @@
   
   enddo peloop ! ipe loop
 
-  if (nanal == nanals) print *,'time in calc_linhx for conv obs on proc',nproc,' =',tsum
+  if (nanal == nanals2) print *,'time in calc_linhx for conv obs on proc',nproc,' =',tsum
   if (nob .ne. nobs_max) then
       print *,'number of obs not what expected in get_convobs_data',nob,nobs_max
       call stop2(94)
diff -urN ../src/enkf/readozobs.f90 enkf/readozobs.f90
--- readozobs.f90	2017-05-22 19:30:34.864359000 +0000
+++ readozobs.f90	2017-06-07 16:08:47.885036000 +0000
@@ -127,7 +127,7 @@
            x_lon, x_lat, x_press, x_time, x_code, x_errorig, x_type, x_used, id, nanal)
 
   use sparsearr,only:sparr, sparr2, readarray, delete, assignment(=)
-  use params,only: nanals, lobsdiag_forenkf
+  use params,only: nanals2, lobsdiag_forenkf
   use statevec, only: state_d
   use mpisetup, only: mpi_wtime, nproc
   use observer_enkf, only: calc_linhx
@@ -179,9 +179,9 @@
   errorlimit=1._r_kind/sqrt(1.e9_r_kind)
   errorlimit2=1._r_kind/sqrt(1.e-6_r_kind)
 
-  twofiles = (.not. lobsdiag_forenkf) .and. (nanal <= nanals)
+  twofiles = (.not. lobsdiag_forenkf) .and. (nanal <= nanals2)
   id2 = 'ensmean'
-  if (nanal <= nanals) then
+  if (nanal <= nanals2) then
      write(id2,'(a3,(i3.3))') 'mem',nanal
   endif
 
@@ -315,7 +315,7 @@
              hx_mean(nob) = rdiagbuf(1,k,n)-rdiagbuf(2,k,n)
              hx_mean_nobc(nob) = rdiagbuf(1,k,n)-rdiagbuf(2,k,n)
              x_type(nob) = ' oz                 '
-             if (nanal <= nanals) then
+             if (nanal <= nanals2) then
                ! read full Hx from diag file
                if (.not. lobsdiag_forenkf) then
                   hx(nob) = rdiagbuf(1,k,n)-rdiagbuf2(2,k,n)
@@ -352,7 +352,7 @@
          if(twofiles) close(iunit2)
       enddo peloop ! ipe
   enddo ! satellite
-  if (nanal == nanals) print *,'time in calc_linhx for oz obs on proc',nproc,' = ',tsum
+  if (nanal == nanals2) print *,'time in calc_linhx for oz obs on proc',nproc,' = ',tsum
 
   if (nob /= nobs_max) then
       print *,'number of obs not what expected in get_ozobs_data',nob,nobs_max
diff -urN ../src/enkf/readsatobs.f90 enkf/readsatobs.f90
--- readsatobs.f90	2017-05-22 19:30:34.833727000 +0000
+++ readsatobs.f90	2017-06-07 16:08:40.261335000 +0000
@@ -152,7 +152,7 @@
 subroutine get_satobs_data(obspath, datestring, nobs_max, nobs_maxdiag, hx_mean, hx_mean_nobc, hx, x_obs, x_err, &
            x_lon, x_lat, x_press, x_time, x_channum, x_errorig, x_type, x_biaspred, x_indx, x_used, id, nanal)
   use radinfo, only: iuse_rad,nusis,jpch_rad,npred,adp_anglebc,emiss_bc
-  use params, only: nanals, lobsdiag_forenkf
+  use params, only: nanals2, lobsdiag_forenkf
   use statevec, only: state_d
   use constants, only: deg2rad, zero
   use mpisetup, only: nproc, mpi_wtime
@@ -209,9 +209,9 @@
   npred_radiag=npred
   lverbose=.false.
 
-  twofiles = (.not. lobsdiag_forenkf) .and. (nanal <= nanals)
+  twofiles = (.not. lobsdiag_forenkf) .and. (nanal <= nanals2)
   id2 = 'ensmean'
-  if (nanal <= nanals) then
+  if (nanal <= nanals2) then
      write(id2,'(a3,(i3.3))') 'mem',nanal
   endif
 
@@ -335,7 +335,7 @@
          ! un-bias corrected Hx
          hx_mean_nobc(nobs) = x_obs(nobs) - data_chan(n)%omgnbc
 
-         if (nanal <= nanals) then
+         if (nanal <= nanals2) then
             ! read full Hx
             if (.not. lobsdiag_forenkf) then
                hx(nobs) = x_obs(nobs) - data_chan2(n)%omgnbc
@@ -395,8 +395,8 @@
 
      enddo peloop ! ipe
  enddo ! satellite
- if (nanal == nanals) print *,'time in calc_linhx for sat obs on proc',nproc,' = ',tsum
- if (nanal == nanals) print *,'time in read_raddiag_data for sat obs on proc',nproc,' = ',tsum2
+ if (nanal == nanals2) print *,'time in calc_linhx for sat obs on proc',nproc,' = ',tsum
+ if (nanal == nanals2) print *,'time in read_raddiag_data for sat obs on proc',nproc,' = ',tsum2
 
   if (nobs /= nobs_max) then
       print *,'number of obs not what expected in get_satobs_data',nobs,nobs_max
diff -urN ../src/enkf/statevec.f90 enkf/statevec.f90
--- statevec.f90	2017-06-06 03:00:36.464946000 +0000
+++ statevec.f90	2017-06-07 15:57:28.229059000 +0000
@@ -13,7 +13,7 @@
 !  statevec_cleanup: deallocate allocatable arrays.
 !
 ! Public Variables:
-!  nanals: (integer scalar) number of ensemble members (from module params)
+!  nanals2: (integer scalar) number of ensemble members (from module params)
 !  nlevs: number of analysis vertical levels (from module params).
 !  ns3d: number of 3D variables
 !  ns2d: number of 2D variables
@@ -43,7 +43,7 @@
 use mpisetup
 use gridinfo, only: getgridinfo, gridinfo_cleanup,               &
                     npts, vars3d_supported, vars2d_supported
-use params, only: nlevs,nstatefields,nanals,statefileprefixes
+use params, only: nlevs,nstatefields,nanals,nanals1,nanals2,nanalsorig,statefileprefixes
 use kinds, only: r_kind, i_kind, r_double, r_single
 use mpeu_util, only: gettablesize, gettable, getindex
 use constants, only : max_varname_length
@@ -170,8 +170,8 @@
 integer(i_kind) ierr
 
 ! must at least nanals tasks allocated.
-if (numproc < nanals) then
-  print *,'need at least nanals =',nanals,'MPI tasks, exiting ...'
+if (numproc < nanals2) then
+  print *,'need at least nanals2 =',nanals2,'MPI tasks, exiting ...'
   call mpi_barrier(mpi_comm_world,ierr)
   call mpi_finalize(ierr)
 end if
@@ -182,7 +182,7 @@
 end if
 
 ! read in whole state vector on i/o procs - keep in memory 
-if (nproc <= nanals-1) then
+if (nproc <= nanals2-1) then
    allocate(state_d(npts,nsdim,nstatefields))
    allocate(qsat(npts,nlevs,nstatefields))
    nanal = nproc + 1
@@ -195,7 +195,9 @@
      do i = 1, nsdim
        state_mean = state_d(:,i,nb)
        call mpi_allreduce(mpi_in_place,state_mean,npts,mpi_real4,mpi_sum,mpi_comm_io,ierr)
-       state_mean = state_mean/real(nanals)
+       ! note: mean of original and modulated ensemble must be the same,
+       ! so that mean of total ensemble (modulated + original) is the same.
+       state_mean = state_mean/real(nanals2)
        state_d(:,i,nb) = state_d(:,i,nb) - state_mean
      enddo
    enddo
@@ -210,7 +212,7 @@
 ! deallocate module-level allocatable arrays.
 if (allocated(svars3d)) deallocate(svars3d)
 if (allocated(svars2d)) deallocate(svars2d)
-if (nproc <= nanals-1 .and. allocated(state_d)) deallocate(state_d)
+if (nproc <= nanals2-1 .and. allocated(state_d)) deallocate(state_d)
 call gridinfo_cleanup()
 end subroutine statevec_cleanup
 
