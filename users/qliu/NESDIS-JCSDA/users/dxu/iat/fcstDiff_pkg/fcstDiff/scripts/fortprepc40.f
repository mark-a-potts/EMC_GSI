      PROGRAM FORPRE
C
C
C     FORTRAN PREPROCESSOR.
C
C
      CHARACTER*1      CARD(72)
      INTEGER          NFT
      DATA             NFT            /8/
      CHARACTER*1      NUM
      DATA             NUM            /'#'/
      CHARACTER*1      PER
      DATA             PER            /'%'/
C
      CHARACTER*80     FILES
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /BPATH/
C     NOPATH - TOTAL NUMBER OF PATHS.
C     LNPATH - LENGTH OF EACH PATH.
C     PATH   - ARRAY OF PATHS.
      COMMON  /BPATH/  NOPATH,
     1                 LNPATH(20),
     2                 PATH(72,20)
      CHARACTER*1      PATH
C
C
C
C     DESCRIPTION OF COMMON /EXTRA/
C     WHEN LREPVR=0, # VARIABLES ARE NOT REPLACED WITH VALUES.
C     WHEN LREPVR=1, # VARIABLES ARE     REPLACED WITH VALUES.
C     NOVREP - NUMBER OF # SIGNS     NOT REPLACED WITH VALUES;
C            - WHEN LREPVR=1.
C     NOVNEW - NUMBER OF # VARIABLES THAT MAY NOT BE INITIALIZED;
C            - WHEN LREPVR=1.
C     LTABLE - TABLE FOR CHARACTERS (UPPER AND LOWER CASE LETTERS,
C            - NUMBERS) TO BE DETECTED.
C     ILOWER, IUPPER - LOWER AND UPPER CASE 'I'.
C     NLOWER, NUPPER - LOWER AND UPPER CASE 'N'.
C     CLOWER, CUPPER - LOWER AND UPPER CASE 'C'.
C     LLOWER, LUPPER - LOWER AND UPPER CASE 'L'.
C     ULOWER, UUPPER - LOWER AND UPPER CASE 'U'.
C     DLOWER, DUPPER - LOWER AND UPPER CASE 'D'.
C     ELOWER, EUPPER - LOWER AND UPPER CASE 'E'.
      COMMON  /EXTRA/  LREPVR,
     1                 NOVREP,
     2                 NOVNEW,
     3                 LTABLE(256),
     4                 ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
      CHARACTER*1      ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
C
C
C
      PRINT 120
120   FORMAT (/ ' BEGINNING OF FORTRAN PREPROCESSOR. '
     1        / ' CRAY VERSION 6.           FEBRUARY 6, 1998. '
     2        / ' PRINTS DIRECTORY/FILENAME OF EACH %INCLUDE. '
     3        / ' A BLANK IS NOT PLACED BEFORE AND AFTER'
     4          ' REPLACED VARIABLES. '
     5        / ' PRINTS VARIABLE INITIALIZATIONS. ')
C
      DO 130 J=1,80
             FILES(J:J) = ' '
130   CONTINUE
      PRINT 135
135   FORMAT (/ ' ENTER  INPUT FILE NAME. ')
      READ (5,140) FILES
140   FORMAT (A80)
      OPEN (NFT, ERR=930, FILE=FILES, FORM='FORMATTED', STATUS='OLD')
      PRINT 150, FILES
150   FORMAT (' INPUT  FILE NAME IS ' / 1X, A80)
C
      DO 160 J=1,80
             FILES(J:J) = ' '
160   CONTINUE
      PRINT 165
165   FORMAT (/ ' ENTER OUTPUT FILE NAME. ')
      READ (5,140) FILES
      OPEN (9, ERR=950, FILE=FILES, FORM='FORMATTED', STATUS='OLD')
      PRINT 170, FILES
170   FORMAT (' OUTPUT FILE NAME IS ' / 1X, A80)
C
C     WRITE THREE RECORDS IN FT09F001.
      WRITE (9,172)
172   FORMAT ('C     OUTPUT OF FORTRAN PREPROCESSOR' /
     1        'C     HAS NO PROCESSED RECORDS.' /
     2        '      STOP' /
     3        '      END' )
      REWIND 9
C
      DO 176 J=1,80
             FILES(J:J) = ' '
176   CONTINUE
      PRINT 178
178   FORMAT (/ ' ENTER  PATHS FILE NAME. ')
      READ (5,140) FILES
      OPEN (10, ERR=970, FILE=FILES, FORM='FORMATTED', STATUS='OLD')
      PRINT 180, FILES
180   FORMAT (' PATHS  FILE NAME IS ' / 1X, A80)
C
      NOPATH = 0
      DO 192 K=1,20
      DO 182 J=1,72
             PATH(J,K) = ' '
182   CONTINUE
      READ (10,300,END=194) (PATH(J,K), J=1,72)
      LEN = 0
      DO 184 J=1,72
             IF (PATH(J,K) .EQ. ' ')  GO TO 186
             LEN = LEN + 1
184   CONTINUE
186   CONTINUE
      LNPATH(K) = LEN
      IF (LEN .EQ. 0)  THEN
             PRINT 188, (PATH(J,K), J=1,72)
188          FORMAT (/ ' ********** ERROR - ZERO LENGTH OF PATH '
     1       / 1X, 72A1)
             PRINT 910
             STOP  110
             ENDIF
      NOPATH = NOPATH + 1
      PRINT 190, NOPATH, (PATH(J,K), J=1,LEN)
190   FORMAT (' PATH ', I2, '=', 72A1)
192   CONTINUE
194   CONTINUE
      IF (NOPATH .EQ. 0)  THEN
             PRINT 195
195          FORMAT (/ ' ********** ERROR - NO PATHS ')
             PRINT 910
             STOP  120
      ENDIF
      CLOSE (10, STATUS='KEEP')
C
C
      ILOWER = 'I'
      NLOWER = 'N'
      CLOWER = 'C'
      LLOWER = 'L'
      ULOWER = 'U'
      DLOWER = 'D'
      ELOWER = 'E'
      IUPPER = ILOWER
      NUPPER = NLOWER
      CUPPER = CLOWER
      LUPPER = LLOWER
      UUPPER = ULOWER
      DUPPER = DLOWER
      EUPPER = ELOWER
      NSEQI  = ICHAR(ILOWER)
      NSEQN  = ICHAR(NLOWER)
      NSEQC  = ICHAR(CLOWER)
      NSEQL  = ICHAR(LLOWER)
      NSEQU  = ICHAR(ULOWER)
      NSEQD  = ICHAR(DLOWER)
      NSEQE  = ICHAR(ELOWER)
C
C     CHANGE ASCII UPPERCASE LETTERS TO LOWERCASE LETTERS.
      IF ( (NSEQI.GE.65) .AND. (NSEQI.LE. 90) )  ILOWER=CHAR(NSEQI+32)
      IF ( (NSEQN.GE.65) .AND. (NSEQN.LE. 90) )  NLOWER=CHAR(NSEQN+32)
      IF ( (NSEQC.GE.65) .AND. (NSEQC.LE. 90) )  CLOWER=CHAR(NSEQC+32)
      IF ( (NSEQL.GE.65) .AND. (NSEQL.LE. 90) )  LLOWER=CHAR(NSEQL+32)
      IF ( (NSEQU.GE.65) .AND. (NSEQU.LE. 90) )  ULOWER=CHAR(NSEQU+32)
      IF ( (NSEQD.GE.65) .AND. (NSEQD.LE. 90) )  DLOWER=CHAR(NSEQD+32)
      IF ( (NSEQE.GE.65) .AND. (NSEQE.LE. 90) )  ELOWER=CHAR(NSEQE+32)
C     CHANGE ASCII LOWERCASE LETTERS TO UPPERCASE LETTERS.
      IF ( (NSEQI.GE.97) .AND. (NSEQI.LE.122) )  IUPPER=CHAR(NSEQI-32)
      IF ( (NSEQN.GE.97) .AND. (NSEQN.LE.122) )  NUPPER=CHAR(NSEQN-32)
      IF ( (NSEQC.GE.97) .AND. (NSEQC.LE.122) )  CUPPER=CHAR(NSEQC-32)
      IF ( (NSEQL.GE.97) .AND. (NSEQL.LE.122) )  LUPPER=CHAR(NSEQL-32)
      IF ( (NSEQU.GE.97) .AND. (NSEQU.LE.122) )  UUPPER=CHAR(NSEQU-32)
      IF ( (NSEQD.GE.97) .AND. (NSEQD.LE.122) )  DUPPER=CHAR(NSEQD-32)
      IF ( (NSEQE.GE.97) .AND. (NSEQE.LE.122) )  EUPPER=CHAR(NSEQE-32)
C
C
      NOVREP = 0
      PRINT 196
196   FORMAT (/ ' IF FOURTH RECORD IS PRESENT, ',
     1        / ' # VARIABLES ARE NOT REPLACED WITH VALUES. ',
     2        / ' IF FOURTH RECORD IS NOT PRESENT, ',
     3        / ' # VARIABLES ARE REPLACED WITH VALUES. ')
      READ (5,140,END=198) FILES
      PRINT 197
197   FORMAT (/ ' FOURTH RECORD IS PRESENT. ',
     1        / ' # VARIABLES ARE NOT REPLACED WITH VALUES. ')
      LREPVR = 0
      GO TO 230
198   CONTINUE
      PRINT 199
199   FORMAT (/ ' FOURTH RECORD IS NOT PRESENT. ',
     1        / ' # VARIABLES ARE REPLACED WITH VALUES. ')
      LREPVR = 1
C
C
      NOVNEW = 0
      DO 212 J=1,256
             LTABLE(J) = 0
212   CONTINUE
C     DETECT ASCII NUMBERS.
      DO 214 J=48,57
             LTABLE(J+1) = 1
214   CONTINUE
C     DETECT ASCII UPPER CASE LETTERS.
      DO 216 J=65,90
             LTABLE(J+1) = 1
216   CONTINUE
C     DETECT ASCII LOWER CASE LETTERS.
      DO 218 J=97,122
             LTABLE(J+1) = 1
218   CONTINUE
C
C
230   CONTINUE
      DO 250 J=1,72
             CARD(J) = ' '
250   CONTINUE
      READ (NFT,300,END=800) CARD
300   FORMAT (72A1)
C
      DO 400 J=1,72
            IPT = J
            IF ( CARD(J) .EQ. NUM )  GO TO 600
            IF ( CARD(J) .EQ. PER )  GO TO 700
400   CONTINUE
C
      DO 450 J=72,1,-1
            LAST = J
            IF ( CARD(J) .NE. ' ' )  GO TO 460
450   CONTINUE
460   CONTINUE
C
CC    NOCARD = NOCARD + 1
      WRITE (9,300) (CARD(J), J=1,LAST)
CC500 FORMAT (72A1, I5, 3X)
      GO TO 230
C
600   CONTINUE
C     CALL VARBLE TO PROCESS A CARD WITH A VARIABLE NAME.
      CALL VARBLE (CARD, IPT)
      GO TO 230
C
700   CONTINUE
C     CALL PERCNT TO PROCESS A CONTROL CARD.
      CALL PERCNT (CARD, IPT, NFT)
      GO TO 230
C
800   CONTINUE
      CLOSE (NFT, STATUS='KEEP')
      CLOSE (  9, STATUS='KEEP')
C
C
      IF   ( NOVREP .EQ. 1 )   PRINT 912, NOVREP
      IF   ( NOVREP .GT. 1 )   PRINT 914, NOVREP
      IF   ( NOVNEW .EQ. 1 )   PRINT 916, NOVNEW
      IF   ( NOVNEW .GT. 1 )   PRINT 918, NOVNEW
      PRINT 910
910   FORMAT (/ ' END OF FORTRAN PREPROCESSOR. ')
      IF ( ( NOVREP .NE. 0 ) .OR. ( NOVNEW .NE. 0 ) )   STOP 130
      STOP
912   FORMAT (/ ' **********  WARNING  ********** '
     1        / 1X, I7, ' # SIGN  IS  NOT REPLACED',
     2                  ' WITH # VARIABLE VALUE. ')
914   FORMAT (/ ' **********  WARNING  ********** '
     1        / 1X, I7, ' # SIGNS ARE NOT REPLACED',
     2                  ' WITH # VARIABLE VALUES. ')
916   FORMAT (/ ' **********  WARNING  ********** '
     1        / 1X, I7, ' # VARIABLE  MAY NOT BE INITIALIZED. ')
918   FORMAT (/ ' **********  WARNING  ********** '
     1        / 1X, I7, ' # VARIABLES MAY NOT BE INITIALIZED. ')
C
C
930   CONTINUE
      PRINT 940, FILES
940   FORMAT (/ ' ********** ERROR OPENING  INPUT FILE ' / 1X, A80)
      PRINT 910
      STOP  140
C
950   CONTINUE
      PRINT 960, FILES
960   FORMAT (/ ' ********** ERROR OPENING OUTPUT FILE ' / 1X, A80)
      PRINT 910
      STOP  150
C
970   CONTINUE
      PRINT 980, FILES
980   FORMAT (/ ' ********** ERROR OPENING  PATHS FILE ' / 1X, A80)
      PRINT 910
      STOP  160
      END
      SUBROUTINE PERCNT (CARD, IPT, NFT)
C
C     SUBROUTINE PERCNT PROCESSES CONTROL CARDS OF MAIN.
C
      PARAMETER ( MAXMEM = 40 )
C
      CHARACTER*1      CARD(72)
      CHARACTER*1      PER
      DATA             PER           /'%'/
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      BLANK
      DATA             BLANK         /' '/
      CHARACTER*1      SEMICL
      DATA             SEMICL        /';'/
      CHARACTER*1      NUM
      DATA             NUM           /'#'/
      CHARACTER*1      EQUAL
      DATA             EQUAL         /'='/
      CHARACTER*1      QUOTE
      DATA             QUOTE         /''''/
      CHARACTER*1      TSTVAR(8)
      INTEGER          TNOLEN
      INTEGER          VARNO
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C              E.G., NOLEN(5) IS THE NUMBER OF VARIABLE NAMES
C              OF LENGTH 5.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /EXTRA/
C     WHEN LREPVR=0, # VARIABLES ARE NOT REPLACED WITH VALUES.
C     WHEN LREPVR=1, # VARIABLES ARE     REPLACED WITH VALUES.
C     NOVREP - NUMBER OF # SIGNS     NOT REPLACED WITH VALUES;
C            - WHEN LREPVR=1.
C     NOVNEW - NUMBER OF # VARIABLES THAT MAY NOT BE INITIALIZED;
C            - WHEN LREPVR=1.
C     LTABLE - TABLE FOR CHARACTERS (UPPER AND LOWER CASE LETTERS,
C            - NUMBERS) TO BE DETECTED.
C     ILOWER, IUPPER - LOWER AND UPPER CASE 'I'.
C     NLOWER, NUPPER - LOWER AND UPPER CASE 'N'.
C     CLOWER, CUPPER - LOWER AND UPPER CASE 'C'.
C     LLOWER, LUPPER - LOWER AND UPPER CASE 'L'.
C     ULOWER, UUPPER - LOWER AND UPPER CASE 'U'.
C     DLOWER, DUPPER - LOWER AND UPPER CASE 'D'.
C     ELOWER, EUPPER - LOWER AND UPPER CASE 'E'.
      COMMON  /EXTRA/  LREPVR,
     1                 NOVREP,
     2                 NOVNEW,
     3                 LTABLE(256),
     4                 ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
      CHARACTER*1      ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
C
C
C
100   CONTINUE
C
      IF (CARD(IPT).NE.PER)  THEN
         PRINT 150, CARD
150      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING % CONTROL STATEMENT. '
     2           / ' TESTED CHARACTER IS NOT PERCENT SIGN. '
     3           / 1X, 72A1)
         STOP 260
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      ITEST = IPT + 2
      IF (ITEST.GT.72)  GO TO 200
C
      IF ( (CARD(IPT  ).EQ.DUPPER) .OR. (CARD(IPT  ).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+1).EQ.CUPPER) .OR. (CARD(IPT+1).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+2).EQ.LUPPER) .OR. (CARD(IPT+2).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
C
C     MOVE POINTER IPT TO 'L' OF 'DCL'.
      IPT = IPT + 2
C
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL MOVESC (CARD, IPT, NFT)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
200   CONTINUE
C
      ITEST = IPT + 6
      IF (ITEST.GT.72)  GO TO 300
C
      IF ( (CARD(IPT  ).EQ.IUPPER) .OR. (CARD(IPT  ).EQ.ILOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+1).EQ.NUPPER) .OR. (CARD(IPT+1).EQ.NLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+2).EQ.CUPPER) .OR. (CARD(IPT+2).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+3).EQ.LUPPER) .OR. (CARD(IPT+3).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+4).EQ.UUPPER) .OR. (CARD(IPT+4).EQ.ULOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+5).EQ.DUPPER) .OR. (CARD(IPT+5).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+6).EQ.EUPPER) .OR. (CARD(IPT+6).EQ.ELOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
C
C     MOVE POINTER IPT TO 'E' OF 'INCLUDE'.
      IPT = IPT + 6
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
C     POINTER IPT SHOULD BE AT FIRST CHARACTER OF MEMBER NAME.
C
C     FIND LENGTH OF MEMBER NAME.
      CALL FINDLM (CARD, IPT, LENGTH)
C
C     SET MEMBER ARRAY TO MEMBER NAME.
      DO 240 II=1,MAXMEM
            MEMBER(II) = BLANK
240   CONTINUE
      JJ = IPT
      DO 250 II=1,LENGTH
            MEMBER(II) = CARD(JJ)
            JJ = JJ + 1
250   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF MEMBER NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 270, CARD
270      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING   % INCLUDE FILENAME ; '
     2           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     3           / 1X, 72A1)
         STOP 300
      ENDIF
C
C     CALL LEVEL1 TO PROCESS LEVEL ONE CARDS OF INCLUDED MEMBER.
      CALL LEVEL1 (MEMBER)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
300   CONTINUE
C
      IF (CARD(IPT).NE.NUM)  THEN
         PRINT 320, CARD
320      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT #. '
     4           / 1X, 72A1)
         STOP 320
      ENDIF
C
C     FIND LENGTH OF VARIABLE NAME.
      CALL FINDLV (CARD, IPT, LENGTH)
C
C     HAS VARIABLE NAME BEEN USED BEFORE?
C
C     COPY VARIABLE NAME TO TSTVAR ARRAY.
      JJ = IPT
      DO 350 II=1,LENGTH
            TSTVAR(II) = CARD(JJ)
            JJ = JJ + 1
350   CONTINUE
C
      TNOLEN = NOLEN(LENGTH)
      IF (TNOLEN.EQ.0)  GO TO 500
C
      NFOUND = 0
C
      DO 450 NN=1,NOVAR
            VARNO = NN
            IF (LENNAM(VARNO).NE.LENGTH)  GO TO 450
            NFOUND = NFOUND + 1
C
                  DO 400 II=1,LENGTH
                        IF (VARNAM(II,VARNO).NE.TSTVAR(II))  GO TO 430
400               CONTINUE
C
C           VARIABLE NAME HAS BEEN FOUND AT VARIABLE NUMBER VARNO.
            INITRE = 1
            GO TO 650
C
430         CONTINUE
C
            IF (NFOUND.EQ.TNOLEN)  GO TO 500
C
450   CONTINUE
C
C     PROCESS NEW VARIABLE NAME.
500   CONTINUE
      INITRE = 0
C
      NOVAR = NOVAR + 1
      IF (NOVAR.GT.500)  THEN
         PRINT 550, CARD
550      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' MORE THAN 500 DIFFERENT',
     4             ' PREPROCESSOR VARIABLES #VARNAME. '
     5           / 1X, 72A1)
         STOP 500
      ENDIF
      VARNO = NOVAR
      NOLEN(LENGTH) = NOLEN(LENGTH) + 1
      LENNAM(VARNO) = LENGTH
C
      JJ = IPT
      DO 600 II=1,LENGTH
            VARNAM(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
600   CONTINUE
C
650   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.EQUAL)  THEN
         PRINT 670, CARD
670      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT EQUAL SIGN. '
     4           / 1X, 72A1)
         STOP 360
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  GO TO 750
C
C     MOVE POINTER IPT TO FIRST CHARACTER OF
C     STRING OF CHARACTERS BETWEEN QUOTES,
C     I.E., VARIABLE VALUE.
      IPT = IPT + 1
C
C     FIND LENGTH OF STRING OF CHARACTERS BETWEEN QUOTES.
      CALL FINDLQ (CARD, IPT, LENGTH)
C
C     PROCESS VARIABLE VALUE.
C
      LENVAL(VARNO) = LENGTH
C
      JJ = IPT
      DO 700 II=1,LENGTH
            VARVAL(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
700   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE VALUE.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  THEN
         PRINT 720, CARD
720      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = ''VALUE'' ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT THE SECOND QUOTE. '
     4           / 1X, 72A1)
         STOP 400
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      GO TO 900
C
C     PROCESS FORMULA.
750   CONTINUE
C
C     STORE FORMULA AND
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL SETFR (CARD, IPT, NFT)
C
C     EVALUATE FORMULA AND
C     SET VARIABLE VALUE LENGTH AND VARIABLE VALUE.
      CALL SETVAR (VARNO)
C
900   CONTINUE
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 920, CARD
920      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     4           / 1X, 72A1)
         STOP 420
      ENDIF
C
      IF ( INITRE .EQ. 0 )  PRINT 930,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
      IF ( INITRE .EQ. 1 )  PRINT 940,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
930   FORMAT ('fortprep variable   initialized   ', 9A1, '= ''', 20A1)
940   FORMAT ('fortprep variable reinitialized   ', 9A1, '= ''', 20A1)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
      END
      SUBROUTINE VARBLE (CARD, IPT)
C
C     COPY CARD TO CARDW AND REPLACE
C     VARIABLE NAMES WITH VARIABLE VALUES.
C     WRITE CARDW TO FT09F001.
C
C     IPT  IS POINTER FOR CARD.
C     IPTW IS POINTER FOR CARDW.
C
      CHARACTER*1      CARD(72)
      CHARACTER*1      CARDW(272)
C
      CHARACTER*1      TSTVAR(8)
      CHARACTER*1      NUM
      DATA             NUM           /'#'/
      CHARACTER*1      BLANK
      DATA             BLANK         /' '/
      INTEGER          TNOLEN
      INTEGER          VARNO
      CHARACTER*1      CHAR1
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLES OF PARTICULAR LENGTHS.
C              E.G., NOLEN(5) IS THE NUMBER OF VARIABLES
C              OF LENGTH 5.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /EXTRA/
C     WHEN LREPVR=0, # VARIABLES ARE NOT REPLACED WITH VALUES.
C     WHEN LREPVR=1, # VARIABLES ARE     REPLACED WITH VALUES.
C     NOVREP - NUMBER OF # SIGNS     NOT REPLACED WITH VALUES;
C            - WHEN LREPVR=1.
C     NOVNEW - NUMBER OF # VARIABLES THAT MAY NOT BE INITIALIZED;
C            - WHEN LREPVR=1.
C     LTABLE - TABLE FOR CHARACTERS (UPPER AND LOWER CASE LETTERS,
C            - NUMBERS) TO BE DETECTED.
C     ILOWER, IUPPER - LOWER AND UPPER CASE 'I'.
C     NLOWER, NUPPER - LOWER AND UPPER CASE 'N'.
C     CLOWER, CUPPER - LOWER AND UPPER CASE 'C'.
C     LLOWER, LUPPER - LOWER AND UPPER CASE 'L'.
C     ULOWER, UUPPER - LOWER AND UPPER CASE 'U'.
C     DLOWER, DUPPER - LOWER AND UPPER CASE 'D'.
C     ELOWER, EUPPER - LOWER AND UPPER CASE 'E'.
      COMMON  /EXTRA/  LREPVR,
     1                 NOVREP,
     2                 NOVNEW,
     3                 LTABLE(256),
     4                 ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
      CHARACTER*1      ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
C
C
C
      IPTW   = IPT
      LNVREP = 0
      LNVNEW = 0
      VARNO  = 0
C
C     SET CARDW TO BLANKS.
      DO 100 II=1,272
            CARDW(II) = BLANK
100   CONTINUE
C
      IF (IPT.EQ.1)  GO TO 200
C
C     COPY CHARACTERS 1 TO IPT-1 FROM CARD TO CARDW.
      IPTM = IPT - 1
      DO 150 II=1,IPTM
            CARDW(II) = CARD(II)
150   CONTINUE
C
200   CONTINUE
C
      IF (CARD(IPT).NE.NUM)  THEN
         PRINT 220, CARD
220      FORMAT (/ ' ********** ERROR ',
     1             ' REPLACING # VARIABLES WITH VALUES. '
     2           / ' TESTED CHARACTER IS NOT # SIGN. '
     3           / 1X, 72A1)
         STOP 610
      ENDIF
C
C     FIND MAXIMUM LENGTH OF TEST VARIABLE,
C     I.E., CHARACTER STRING OF CARD BEGINNING WITH '#'.
      LENMAX = 73 - IPT
      IF (LENMAX.GT.1)  GO TO 250
C           '#' IS AT COLUMN 72 OF CARD.
C
C           # SIGN IS NOT REPLACED WITH # VARIABLE VALUE.
            IF ( LREPVR .EQ. 1 )  THEN
                 NOVREP = NOVREP + 1
                 LNVREP = LNVREP + 1
            ENDIF
C
C           COPY '#' FROM CARD TO CARDW.
C           IS CARDW ARRAY LONG ENOUGH?
            IF (IPTW.GT.270)  THEN
               PRINT 520, CARD
               STOP 643
            ENDIF
            CARDW(IPTW) = CARD(IPT)
            IPT  = IPT  + 1
            IPTW = IPTW + 1
            GO TO 650
250   CONTINUE
      IF (LENMAX.GT.8)  LENMAX=8
C
C     COPY TEST VARIABLE TO TSTVAR ARRAY.
      JJ = IPT
      DO 300 II=1,LENMAX
            TSTVAR(II) = CARD(JJ)
            JJ = JJ + 1
300   CONTINUE
C
C     SEARCH FOR TEST VARIABLE AMONG VARIABLE NAMES.
C     START SEARCH WITH LONGEST VARIABLE NAMES.
C
      LENGTH = LENMAX
C
      DO 500 LL=2,LENMAX
C
      TNOLEN = NOLEN(LENGTH) * LREPVR
      IF (TNOLEN.EQ.0)  GO TO 450
C
      NFOUND = 0
C
      DO 400 NN=1,NOVAR
            VARNO = NN
            IF (LENNAM(VARNO).NE.LENGTH)  GO TO 400
            NFOUND = NFOUND + 1
C
                  DO 350 II=1,LENGTH
                        IF (VARNAM(II,VARNO).NE.TSTVAR(II))  GO TO 370
350               CONTINUE
C
C           VARIABLE NAME HAS BEEN FOUND AT VARIABLE NUMBER VARNO.
            GO TO 550
C
370         CONTINUE
C
            IF (NFOUND.EQ.TNOLEN)  GO TO 450
C
400   CONTINUE
C
450   CONTINUE
C
C     TEST VARIABLE NOT FOUND AMONG
C     VARIABLE NAMES OF THIS LENGTH.
C
C     TRY LENGTH LESS ONE.
      LENGTH = LENGTH - 1
C
500   CONTINUE
C
C     TEST VARIABLE NOT FOUND AMONG
C     ALL OF THE VARIABLE NAMES.
C
      VARNO  = 0
C
C     # SIGN IS NOT REPLACED WITH # VARIABLE VALUE.
      IF ( LREPVR .EQ. 1 )  THEN
           NOVREP = NOVREP + 1
           LNVREP = LNVREP + 1
      ENDIF
C
C     COPY '#' FROM CARD TO CARDW.
C     IS CARDW ARRAY LONG ENOUGH?
      IF (IPTW.GT.270)  THEN
         PRINT 520, CARD
520      FORMAT (/ ' ********** ERROR ',
     1             ' REPLACING # VARIABLES WITH VALUES. '
     2           / ' OUTPUT CARD INCREASED BEYOND 270 CHARACTERS. '
     3           / 1X, 72A1)
         STOP 637
      ENDIF
      CARDW(IPTW) = CARD(IPT)
      IPT  = IPT  + 1
      IPTW = IPTW + 1
C
      GO TO 650
C
550   CONTINUE
C
C     REPLACE VARIABLE NAME WITH VARIABLE VALUE.
C
C     SET LNAME TO LENGTH OF VARIABLE NAME.
      LNAME = LENNAM(VARNO)
C
C     SET LVALUE TO LENGTH OF VARIABLE VALUE.
      LVALUE = LENVAL(VARNO)
C
CMJR  IBLNKS = 2
      IBLNKS = 0
      IF (VARNAM(2,VARNO) .EQ. NUM)  IBLNKS = 0
C
C     IS CARDW ARRAY LONG ENOUGH?
      IPTWT = IPTW + LVALUE + IBLNKS
      IF (IPTWT.GT.270)  THEN
         PRINT 520, CARD
         STOP 630
      ENDIF
C
      IF (IBLNKS .EQ. 0)  GO TO 580
C     PUT A BLANK BEFORE VARIABLE VALUE.
      CARDW(IPTW) = BLANK
      IPTW = IPTW + 1
580   CONTINUE
C
C     COPY VARIABLE VALUE.
      DO 600 II=1,LVALUE
            CARDW(IPTW) = VARVAL(II,VARNO)
            IPTW = IPTW + 1
600   CONTINUE
C
      IF (IBLNKS .EQ. 0)  GO TO 620
C     PUT A BLANK AFTER VARIABLE VALUE.
      CARDW(IPTW) = BLANK
      IPTW = IPTW + 1
620   CONTINUE
C
C     MOVE POINTER IPT TO CHARACTER AFTER VARIABLE NAME.
      IPT = IPT + LNAME
C
650   CONTINUE
C
      IF (IPT.GT.72)  GO TO 750
C
C     IS CHARACTER AFTER # VARIABLE NAME A LETTER OR A NUMBER?
C     THIS IS DONE TO DETECT A # VARIABLE THAT IS NOT INITIALIZED.
      IF ( (LREPVR.EQ.1) .AND. (VARNO.GT.0) )  THEN
           NSEQ = ICHAR(CARD(IPT))
CC         EXCEPTION 1.  A NUMBER IS AFTER THE # VARIABLE #E
CC                       (UPPER OR LOWER CASE 'E').
           CHAR1 = VARNAM(2,VARNO)
           IF (         (LNAME.EQ.2)
     1          .AND. ( (CHAR1.EQ.EUPPER) .OR. (CHAR1.EQ.ELOWER) )
     2          .AND. ( (NSEQ.GE.48) .AND. (NSEQ.LE.57) ) )  GO TO 670
CC         EXCEPTION 2.  THE # VARIABLE NAME HAS A LENGTH OF 5,
CC                       AND THE CHARACTER AFTER THE # VARIABLE NAME
CC                       IS IN COLUMN 6.
           IF ( (LNAME.EQ.5) .AND. (IPT.EQ.6) )  GO TO 670
           LTAB = LTABLE(NSEQ+1)
           NOVNEW = NOVNEW + LTAB
           LNVNEW = LNVNEW + LTAB
      ENDIF
670   CONTINUE
C
C     COPY CARD TO CARDW UNTIL TEST VARIABLE IS FOUND.
      JJ = IPT
      DO 700 II=JJ,72
            IF (CARD(IPT).EQ.NUM)  GO TO 200
C           IS CARDW ARRAY LONG ENOUGH?
            IF (IPTW.GT.270)  THEN
               PRINT 520, CARD
               STOP 639
            ENDIF
            CARDW(IPTW) = CARD(IPT)
            IPT  = IPT  + 1
            IPTW = IPTW + 1
700   CONTINUE
C
750   CONTINUE
C
C     CHARACTERS THROUGH COLUMN 72 OF CARD HAVE BEEN PROCESSED.
C
C     WRITE CARDW TO FT09F001 AS EITHER
C     A FORTRAN STATEMENT OR COMMENT.
C     (THIS RECORD HAS ' 1 ' IN COLUMNS 78 TO 80.  NOT DONE.)
C
C     SET LENMAX TO THE NUMBER OF THE LAST
C     CHARACTER OF CARDW THAT WAS SET.
      LENMAX = IPTW - 1
C
      DO 820 II=LENMAX,1,-1
            LAST = II
            IF (CARDW(II).NE.BLANK)  GO TO 830
820   CONTINUE
830   CONTINUE
C
CC    NOCARD = NOCARD + 1
      LASTPR = MIN0(LAST,72)
      WRITE (9,840) (CARDW(II),II=1,LASTPR)
840   FORMAT (72A1)
CC840 FORMAT (72A1, I5, ' 1 ')
C
      IF   ( LNVREP .EQ. 1 )   PRINT 842, LNVREP
      IF   ( LNVREP .GT. 1 )   PRINT 843, LNVREP
      IF   ( LNVNEW .EQ. 1 )   PRINT 844, LNVNEW
      IF   ( LNVNEW .GT. 1 )   PRINT 845, LNVNEW
      IF ( ( LNVREP .NE. 0 ) .OR. ( LNVNEW .NE. 0 ) )
     1     PRINT 846, CARD, (CARDW(II), II=1,LASTPR)
842   FORMAT (/ 1X, I7, ' # SIGN  IS  NOT REPLACED',
     1                  ' WITH # VARIABLE VALUE. ')
843   FORMAT (/ 1X, I7, ' # SIGNS ARE NOT REPLACED',
     1                  ' WITH # VARIABLE VALUES. ')
844   FORMAT (/ 1X, I7, ' # VARIABLE  MAY NOT BE INITIALIZED. ')
845   FORMAT (/ 1X, I7, ' # VARIABLES MAY NOT BE INITIALIZED. ')
846   FORMAT ( (1X, 72A1) )
C
      IF (LAST.LE.72)  GO TO 950
C
C     WRITE REST OF CARDW TO FT09F001
C     AS UP TO THREE ADDITIONAL RECORDS.
C     (THESE RECORDS HAVE ' **' IN COLUMNS 78 TO 80.  NOT DONE.)
C
      CHAR1 = BLANK
      IF (CARDW(1).EQ.CLOWER) CHAR1=CLOWER
      IF (CARDW(1).EQ.CUPPER) CHAR1=CUPPER
      IMIN = 73
      IMAX = 138
C
      DO 900 JJ=1,3
CC          NOCARD = NOCARD + 1
            IMAXPR = MIN0(IMAX,LAST)
            IF ( ( LNVREP .NE. 0 ) .OR. ( LNVNEW .NE. 0 ) )
     1      PRINT    850, CHAR1, JJ, (CARDW(II),II=IMIN,IMAXPR)
            WRITE (9,852) CHAR1, JJ, (CARDW(II),II=IMIN,IMAXPR)
850         FORMAT (1X, A1, 4X, I1, 66A1)
852         FORMAT (    A1, 4X, I1, 66A1)
CC852       FORMAT (    A1, 4X, I1, 66A1, I5, ' **')
            IF (LAST.LE.IMAX)  GO TO 950
            IMIN = IMAX + 1
            IMAX = IMAX + 66
900   CONTINUE
C
950   CONTINUE
C
      RETURN
      END
      SUBROUTINE FINDLM (CARD, IPT, LENGTH)
C
C    (FIND LENGTH OF MEMBER NAME.)
C     FIND LENGTH OF FILE   NAME.
C
      PARAMETER ( MAXMEM = 40 )
C
      CHARACTER*1     CARD(72)
      CHARACTER*1     BLANK
      DATA            BLANK          /' '/
      CHARACTER*1     SEMICL
      DATA            SEMICL         /';'/
C
      LENGTH = 0
      IPTP = IPT
C
      MAXMP2 = MAXMEM + 2
      DO 200 L=1,MAXMP2
            IF (IPTP.GT.72)            GO TO 300
            IF (CARD(IPTP).EQ.BLANK)   GO TO 300
            IF (CARD(IPTP).EQ.SEMICL)  GO TO 300
C
            LENGTH = L
            IPTP = IPTP + 1
200   CONTINUE
C
300   CONTINUE
C
      IF (LENGTH.LT.1)  THEN
         PRINT 400, CARD
400      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING  % INCLUDE FILENAME ; '
     2           / ' LENGTH OF FILENAME LESS THAN ONE. '
     3           / 1X, 72A1)
         STOP 280
      ENDIF
C
      IF (LENGTH.GT.MAXMEM) THEN
         PRINT 500, MAXMEM, CARD
500      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING  % INCLUDE FILENAME ; '
     2           / ' LENGTH OF FILENAME GREATER THAN ', I3
     3           / 1X, 72A1)
         STOP 285
      ENDIF
C
      RETURN
      END
      SUBROUTINE FINDLV (CARD, IPT, LENGTH)
C
C     FIND LENGTH OF VARIABLE NAME.
C
      CHARACTER*1     CARD(72)
      CHARACTER*1     BLANK
      DATA            BLANK          /' '/
      CHARACTER*1     EQUAL
      DATA            EQUAL          /'='/
C
      LENGTH = 0
      IPTP = IPT
C
      DO 200 L=1,10
            IF (IPTP.GT.72)           GO TO 300
            IF (CARD(IPTP).EQ.BLANK)  GO TO 300
            IF (CARD(IPTP).EQ.EQUAL)  GO TO 300
C
            LENGTH = L
            IPTP = IPTP + 1
200   CONTINUE
C
300   CONTINUE
C
      IF (LENGTH.LT.2)  THEN
         PRINT 400, CARD
400      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING  % #VARNAME = VALUE ; '
     2           / ' LENGTH OF VARIABLE #VARNAME LESS THAN TWO. '
     3           / 1X, 72A1)
         STOP 340
      ENDIF
C
      IF (LENGTH.GT.8)  THEN
         PRINT 500, CARD
500      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING  % #VARNAME = VALUE ; '
     2           / ' LENGTH OF VARIABLE #VARNAME GREATER THAN EIGHT. '
     3           / 1X, 72A1)
         STOP 345
      ENDIF
C
      RETURN
      END
      SUBROUTINE FINDLQ (CARD, IPT, LENGTH)
C
C     FIND LENGTH OF STRING OF CHARACTERS BETWEEN QUOTES.
C
      CHARACTER*1     CARD(72)
      CHARACTER*1     QUOTE
      DATA            QUOTE          /''''/
C
      LENGTH = 0
      IPTP = IPT
C
      DO 200 L=1,18
            IF (IPTP.GT.72)           GO TO 300
            IF (CARD(IPTP).EQ.QUOTE)  GO TO 300
C
            LENGTH = L
            IPTP = IPTP + 1
200   CONTINUE
C
300   CONTINUE
C
      IF (LENGTH.LT. 1)  THEN
         PRINT 400, CARD
400      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING  % #VARNAME = ''VALUE'' ; '
     2           / ' LENGTH OF VALUE (STRING OF CHARACTERS',
     3             ' BETWEEN QUOTES) LESS THAN ONE. '
     4           / 1X, 72A1)
         STOP 380
      ENDIF
C
      IF (LENGTH.GT.16)  THEN
         PRINT 500, CARD
500      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING  % #VARNAME = ''VALUE'' ; '
     2           / ' LENGTH OF VALUE (STRING OF CHARACTERS',
     3             ' BETWEEN QUOTES) GREATER THAN SIXTEEN. '
     4           / 1X, 72A1)
         STOP 385
      ENDIF
C
      RETURN
      END
      SUBROUTINE BLANKE (CARD, IPT)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
C     SET IPT=73 IF REST OF CARD IS BLANKS.
C
      CHARACTER*1     CARD(72)
      CHARACTER*1     BLANK
      DATA            BLANK          /' '/
C
200   CONTINUE
      IPT = IPT + 1
      IF (IPT.GT.72)           RETURN
      IF (CARD(IPT).EQ.BLANK)  GO TO 200
C
      RETURN
      END
      SUBROUTINE BLANKM (CARD, IPT, NFT)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
C
      CHARACTER*1     CARD(72)
      CHARACTER*1     BLANK
      DATA            BLANK          /' '/
C
200   CONTINUE
      IPT = IPT + 1
      IF (IPT.LT.73)  GO TO 400
      IPT = 0
      DO 567 IJK=1,72
             CARD(IJK) = ' '
567   CONTINUE
      READ (NFT,300,END=500)  CARD
300   FORMAT (72A1)
      GO TO 200
400   CONTINUE
      IF (CARD(IPT).EQ.BLANK)  GO TO 200
C
      RETURN
C
500   CONTINUE
      PRINT 600, CARD
600   FORMAT (/ ' ********** ERROR ',
     1          ' PROCESSING  % CONTROL STATEMENT. '
     2        / ' END OF INPUT FILE OR INCLUDED FILE REACHED'
     3        / ' DURING SEARCH FOR NEXT NONBLANK CHARACTER. '
     4        / 1X, 72A1)
      STOP  220
C
      END
      SUBROUTINE MOVESC (CARD, IPT, NFT)
C
C     MOVE POINTER IPT TO NEXT SEMICOLON.
C
      CHARACTER*1     CARD(72)
      CHARACTER*1     SEMICL
      DATA            SEMICL         /';'/
C
200   CONTINUE
      IPT = IPT + 1
      IF (IPT.LT.73)  GO TO 400
      IPT = 0
      DO 567 IJK=1,72
             CARD(IJK) = ' '
567   CONTINUE
      READ (NFT,300,END=500)  CARD
300   FORMAT (72A1)
      GO TO 200
400   CONTINUE
      IF (CARD(IPT).NE.SEMICL)  GO TO 200
C
      RETURN
C
500   CONTINUE
      PRINT 600, CARD
600   FORMAT (/ ' ********** ERROR ',
     1          ' PROCESSING  % CONTROL STATEMENT. '
     2        / ' END OF INPUT FILE OR INCLUDED FILE REACHED'
     3        / ' DURING SEARCH FOR NEXT SEMICOLON. '
     4        / 1X, 72A1)
      STOP  240
C
      END
      BLOCK DATA
C
C     INITIALIZE VARIABLES AND ARRAYS OF COMMON /BLOCK/.
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLES OF PARTICULAR LENGTHS.
C              E.G., NOLEN(5) IS THE NUMBER OF VARIABLES
C              OF LENGTH 5.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
      DATA             NOCARD             /0/
      DATA             NOVAR              /0/
      DATA             NOLEN              /8*0/
      DATA             VARNAM             /4000*' '/
      DATA             LENNAM             /500*0/
      DATA             VARVAL             /8000*' '/
      DATA             LENVAL             /500*0/
C
      END
      SUBROUTINE SETVAR (VARNO)
C
C     EVALUATE FORMULA AND
C     SET VARIABLE VALUE LENGTH AND VARIABLE VALUE.
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C              E.G., NOLEN(5) IS THE NUMBER OF VARIABLE NAMES
C              OF LENGTH 5.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
      COMMON /FORM/ LENFOR, PTFORM, PTINFX, FORMLA(200), INFIXE(200)
C
      INTEGER          LENFOR, PTFORM, PTINFX
      CHARACTER*1      FORMLA, INFIXE
C
C     LENFOR - LENGTH OF FORMULA.
C     PTFORM - POINTER FOR FORMULA.
C     PTINFX - POINTER FOR INFIX EXPRESSION.
C     FORMLA - ARRAY FOR FORMULA OF ONE TO LENFOR NONBLANK CHARACTERS.
C     INFIXE - ARRAY FOR INFIX EXPRESSION.
C
C
      INTEGER          PTEXPR
      INTEGER          PTOPND
      CHARACTER*1      ERTURN(200)
      CHARACTER*1      ORTURN(200)
      CHARACTER*1      ESTFOR(200)
      CHARACTER*1      ESTINF(200)
      CHARACTER*1      ESTVCN(200)
      CHARACTER*1      OSTFOR(200)
      CHARACTER*1      OSTINF(200)
      CHARACTER*1      OSTVCN(200)
      CHARACTER*1      EIND(200)
      CHARACTER*1      OIND(200)
      INTEGER          IND
      DATA             IND               /0/
      CHARACTER*1      LIND
      CHARACTER*1      LABEL
      CHARACTER*1      L1
      CHARACTER*1      L2
      CHARACTER*1      L3
      CHARACTER*1      L4
      CHARACTER*1      L5
      INTEGER          VARCON(200)
      INTEGER          PTVRCN
      INTEGER          VARNO
      INTEGER          IVALUE
      INTEGER          LVALUE
      CHARACTER*16     VALUE
      CHARACTER*1      BLANK
      DATA             BLANK             /' '/
      INTEGER          MAXPTS
      INTEGER          MAXPTR
      INTEGER          REVPOL(200)
      INTEGER          STACK(200)
      INTEGER          PTSTAK
      INTEGER          PTRPOL
      INTEGER          TVALUE
      INTEGER          TPRIOR
      INTEGER          PRIOR(5)
      DATA             PRIOR             /1, 1, 2, 2, 3/
C
C
      L1 = CHAR(01)
      L2 = CHAR(02)
      L3 = CHAR(03)
      L4 = CHAR(04)
      L5 = CHAR(05)
C
C     (TEST FOR INVALID LENGTH OF FORMULA.)
C     (DONE IN SUBROUTINE SETFR.)
CCCC  IF (LENFOR.LT.1)  STOP 1030
C
C     SET POINTERS TO ZERO.
      PTFORM = 0
      PTINFX = 0
      PTEXPR = 0
      PTOPND = 0
      PTVRCN = 0
C
C     PARSE OF (EXPRESSION)1, I.E., THE ENTIRE FORMULA.
C
C     INCREMENT POINTER.
      PTEXPR = PTEXPR + 1
C
C     SET RETURN STACK TO WHERE TO RETURN.
      ERTURN(PTEXPR) = L1
C
C     BRANCH TO PARSE OF (EXPRESSION).
      GO TO 120
C
C     PARSE OF (EXPRESSION)1 IS DONE.
    1 CONTINUE
C
C     EVALUATE INDICATOR FOR THE PARSE OF (EXPRESSION)1.
C
C     IF PARSE OF (EXPRESSION)1 IS TRUE, BRANCH TO PART
C     THAT SETS REVERSE POLISH NOTATION OF FORMULA.
      IF (EIND(PTEXPR).EQ.L1)  GO TO 460
C
C     PARSE OF (EXPRESSION)1 IS FALSE.
      PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1           (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2           (FORMLA(JJ)      , JJ=1,LENFOR)
100   FORMAT (/ ' ********** ERROR ',
     1          ' PROCESSING  % #VARNAME = FORMULA ; '
     2        / ' FORMULA IS INVALID. '
     3        / ' #VARNAME IS ', 9A1
     4        / ' FORMULA  IS ', 40A1 / (13X, 40A1) )
      STOP 1040
C
C     PARSE OF (EXPRESSION).
  120 CONTINUE
C
C     (EXPRESSION) = / (OPERAND)4 (OPERATOR) (EXPRESSION)2 /
C                    / (OPERAND)5 /
C
C     SAVE VALUES OF FORMULA POINTERS AT BEGINNING OF PART.
      ESTFOR(PTEXPR) = CHAR(PTFORM)
      ESTINF(PTEXPR) = CHAR(PTINFX)
      ESTVCN(PTEXPR) = CHAR(PTVRCN)
C
C     PARSE OF / (OPERAND)4.
C
C     INCREMENT POINTER.
      PTOPND = PTOPND + 1
C
C     SET RETURN STACK TO WHERE TO RETURN.
      ORTURN(PTOPND) = L4
C
C     BRANCH TO PARSE OF (OPERAND).
      GO TO 260
C
C     PARSE OF / (OPERAND)4 IS DONE.
    4 CONTINUE
C
C     EVALUATE INDICATOR FOR THE PARSE OF / (OPERAND)4.
C
      IF (OIND(PTOPND).EQ.L1)  GO TO 140
C
C     PARSE OF / (OPERAND)4 IS FALSE.
C
C     DECREMENT THE OPERAND STACK POINTER.
      PTOPND = PTOPND - 1
C
C     RESET FORMULA POINTERS TO VALUES AT BEGINNING OF PART.
      PTFORM = ICHAR(ESTFOR(PTEXPR))
      PTINFX = ICHAR(ESTINF(PTEXPR))
      PTVRCN = ICHAR(ESTVCN(PTEXPR))
C
C     BRANCH TO / (OPERAND)5 /.
      GO TO 220
C
C     PARSE OF / (OPERAND)4 IS TRUE.
  140 CONTINUE
C
C     DECREMENT THE OPERAND STACK POINTER.
      PTOPND = PTOPND - 1
C
C     PARSE OF (OPERATOR).
      CALL OPERAT (IND)
C
C     EVALUATE INDICATOR FOR THE PARSE OF (OPERATOR).
C
      IF (IND.EQ.1)  GO TO 160
C
C     PARSE OF (OPERATOR) IS FALSE.
C
C     RESET FORMULA POINTERS TO VALUES AT BEGINNING OF PART.
      PTFORM = ICHAR(ESTFOR(PTEXPR))
      PTINFX = ICHAR(ESTINF(PTEXPR))
      PTVRCN = ICHAR(ESTVCN(PTEXPR))
C
C     BRANCH TO / (OPERAND)5 /.
      GO TO 220
C
C     PARSE OF (OPERATOR) IS TRUE.
  160 CONTINUE
C
C     PARSE OF (EXPRESSION)2 /.
C
C     INCREMENT POINTER.
      PTEXPR = PTEXPR + 1
C
C     SET RETURN STACK TO WHERE TO RETURN.
      ERTURN(PTEXPR) = L2
C
C     BRANCH TO PARSE OF (EXPRESSION).
      GO TO 120
C
C     PARSE OF (EXPRESSION)2 / IS DONE.
    2 CONTINUE
C
C     EVALUATE INDICATOR FOR THE PARSE OF (EXPRESSION)2 /.
C
      IF (EIND(PTEXPR).EQ.L1)  GO TO 180
C
C     PARSE OF (EXPRESSION)2 / IS FALSE.
C
C     DECREMENT THE EXPRESSION STACK POINTER.
      PTEXPR = PTEXPR - 1
C
C     RESET FORMULA POINTERS TO VALUES AT BEGINNING OF PART.
      PTFORM = ICHAR(ESTFOR(PTEXPR))
      PTINFX = ICHAR(ESTINF(PTEXPR))
      PTVRCN = ICHAR(ESTVCN(PTEXPR))
C
C     BRANCH TO / (OPERAND)5 /.
      GO TO 220
C
C     PARSE OF (EXPRESSION)2 / IS TRUE.
  180 CONTINUE
C
C     SET LIND TO INDICATOR FOR THE PARSE OF (EXPRESSION)2 /.
      LIND = EIND(PTEXPR)
C
C     DECREMENT THE EXPRESSION STACK POINTER.
      PTEXPR = PTEXPR - 1
C
C     SET INDICATOR FOR THE PARSE OF (EXPRESSION) TO
C         INDICATOR FOR THE PARSE OF (EXPRESSION)2 /.
      EIND(PTEXPR) = LIND
C
C     SET LABEL TO WHERE TO RETURN.
      LABEL = ERTURN(PTEXPR)
C
C     BRANCH TO LABEL.
      IF (LABEL.EQ.L1)  GO TO 1
      IF (LABEL.EQ.L2)  GO TO 2
      IF (LABEL.EQ.L3)  GO TO 3
C
C     INVALID LABEL.
      PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1           (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2           (FORMLA(JJ)      , JJ=1,LENFOR)
      STOP 1050
C
C     PARSE OF  / (OPERAND)5 /.
  220 CONTINUE
C
C     INCREMENT POINTER.
      PTOPND = PTOPND + 1
C
C     SET RETURN STACK TO WHERE TO RETURN.
      ORTURN(PTOPND) = L5
C
C     BRANCH TO PARSE OF (OPERAND).
      GO TO 260
C
C     PARSE OF / (OPERAND)5 / IS DONE.
    5 CONTINUE
C
C     SET INDICATOR FOR THE PARSE OF (EXPRESSION) TO
C         INDICATOR FOR THE PARSE OF / (OPERAND)5 /.
      EIND(PTEXPR) = OIND(PTOPND)
C
C     EVALUATE INDICATOR FOR THE PARSE OF / (OPERAND)5 /.
C
      IF (OIND(PTOPND).EQ.L1)  GO TO 240
C
C     PARSE OF / (OPERAND)5 / IS FALSE.
C
C     RESET FORMULA POINTERS TO VALUES AT BEGINNING OF PART.
      PTFORM = ICHAR(ESTFOR(PTEXPR))
      PTINFX = ICHAR(ESTINF(PTEXPR))
      PTVRCN = ICHAR(ESTVCN(PTEXPR))
C
C     / (OPERAND)5 / IS TRUE, OR FINISH IF
C     / (OPERAND)5 / IS FALSE.
  240 CONTINUE
C
C     DECREMENT THE OPERAND STACK POINTER.
      PTOPND = PTOPND - 1
C
C     SET LABEL TO WHERE TO RETURN.
      LABEL = ERTURN(PTEXPR)
C
C     (EXPRESSION) HAS BEEN PARSED.
C     BRANCH TO WHERE TO RETURN.
      IF (LABEL.EQ.L1)  GO TO 1
      IF (LABEL.EQ.L2)  GO TO 2
      IF (LABEL.EQ.L3)  GO TO 3
C
C     INVALID LABEL.
      PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1           (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2           (FORMLA(JJ)      , JJ=1,LENFOR)
      STOP 1060
C
C     PARSE OF (OPERAND).
  260 CONTINUE
C
C     (OPERAND) = / (OPEN PAREN) (EXPRESSION)3 (CLOSE PAREN) /
C                 / (VARIABLE) /
C                 / (CONSTANT) /
C
C     SAVE VALUES OF FORMULA POINTERS AT BEGINNING OF PART.
      OSTFOR(PTOPND) = CHAR(PTFORM)
      OSTINF(PTOPND) = CHAR(PTINFX)
      OSTVCN(PTOPND) = CHAR(PTVRCN)
C
C     PARSE OF (OPEN PAREN).
      CALL OPENP (IND)
C
C     EVALUATE INDICATOR FOR THE PARSE OF (OPEN PAREN).
C
      IF (IND.EQ.1)  GO TO 280
C
C     PARSE OF (OPEN PAREN) IS FALSE.
C
C     RESET FORMULA POINTERS TO VALUES AT BEGINNING OF PART.
      PTFORM = ICHAR(OSTFOR(PTOPND))
      PTINFX = ICHAR(OSTINF(PTOPND))
      PTVRCN = ICHAR(OSTVCN(PTOPND))
C
C     BRANCH TO PARSE OF / (VARIABLE) /.
      GO TO 360
C
C     PARSE OF (OPEN PAREN) IS TRUE.
  280 CONTINUE
C
C     PARSE OF (EXPRESSION)3.
C
C     INCREMENT POINTER.
      PTEXPR = PTEXPR + 1
C
C     SET RETURN STACK TO WHERE TO RETURN.
      ERTURN(PTEXPR) = L3
C
C     BRANCH TO PARSE OF (EXPRESSION).
      GO TO 120
C
C     PARSE OF (EXPRESSION)3 IS DONE.
    3 CONTINUE
C
C     EVALUATE INDICATOR FOR THE PARSE OF (EXPRESSION)3.
C
      IF (EIND(PTEXPR).EQ.L1)  GO TO 320
C
C     PARSE OF (EXPRESSION)3 IS FALSE.
C
C     DECREMENT THE EXPRESSION STACK POINTER.
      PTEXPR = PTEXPR - 1
C
C     RESET FORMULA POINTERS TO VALUES AT BEGINNING OF PART.
      PTFORM = ICHAR(OSTFOR(PTOPND))
      PTINFX = ICHAR(OSTINF(PTOPND))
      PTVRCN = ICHAR(OSTVCN(PTOPND))
C
C     BRANCH TO / (VARIABLE) /.
      GO TO 360
C
C     PARSE OF (EXPRESSION)3 IS TRUE.
  320 CONTINUE
C
C     DECREMENT THE EXPRESSION STACK POINTER.
      PTEXPR = PTEXPR - 1
C
C     PARSE OF (CLOSE PAREN) /.
      CALL CLOSEP (IND)
C
C     EVALUATE INDICATOR FOR THE PARSE OF (CLOSE PAREN) /.
C
      IF (IND.EQ.1)  GO TO 340
C
C     PARSE OF (CLOSE PAREN) / IS FALSE.
C
C     RESET FORMULA POINTERS TO VALUES AT BEGINNING OF PART.
      PTFORM = ICHAR(OSTFOR(PTOPND))
      PTINFX = ICHAR(OSTINF(PTOPND))
      PTVRCN = ICHAR(OSTVCN(PTOPND))
C
C     BRANCH TO / (VARIABLE) /.
      GO TO 360
C
C     PARSE OF (CLOSE PAREN) / IS TRUE.
  340 CONTINUE
C
C     SET LABEL TO WHERE TO RETURN.
      LABEL = ORTURN(PTOPND)
C
C     SET INDICATOR FOR THE PARSE OF (OPERAND) TO
C         INDICATOR FOR THE PARSE OF (CLOSE PAREN) /.
      OIND(PTOPND) = CHAR(IND)
C
C     BRANCH TO LABEL.
      IF (LABEL.EQ.L4)  GO TO 4
      IF (LABEL.EQ.L5)  GO TO 5
C
C     INVALID LABEL.
      PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1           (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2           (FORMLA(JJ)      , JJ=1,LENFOR)
      STOP 1070
C
  360 CONTINUE
C
C     PARSE OF / (VARIABLE) /.
      CALL VARIAB (IND, VARCON, PTVRCN)
C
C     EVALUATE INDICATOR FOR THE PARSE OF / (VARIABLE) /.
C
      IF (IND.EQ.1)  GO TO 380
C
C     PARSE OF / (VARIABLE) / IS FALSE.
C
C     RESET FORMULA POINTERS TO VALUES AT BEGINNING OF PART.
      PTFORM = ICHAR(OSTFOR(PTOPND))
      PTINFX = ICHAR(OSTINF(PTOPND))
      PTVRCN = ICHAR(OSTVCN(PTOPND))
C
C     BRANCH TO / (CONSTANT) /.
      GO TO 420
C
C     PARSE OF / (VARIABLE) / IS TRUE.
  380 CONTINUE
C
C     SET LABEL TO WHERE TO RETURN.
      LABEL = ORTURN(PTOPND)
C
C     SET INDICATOR FOR THE PARSE OF (OPERAND) TO
C         INDICATOR FOR THE PARSE OF / (VARIABLE) /.
      OIND(PTOPND) = CHAR(IND)
C
C     BRANCH TO LABEL.
      IF (LABEL.EQ.L4)  GO TO 4
      IF (LABEL.EQ.L5)  GO TO 5
C
C     INVALID LABEL.
      PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1           (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2           (FORMLA(JJ)      , JJ=1,LENFOR)
      STOP 1080
C
  420 CONTINUE
C
C     PARSE OF / (CONSTANT) /.
      CALL CONST (IND, VARCON, PTVRCN)
C
C     EVALUATE INDICATOR FOR THE PARSE OF / (CONSTANT) /.
C
      IF (IND.EQ.1)  GO TO 440
C
C     PARSE OF / (CONSTANT) / IS FALSE.
C
C     RESET FORMULA POINTERS TO VALUES AT BEGINNING OF PART.
      PTFORM = ICHAR(OSTFOR(PTOPND))
      PTINFX = ICHAR(OSTINF(PTOPND))
      PTVRCN = ICHAR(OSTVCN(PTOPND))
C
C     PARSE OF / (CONSTANT) / IS TRUE, OR FINISH IF
C     PARSE OF / (CONSTANT) / IS FALSE.
  440 CONTINUE
C
C     SET LABEL TO WHERE TO RETURN.
      LABEL = ORTURN(PTOPND)
C
C     SET INDICATOR FOR THE PARSE OF (OPERAND) TO
C         INDICATOR FOR THE PARSE OF / (CONSTANT) /.
      OIND(PTOPND) = CHAR(IND)
C
C     BRANCH TO LABEL.
      IF (LABEL.EQ.L4)  GO TO 4
      IF (LABEL.EQ.L5)  GO TO 5
C
C     INVALID LABEL.
      PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1           (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2           (FORMLA(JJ)      , JJ=1,LENFOR)
      STOP 1090
C
C     PARSE OF ENTIRE FORMULA IS TRUE.
  460 CONTINUE
C
C     SET REVPOL ARRAY TO REVERSE POLISH NOTATION OF FORMULA.
C     USE STACK FOR OPERATORS.
C
C     SET MAXIMUM VALUE OF POINTER FOR STACK TO ZERO.
      MAXPTS = 0
C
C     SET POINTERS TO ZERO.
      PTSTAK = 0
      PTRPOL = 0
C
C     SET IVALUE TO ZERO.
      IVALUE = 0
C
      DO 660 II=1,PTINFX
C
C     SET IVALUE TO THE ELEMENT OF ARRAY FOR INFIX EXPRESSION.
      IVALUE = ICHAR(INFIXE(II))
C
      IF (IVALUE.GT.240)  GO TO 480
C
C     IVALUE POINTS TO AN OPERAND IN THE VARCON ARRAY.
C
C     INCREMENT POINTER FOR ARRAY FOR REVERSE POLISH NOTATION.
      PTRPOL = PTRPOL + 1
C
C     SET ELEMENT OF ARRAY FOR REVERSE POLISH NOTATION
C     TO NEGATIVE OF IVALUE OPERAND.
      REVPOL(PTRPOL) = -IVALUE
C
C     PROCESS NEXT ELEMENT OF ARRAY FOR INFIX EXPRESSION.
      GO TO 660
C
C     IVALUE IS AN OPERATOR.
  480 CONTINUE
C
C     SET IVALUE OPERATOR TO A VALUE FROM ONE TO SEVEN.
      IVALUE = IVALUE - 240
C
      IF (IVALUE.NE.7)  GO TO 580
C
C     IVALUE OPERATOR IS ')'.
C
C     POP OPERATOR STACK THROUGH '('.
C     STORE ARITHMETIC OPERATORS FROM ONE TO FIVE (BUT NOT THE '(')
C     IN ARRAY FOR REVERSE POLISH NOTATION.
C
C     SET POINTER FOR STACK TO MAXIMUM VALUE OF POINTER FOR STACK.
      PTSTAK = MAXPTS
C
  520 CONTINUE
C
C
      IF (PTSTAK.LT.1)  THEN
         PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1              (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2              (FORMLA(JJ)      , JJ=1,LENFOR)
         STOP 1120
      ENDIF
C
C     SET TVALUE TO TEST OPERATOR FROM STACK.
      TVALUE = STACK(PTSTAK)
C
C     SKIP OVER OPERATORS THAT HAVE BEEN POPPED BEFORE.
      IF (TVALUE.EQ.0)  GO TO 560
C
C     STOP POPPING PROCESS IF TEST OPERATOR IS '('.
      IF (TVALUE.NE.6)  GO TO 540
C
C     TEST OPERATOR IS '('.
C
      IF (PTSTAK.LT.1)  THEN
         PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1              (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2              (FORMLA(JJ)      , JJ=1,LENFOR)
         STOP 1120
      ENDIF
C
C
C     SET ELEMENT FROM STACK TO ZERO TO INDICATE THAT
C     OPERATOR HAS BEEN POPPED.
      STACK(PTSTAK) = 0
C
C     PROCESS NEXT ELEMENT OF ARRAY FOR INFIX EXPRESSION.
      GO TO 660
C
C     TEST OPERATOR HAS A VALUE FROM ONE TO FIVE.
  540 CONTINUE
C
C     INCREMENT POINTER FOR ARRAY FOR REVERSE POLISH NOTATION.
      PTRPOL = PTRPOL + 1
C
C     SET ELEMENT OF ARRAY FOR REVERSE POLISH NOTATION
C     TO TEST OPERATOR.
      REVPOL(PTRPOL) = TVALUE
C
C     SET ELEMENT FROM STACK TO ZERO TO INDICATE THAT
C     OPERATOR HAS BEEN POPPED.
      STACK(PTSTAK) = 0
C
  560 CONTINUE
C
C     DECREMENT POINTER FOR STACK.
      PTSTAK = PTSTAK - 1
C
C     BRANCH TO TEST THE OPERATOR FROM STACK AT POINTER.
      GO TO 520
C
  580 CONTINUE
C
C     IVALUE OPERATOR HAS A VALUE FROM ONE TO SIX.
C
C     INCREMENT MAXIMUM VALUE OF POINTER FOR OPERATOR STACK.
      MAXPTS = MAXPTS + 1
C
C     SET ELEMENT OF OPERATOR STACK TO IVALUE OPERATOR.
      STACK(MAXPTS) = IVALUE
C
C     IF THE IVALUE OPERATOR IS '(', PROCESS NEXT
C     ELEMENT OF ARRAY FOR INFIX EXPRESSION.
      IF (IVALUE.EQ.6)  GO TO 660
C
C     IVALUE OPERATOR HAS A VALUE FROM ONE TO FIVE.
C
C     POP OUT OF STACK THE OPERATORS THAT ARE GREATER THAN
C     OR EQUAL TO THE IVALUE OPERATOR.
C
C     SET IPRIOR TO THE PRIORITY OF THE IVALUE OPERATOR.
      IPRIOR = PRIOR(IVALUE)
C
C     SET POINTER FOR STACK TO MAXIMUM VALUE OF POINTER FOR STACK
C     MINUS ONE.
      PTSTAK = MAXPTS - 1
C
  620 CONTINUE
C
C     IF POINTER FOR STACK IS ZERO, PROCESS NEXT
C     ELEMENT OF ARRAY FOR INFIX EXPRESSION.
      IF (PTSTAK.EQ.0)  GO TO 660
C
C
      IF (PTSTAK.LT.1)  THEN
         PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1              (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2              (FORMLA(JJ)      , JJ=1,LENFOR)
         STOP 1120
      ENDIF
C
C     SET TVALUE TO TEST OPERATOR FROM STACK.
      TVALUE = STACK(PTSTAK)
C
C     SKIP OVER OPERATORS THAT HAVE BEEN POPPED BEFORE.
      IF (TVALUE.EQ.0)  GO TO 640
C
C     IF THE TEST OPERATOR IS '(', PROCESS NEXT
C     ELEMENT OF ARRAY FOR INFIX EXPRESSION.
      IF (TVALUE.EQ.6)  GO TO 660
C
C     TEST OPERATOR HAS A VALUE FROM ONE TO FIVE.
C
C     SET TPRIOR TO THE PRIORITY OF THE TEST OPERATOR.
      TPRIOR = PRIOR(TVALUE)
C
C     IF PRIORITY OF TEST   OPERATOR IS LESS THAN
C        PRIORITY OF IVALUE OPERATOR, SKIP OVER TEST OPERATOR.
      IF (TPRIOR.LT.IPRIOR)  GO TO 640
C
C     PRIORITY OF TEST   OPERATOR IS GREATER THAN OR EQUAL TO
C     PRIORITY OF IVALUE OPERATOR.
C
C     INCREMENT POINTER FOR ARRAY FOR REVERSE POLISH NOTATION.
      PTRPOL = PTRPOL + 1
C
C     SET ELEMENT OF ARRAY FOR REVERSE POLISH NOTATION
C     TO TEST OPERATOR.
      REVPOL(PTRPOL) = TVALUE
C
C     SET ELEMENT FROM STACK TO ZERO TO INDICATE THAT
C     OPERATOR HAS BEEN POPPED.
      STACK(PTSTAK) = 0
C
  640 CONTINUE
C
C     DECREMENT POINTER FOR STACK.
      PTSTAK = PTSTAK - 1
C
C     BRANCH TO TEST THE OPERATOR FROM STACK AT POINTER.
      GO TO 620
C
C     PROCESS NEXT ELEMENT OF ARRAY FOR INFIX EXPRESSION.
  660 CONTINUE
C
C     ALL OF ARRAY FOR INFIX EXPRESSION HAS BEEN PROCESSED.
C
C     POP OUT OF STACK ANY REMAINING OPERATORS.
C
C     SET POINTER FOR STACK TO MAXIMUM VALUE OF POINTER FOR STACK.
      PTSTAK = MAXPTS
C
C     IF MAXIMUM VALUE OF POINTER FOR STACK IS ZERO,
C     BRANCH AROUND LOOP 680.
      IF (MAXPTS.EQ.0)  GO TO 690
C
      DO 680 II=1,MAXPTS
C
C
      IF (PTSTAK.LT.1)  THEN
         PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1              (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2              (FORMLA(JJ)      , JJ=1,LENFOR)
         STOP 1120
      ENDIF
C
C     SET TVALUE TO TEST OPERATOR FROM STACK.
      TVALUE = STACK(PTSTAK)
C
C     SKIP OVER OPERATORS THAT HAVE BEEN POPPED BEFORE.
      IF (TVALUE.EQ.0)  GO TO 670
C
C     TEST OPERATOR HAS A VALUE FROM ONE TO FIVE.
C
C     INCREMENT POINTER FOR ARRAY FOR REVERSE POLISH NOTATION.
      PTRPOL = PTRPOL + 1
C
C     SET ELEMENT OF ARRAY FOR REVERSE POLISH NOTATION
C     TO TEST OPERATOR.
      REVPOL(PTRPOL) = TVALUE
C
  670 CONTINUE
C
C     DECREMENT POINTER FOR STACK.
      PTSTAK = PTSTAK - 1
C
  680 CONTINUE
C
  690 CONTINUE
C
C     REVPOL ARRAY IS SET TO REVERSE POLISH NOTATION OF FORMULA.
C
C     EVALUATE REVERSE POLISH NOTATION OF FORMULA.
C     USE STACK FOR OPERANDS.
C
C     SET MAXPTR TO MAXIMUM VALUE OF
C     POINTER FOR ARRAY FOR REVERSE POLISH NOTATION.
      MAXPTR = PTRPOL
C
C     SET POINTER FOR STACK TO ZERO.
      PTSTAK = 0
C
      DO 860 PTRPOL=1,MAXPTR
C
C     SET IVALUE TO THE ELEMENT OF
C     ARRAY FOR REVERSE POLISH NOTATION.
      IVALUE = REVPOL(PTRPOL)
C
      IF (IVALUE.GT.0)  GO TO 720
C
C     NEGATIVE OF IVALUE POINTS TO AN OPERAND IN THE VARCON ARRAY.
C
C     INCREMENT POINTER FOR STACK.
      PTSTAK = PTSTAK + 1
C
C     PUSH OPERAND INTO STACK.
      STACK(PTSTAK) = VARCON(-IVALUE)
C
C     PROCESS NEXT ELEMENT OF
C     ARRAY FOR REVERSE POLISH NOTATION.
      GO TO 860
C
C     IVALUE IS AN OPERATOR FROM ONE TO FIVE.
  720 CONTINUE
C
C     EXECUTE THE IVALUE OPERATOR ON THE TWO OPERANDS
C     AT TOP OF STACK, POP THEM, AND PUSH RESULT INTO STACK.
C
C     SET TVALUE TO THE OPERAND AT TOP OF STACK.
      TVALUE = STACK(PTSTAK)
C
C     DECREMENT POINTER FOR STACK.
      PTSTAK = PTSTAK - 1
C
      IF (IVALUE.NE.1)  GO TO 740
C
C     THE IVALUE OPERATOR IS 1 FOR '+'.
C
C     EXECUTE OPERATOR AND PUSH RESULT INTO STACK.
      STACK(PTSTAK) = STACK(PTSTAK) + TVALUE
C
C     PROCESS NEXT ELEMENT OF
C     ARRAY FOR REVERSE POLISH NOTATION.
      GO TO 860
C
  740 CONTINUE
C
      IF (IVALUE.NE.2)  GO TO 760
C
C     THE IVALUE OPERATOR IS 2 FOR '-'.
C
C     EXECUTE OPERATOR AND PUSH RESULT INTO STACK.
      STACK(PTSTAK) = STACK(PTSTAK) - TVALUE
C
C     PROCESS NEXT ELEMENT OF
C     ARRAY FOR REVERSE POLISH NOTATION.
      GO TO 860
C
  760 CONTINUE
C
      IF (IVALUE.NE.3)  GO TO 780
C
C     THE IVALUE OPERATOR IS 3 FOR '*'.
C
C     EXECUTE OPERATOR AND PUSH RESULT INTO STACK.
      STACK(PTSTAK) = STACK(PTSTAK) * TVALUE
C
C     PROCESS NEXT ELEMENT OF
C     ARRAY FOR REVERSE POLISH NOTATION.
      GO TO 860
C
  780 CONTINUE
C
      IF (IVALUE.NE.4)  GO TO 820
C
C     THE IVALUE OPERATOR IS 4 FOR '/'.
C
C     EXECUTE OPERATOR AND PUSH RESULT INTO STACK.
      STACK(PTSTAK) = STACK(PTSTAK) / TVALUE
C
C     PROCESS NEXT ELEMENT OF
C     ARRAY FOR REVERSE POLISH NOTATION.
      GO TO 860
C
  820 CONTINUE
C
      IF (IVALUE.NE.5)  GO TO 840
C
C     THE IVALUE OPERATOR IS 5 FOR '**'.
C
C     EXECUTE OPERATOR AND PUSH RESULT INTO STACK.
      STACK(PTSTAK) = STACK(PTSTAK) ** TVALUE
C
C     PROCESS NEXT ELEMENT OF
C     ARRAY FOR REVERSE POLISH NOTATION.
      GO TO 860
C
  840 CONTINUE
C
C     THE IVALUE OPERATOR IN INVALID.
      PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1           (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2           (FORMLA(JJ)      , JJ=1,LENFOR)
      STOP 1110
C
C     PROCESS NEXT ELEMENT OF
C     ARRAY FOR REVERSE POLISH NOTATION.
  860 CONTINUE
C
C     REVERSE POLISH NOTATION OF FORMULA IS EVALUATED.
C
C     POINTER FOR STACK IS INVALID IF NOT EQUAL TO ONE.
      IF (PTSTAK.NE.1)  THEN
         PRINT 100, (VARNAM(JJ,VARNO), JJ=1,LENNAM(VARNO)),
     1              (BLANK           , JJ=  LENNAM(VARNO)+1,9),
     2              (FORMLA(JJ)      , JJ=1,LENFOR)
         STOP 1120
      ENDIF
C
C     SET IVALUE TO VALUE OF FORMULA.
      IVALUE = STACK(1)
C
C     SET VALUE ARRAY TO IVALUE BY USING A FORMATTED WRITE.
C
      WRITE (VALUE,920) IVALUE
  920 FORMAT (I16)
C
C     COUNT NUMBER OF BLANKS AT BEGINNING OF VALUE.
      NBLANK = 0
      DO 940 II=1,15
            IF (VALUE(II:II).NE.BLANK)  GO TO 960
            NBLANK = NBLANK + 1
  940 CONTINUE
  960 CONTINUE
C
      LVALUE = 16 - NBLANK
C
C     SET VARIABLE VALUE LENGTH TO LVALUE.
      LENVAL(VARNO) = LVALUE
C
C     SET VARIABLE VALUE.
      JJ = NBLANK + 1
      DO 980 II=1,LVALUE
            VARVAL(II,VARNO) = VALUE(JJ:JJ)
            JJ = JJ + 1
  980 CONTINUE
C
      RETURN
      END
      SUBROUTINE OPENP (IND)
C
C     PARSE OF (OPEN PAREN).
C
C     (OPEN PAREN) = /'('/
C
C
      COMMON /FORM/ LENFOR, PTFORM, PTINFX, FORMLA(200), INFIXE(200)
C
      INTEGER          LENFOR, PTFORM, PTINFX
      CHARACTER*1      FORMLA, INFIXE
C
C     LENFOR - LENGTH OF FORMULA.
C     PTFORM - POINTER FOR FORMULA.
C     PTINFX - POINTER FOR INFIX EXPRESSION.
C     FORMLA - ARRAY FOR FORMULA OF ONE TO LENFOR NONBLANK CHARACTERS.
C     INFIXE - ARRAY FOR INFIX EXPRESSION.
C
C
      CHARACTER*1      OPAREN
      DATA             OPAREN        /'('/
      CHARACTER*1      L6
C
C
      L6 = CHAR(246)
C
C     INCREMENT POINTER FOR FORMULA.
      PTFORM = PTFORM + 1
C
C     INCREMENT POINTER FOR INFIX EXPRESSION.
      PTINFX = PTINFX + 1
C
C     HAS POINTER FOR FORMULA EXCEEDED LENGTH OF FORMULA?
      IF (PTFORM.GT.LENFOR)  GO TO 200
C
      IF (FORMLA(PTFORM).NE.OPAREN)  GO TO 200
C
C     PARSE OF (OPEN PAREN) IS TRUE.
C
C     SET INDICATOR OF PARSE OF (OPEN PAREN) TO 1 FOR TRUE.
      IND = 1
C
C     SET ELEMENT OF ARRAY FOR INFIX EXPRESSION
C     TO VALUE FOR OPEN PARENTHESIS.
      INFIXE(PTINFX) = L6
C
      RETURN
C
  200 CONTINUE
C
C     PARSE OF (OPEN PAREN) IS FALSE.
C
C     SET INDICATOR OF PARSE OF (OPEN PAREN) TO 0 FOR FALSE.
      IND = 0
C
      RETURN
      END
      SUBROUTINE CLOSEP (IND)
C
C     PARSE OF (CLOSE PAREN).
C
C     (CLOSE PAREN) = /')'/
C
C
      COMMON /FORM/ LENFOR, PTFORM, PTINFX, FORMLA(200), INFIXE(200)
C
      INTEGER          LENFOR, PTFORM, PTINFX
      CHARACTER*1      FORMLA, INFIXE
C
C     LENFOR - LENGTH OF FORMULA.
C     PTFORM - POINTER FOR FORMULA.
C     PTINFX - POINTER FOR INFIX EXPRESSION.
C     FORMLA - ARRAY FOR FORMULA OF ONE TO LENFOR NONBLANK CHARACTERS.
C     INFIXE - ARRAY FOR INFIX EXPRESSION.
C
C
      CHARACTER*1      CPAREN
      DATA             CPAREN        /')'/
      CHARACTER*1      L7
C
C
      L7 = CHAR(247)
C
C     INCREMENT POINTER FOR FORMULA.
      PTFORM = PTFORM + 1
C
C     INCREMENT POINTER FOR INFIX EXPRESSION.
      PTINFX = PTINFX + 1
C
C     HAS POINTER FOR FORMULA EXCEEDED LENGTH OF FORMULA?
      IF (PTFORM.GT.LENFOR)  GO TO 200
C
      IF (FORMLA(PTFORM).NE.CPAREN)  GO TO 200
C
C     PARSE OF (CLOSE PAREN) IS TRUE.
C
C     SET INDICATOR OF PARSE OF (CLOSE PAREN) TO 1 FOR TRUE.
      IND = 1
C
C     SET ELEMENT OF ARRAY FOR INFIX EXPRESSION
C     TO VALUE FOR CLOSE PARENTHESIS.
      INFIXE(PTINFX) = L7
C
      RETURN
C
  200 CONTINUE
C
C     PARSE OF (CLOSE PAREN) IS FALSE.
C
C     SET INDICATOR OF PARSE OF (CLOSE PAREN) TO 0 FOR FALSE.
      IND = 0
C
      RETURN
      END
      SUBROUTINE OPERAT (IND)
C
C     PARSE OF (OPERATOR).
C
C     (OPERATOR) = / '+' / '-' / '/' / '*' / '**' /
C
C
      COMMON /FORM/ LENFOR, PTFORM, PTINFX, FORMLA(200), INFIXE(200)
C
      INTEGER          LENFOR, PTFORM, PTINFX
      CHARACTER*1      FORMLA, INFIXE
C
C     LENFOR - LENGTH OF FORMULA.
C     PTFORM - POINTER FOR FORMULA.
C     PTINFX - POINTER FOR INFIX EXPRESSION.
C     FORMLA - ARRAY FOR FORMULA OF ONE TO LENFOR NONBLANK CHARACTERS.
C     INFIXE - ARRAY FOR INFIX EXPRESSION.
C
C
      CHARACTER*1      PLUS
      DATA             PLUS          /'+'/
      CHARACTER*1      MINUS
      DATA             MINUS         /'-'/
      CHARACTER*1      STAR
      DATA             STAR          /'*'/
      CHARACTER*1      DIVIDE
      DATA             DIVIDE        /'/'/
      CHARACTER*1      L1
      CHARACTER*1      L2
      CHARACTER*1      L3
      CHARACTER*1      L4
      CHARACTER*1      L5
      CHARACTER*1      FLTEST
      INTEGER          PTTEST
C
C
      L1 = CHAR(241)
      L2 = CHAR(242)
      L3 = CHAR(243)
      L4 = CHAR(244)
      L5 = CHAR(245)
C
C     INCREMENT POINTER FOR FORMULA.
      PTFORM = PTFORM + 1
C
C     INCREMENT POINTER FOR INFIX EXPRESSION.
      PTINFX = PTINFX + 1
C
C     HAS POINTER FOR FORMULA EXCEEDED LENGTH OF FORMULA?
      IF (PTFORM.GT.LENFOR)  GO TO 500
C
C     SET FLTEST TO ELEMENT OF FORMULA AT POINTER FOR FORMULA.
      FLTEST = FORMLA(PTFORM)
C
      IF (FLTEST.NE.PLUS)  GO TO 200
C
C     (OPERATOR) = / '+' / IS TRUE.
C
C     SET INDICATOR OF PARSE OF (OPERATOR) TO 1 FOR TRUE.
      IND = 1
C
C     SET ELEMENT OF ARRAY FOR INFIX EXPRESSION
C     TO VALUE FOR PLUS SIGN.
      INFIXE(PTINFX) = L1
C
      RETURN
C
  200 CONTINUE
C
      IF (FLTEST.NE.MINUS)  GO TO 300
C
C     (OPERATOR) = / '-' / IS TRUE.
C
C     SET INDICATOR OF PARSE OF (OPERATOR) TO 1 FOR TRUE.
      IND = 1
C
C     SET ELEMENT OF ARRAY FOR INFIX EXPRESSION
C     TO VALUE FOR MINUS SIGN.
      INFIXE(PTINFX) = L2
C
      RETURN
C
  300 CONTINUE
C
      IF (FLTEST.NE.DIVIDE)  GO TO 400
C
C     (OPERATOR) = / '/' / IS TRUE.
C
C     SET INDICATOR OF PARSE OF (OPERATOR) TO 1 FOR TRUE.
      IND = 1
C
C     SET ELEMENT OF ARRAY FOR INFIX EXPRESSION
C     TO VALUE FOR DIVIDE SIGN.
      INFIXE(PTINFX) = L4
C
      RETURN
C
  400 CONTINUE
C
      IF (FLTEST.NE.STAR)  GO TO 500
C
C     (OPERATOR) = / '*' / IS TRUE.
C
C     SET INDICATOR OF PARSE OF (OPERATOR) TO 1 FOR TRUE.
      IND = 1
C
C     SET ELEMENT OF ARRAY FOR INFIX EXPRESSION
C     TO VALUE FOR STAR SIGN.
      INFIXE(PTINFX) = L3
C
C     ARE THERE TWO STARS FOR EXPONENTIATION?
C
C     SET TEST POINTER TO POINTER FOR FORMULA PLUS ONE.
      PTTEST = PTFORM + 1
C
C     HAS TEST POINTER EXCEEDED LENGTH OF FORMULA?
      IF (PTTEST.GT.LENFOR)  RETURN
C
      IF (FORMLA(PTTEST).NE.STAR)  RETURN
C
C     (OPERATOR) = / '**' / IS TRUE.
C
C     SET INDICATOR OF PARSE OF (OPERATOR) TO 1 FOR TRUE.
      IND = 1
C
C     SET POINTER FOR FORMULA TO TEST POINTER.
      PTFORM = PTTEST
C
C     SET ELEMENT OF ARRAY FOR INFIX EXPRESSION
C     TO VALUE FOR TWO STAR SIGNS.
      INFIXE(PTINFX) = L5
C
      RETURN
C
  500 CONTINUE
C
C     PARSE OF (OPERATOR) IS FALSE.
C
C     SET INDICATOR OF PARSE OF (OPERATOR) TO 0 FOR FALSE.
      IND = 0
C
      RETURN
      END
      SUBROUTINE CONST (IND, VARCON, PTVRCN)
C
C     PARSE OF (CONSTANT).
C
C     (CONSTANT) = / (MINUS) (NUMBER) / (NUMBER) /
C
C     (MINUS) = / '-' /
C
C     (NUMBER) = / (FROM 1 TO 10) (DIGIT)'S /
C
C     (DIGIT) = / '0' / '1' / '2' / '3' / '4' /
C               / '5' / '6' / '7' / '8' / '9' /
C
C
      COMMON /FORM/ LENFOR, PTFORM, PTINFX, FORMLA(200), INFIXE(200)
C
      INTEGER          LENFOR, PTFORM, PTINFX
      CHARACTER*1      FORMLA, INFIXE
C
C     LENFOR - LENGTH OF FORMULA.
C     PTFORM - POINTER FOR FORMULA.
C     PTINFX - POINTER FOR INFIX EXPRESSION.
C     FORMLA - ARRAY FOR FORMULA OF ONE TO LENFOR NONBLANK CHARACTERS.
C     INFIXE - ARRAY FOR INFIX EXPRESSION.
C
C
      CHARACTER*1      MINUS
      DATA             MINUS         /'-'/
      CHARACTER*1      DIGIT(10)
      DATA             DIGIT         /'0', '1', '2', '3', '4',
     1                                '5', '6', '7', '8', '9'/
      INTEGER          PTTEST
      CHARACTER*1      FLTEST
      CHARACTER*21     BLANKS
      CHARACTER*1       CONSNT(11)
      EQUIVALENCE      (CONSNT(1), BLANKS(11:11))
      INTEGER          VARCON(200)
      INTEGER          PTVRCN
      INTEGER          PTVC
C
      DATA             BLANKS        /'                     '/
C
C
C     SET LENGTH OF CONSTANT TO ZERO.
      LENCST = 0
C
C     PARSE OF (MINUS).
C
C     SET TEST POINTER TO POINTER FOR FORMULA PLUS ONE.
      PTTEST = PTFORM + 1
C
C     HAS TEST POINTER EXCEEDED LENGTH OF FORMULA?
      IF (PTTEST.GT.LENFOR)  GO TO 800
C
C     SET FLTEST TO ELEMENT OF FORMULA TO TEST.
      FLTEST = FORMLA(PTTEST)
C
      IF (FLTEST.NE.MINUS)  GO TO 200
C
C     PARSE OF (MINUS) IS TRUE.
C
C     INCREMENT LENGTH OF CONSTANT.
      LENCST = LENCST + 1
C
C     SET POINTER FOR FORMULA TO TEST POINTER.
      PTFORM = PTTEST
C
C     SET ELEMENT OF CONSNT ARRAY TO THE MINUS SIGN.
      CONSNT(LENCST) = FLTEST
C
  200 CONTINUE
C
C     PARSE OF (NUMBER).
C
C     SET LENGTH OF NUMBER TO ZERO.
      LENNUM = 0
C
      DO 500 II=1,10
C
C           PARSE OF (DIGIT).
C
C           SET TEST POINTER TO POINTER FOR FORMULA PLUS ONE.
            PTTEST = PTFORM + 1
C
C           HAS TEST POINTER EXCEEDED LENGTH OF FORMULA?
            IF (PTTEST.GT.LENFOR)  GO TO 600
C
C           SET FLTEST TO ELEMENT OF FORMULA TO TEST.
            FLTEST = FORMLA(PTTEST)
C
                  DO 300 JJ=1,10
                        IF (FLTEST.EQ.DIGIT(JJ))  GO TO 400
  300             CONTINUE
C
C           PARSE OF (DIGIT) IS FALSE.
            GO TO 600
C
C           PARSE OF (DIGIT) IS TRUE.
  400       CONTINUE
C
C           INCREMENT LENGTH OF NUMBER.
            LENNUM = LENNUM + 1
C
C           INCREMENT LENGTH OF CONSTANT.
            LENCST = LENCST + 1
C
C           SET POINTER FOR FORMULA TO TEST POINTER.
            PTFORM = PTTEST
C
C           SET ELEMENT OF CONSNT ARRAY TO THE DIGIT.
            CONSNT(LENCST) = FLTEST
C
  500 CONTINUE
C
  600 CONTINUE
C
C     PARSE OF (NUMBER) IS FALSE IF LENGTH OF NUMBER IS ZERO.
      IF (LENNUM.EQ.0)  GO TO 800
C
C     PARSE OF (CONSTANT) IS TRUE.
C
C     SET INDICATOR OF PARSE OF (CONSTANT) TO 1 FOR TRUE.
      IND = 1
C
C     INCREMENT POINTER FOR VARCON ARRAY.
      PTVRCN = PTVRCN + 1
C
C     SET PTVC TO POINTER FOR VARCON ARRAY.
      PTVC = PTVRCN
C
C     INCREMENT POINTER FOR INFIX EXPRESSION.
      PTINFX = PTINFX + 1
C
C     SET ELEMENT OF ARRAY FOR INFIX EXPRESSION
C     TO POINTER FOR VARCON ARRAY.
      INFIXE(PTINFX) = CHAR(PTVC)
C
C     SET ELEMENT OF VARCON ARRAY TO I*4 VALUE OF CONSTANT.
      READ (BLANKS(LENCST:LENCST+10), 700) VARCON(PTVRCN)
  700 FORMAT (I11)
C
      RETURN
C
  800 CONTINUE
C
C     PARSE OF (CONSTANT) IS FALSE.
C
C     SET INDICATOR OF PARSE OF (CONSTANT) TO 0 FOR FALSE.
      IND = 0
C
      RETURN
      END
      SUBROUTINE SETFR (CARD, IPT, NFT)
C
C     STORE FORMULA AND
C     MOVE POINTER IPT TO NEXT SEMICOLON.
C
      CHARACTER*1     CARD(72)
      CHARACTER*1     BLANK
      DATA            BLANK          /' '/
      CHARACTER*1     SEMICL
      DATA            SEMICL         /';'/
C
C
      COMMON /FORM/ LENFOR, PTFORM, PTINFX, FORMLA(200), INFIXE(200)
C
      INTEGER          LENFOR, PTFORM, PTINFX
      CHARACTER*1      FORMLA, INFIXE
C
C     LENFOR - LENGTH OF FORMULA.
C     PTFORM - POINTER FOR FORMULA.
C     PTINFX - POINTER FOR INFIX EXPRESSION.
C     FORMLA - ARRAY FOR FORMULA OF ONE TO LENFOR NONBLANK CHARACTERS.
C     INFIXE - ARRAY FOR INFIX EXPRESSION.
C
C
C     SET FORMLA ARRAY TO FORMULA,
C     I.E., THE STRING OF NONBLANK CHARACTERS BETWEEN '=' AND ';'.
C
C     SET LENFOR TO LENGTH OF FORMULA.
C     MAXIMUM LENGTH OF FORMULA IS 200 NONBLANK CHARACTERS.
C
      LENFOR = 0
C
C     DO NOT INCREMENT POINTER IPT AT BEGINNING,
C     BECAUSE POINTER IPT IS AT CHARACTER AFTER '='.
      GO TO 250
C
200   CONTINUE
      IPT = IPT + 1
250   CONTINUE
      IF (IPT.LT.73)  GO TO 400
         IPT = 0
C
C        READ THE NEXT RECORD.
         DO 567 IJK=1,72
                CARD(IJK) = ' '
567      CONTINUE
         READ (NFT,300,END=500)  CARD
300      FORMAT (72A1)
C
         GO TO 200
400   CONTINUE
      IF (CARD(IPT).EQ.BLANK)   GO TO 200
      IF (CARD(IPT).EQ.SEMICL)  THEN
C
C        TEST FOR INVALID LENGTH OF FORMULA.
         IF (LENFOR.LT.1)  THEN
            PRINT 420, CARD
420         FORMAT (/ ' ********** ERROR ',
     1                ' PROCESSING  % #VARNAME = FORMULA ; '
     2              / ' LENGTH OF FORMULA LESS THAN ONE. '
     3              / 1X, 72A1)
            STOP 1030
         ENDIF
C
         RETURN
      ENDIF
C
      LENFOR = LENFOR + 1
      IF (LENFOR.GT.200)  THEN
         PRINT 440, CARD
440      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING  % #VARNAME = FORMULA ; '
     2           / ' FORMULA GREATER THAN 200 NONBLANK CHARACTERS. '
     3           / 1X, 72A1)
         STOP 1010
      ENDIF
      FORMLA(LENFOR) = CARD(IPT)
      GO TO 200
C
500   CONTINUE
C
C     END-OF-FILE REACHED.
      PRINT 600, CARD
600   FORMAT (/ ' ********** ERROR ',
     1          ' PROCESSING  % #VARNAME = FORMULA ; '
     2        / ' END OF INPUT FILE OR INCLUDED FILE REACHED'
     3        / ' WHILE STORING NONBLANK CHARACTERS OF FORMULA. '
     4        / 1X, 72A1)
      STOP  1020
C
      END
      SUBROUTINE VARIAB (IND, VARCON, PTVRCN)
C
C     PARSE OF (VARIABLE).
C
C     (VARIABLE) = A VALID VARIABLE NAME
C                  WHICH WAS INITIALIZED BEFORE.
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C              E.G., NOLEN(5) IS THE NUMBER OF VARIABLE NAMES
C              OF LENGTH 5.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
      COMMON /FORM/ LENFOR, PTFORM, PTINFX, FORMLA(200), INFIXE(200)
C
      INTEGER          LENFOR, PTFORM, PTINFX
      CHARACTER*1      FORMLA, INFIXE
C
C     LENFOR - LENGTH OF FORMULA.
C     PTFORM - POINTER FOR FORMULA.
C     PTINFX - POINTER FOR INFIX EXPRESSION.
C     FORMLA - ARRAY FOR FORMULA OF ONE TO LENFOR NONBLANK CHARACTERS.
C     INFIXE - ARRAY FOR INFIX EXPRESSION.
C
C
      INTEGER          VARCON(200)
      INTEGER          PTVRCN
      INTEGER          PTVC
      CHARACTER*16     TSTVAR
      CHARACTER*1      NUM
      DATA             NUM               /'#'/
      CHARACTER*1      BLANK
      DATA             BLANK             /' '/
      INTEGER          TNOLEN
      INTEGER          VARNO
C
C
C     INCREMENT POINTER FOR FORMULA.
      PTFORM = PTFORM + 1
C
C     HAS POINTER FOR FORMULA EXCEEDED LENGTH OF FORMULA?
      IF (PTFORM.GT.LENFOR)  GO TO 900
C
      IF (FORMLA(PTFORM).NE.NUM)  GO TO 900
C
C     FIND MAXIMUM LENGTH OF TEST VARIABLE,
C     I.E., CHARACTER STRING OF FORMULA BEGINNING WITH '#'.
      LENMAX = LENFOR - PTFORM + 1
      IF (LENMAX.LT.2)  GO TO 900
      IF (LENMAX.GT.8)  LENMAX=8
C
C     COPY TEST VARIABLE TO TSTVAR ARRAY.
      JJ = PTFORM
      DO 300 II=1,LENMAX
            TSTVAR(II:II) = FORMLA(JJ)
            JJ = JJ + 1
300   CONTINUE
C
C     SEARCH FOR TEST VARIABLE AMONG VARIABLE NAMES.
C     START SEARCH WITH LONGEST VARIABLE NAMES.
C
      LENGTH = LENMAX
C
      DO 500 LL=2,LENMAX
C
      TNOLEN = NOLEN(LENGTH)
      IF (TNOLEN.EQ.0)  GO TO 450
C
      NFOUND = 0
C
      DO 400 NN=1,NOVAR
            VARNO = NN
            IF (LENNAM(VARNO).NE.LENGTH)  GO TO 400
            NFOUND = NFOUND + 1
C
                  DO 350 II=1,LENGTH
                  IF (VARNAM(II,VARNO) .NE. TSTVAR(II:II))  GO TO 370
350               CONTINUE
C
C           VARIABLE NAME HAS BEEN FOUND AT VARIABLE NUMBER VARNO.
            GO TO 550
C
370         CONTINUE
C
            IF (NFOUND.EQ.TNOLEN)  GO TO 450
C
400   CONTINUE
C
450   CONTINUE
C
C     TEST VARIABLE NOT FOUND AMONG
C     VARIABLE NAMES OF THIS LENGTH.
C
C     TRY LENGTH LESS ONE.
      LENGTH = LENGTH - 1
C
500   CONTINUE
C
C     TEST VARIABLE NOT FOUND AMONG
C     ALL OF THE VARIABLE NAMES.
      GO TO 900
C
C     VARIABLE NAME HAS BEEN FOUND AT VARIABLE NUMBER VARNO.
550   CONTINUE
C
C     PARSE OF (VARIABLE) IS TRUE.
C
C     SET INDICATOR OF PARSE OF (VARIABLE) TO 1 FOR TRUE.
      IND = 1
C
C     INCREMENT POINTER FOR VARCON ARRAY.
      PTVRCN = PTVRCN + 1
C
C     SET PTVC TO POINTER FOR VARCON ARRAY.
      PTVC = PTVRCN
C
C     INCREMENT POINTER FOR INFIX EXPRESSION.
      PTINFX = PTINFX + 1
C
C     SET ELEMENT OF ARRAY FOR INFIX EXPRESSION
C     TO POINTER FOR VARCON ARRAY.
      INFIXE(PTINFX) = CHAR(PTVC)
C
C     SET TSTVAR ARRAY TO BLANKS.
      DO 600 II=1,16
            TSTVAR(II:II) = BLANK
  600 CONTINUE
C
C     SET LENMAX TO VARIABLE VALUE LENGTH.
      LENMAX = LENVAL(VARNO)
C
C     IF (LENMAX.LT.1)  GO TO 770
C
C     SET TSTVAR ARRAY TO NONBLANK CHARACTERS
C     OF VARIABLE VALUE ARRAY.
      JJ = LENMAX
      II = 16
      DO 750 LL=1,LENMAX
            IF (VARVAL(JJ,VARNO).EQ.BLANK)  GO TO 730
                  TSTVAR(II:II) = VARVAL(JJ,VARNO)
                  II = II - 1
  730       CONTINUE
            JJ = JJ - 1
  750 CONTINUE
C
C     SET ELEMENT OF VARCON ARRAY TO I*4 VARIABLE VALUE.
      READ (TSTVAR,800) VARCON(PTVRCN)
  800 FORMAT (I16)
C
C     MOVE POINTER FOR FORMULA TO LAST CHARACTER OF VARIABLE.
      PTFORM = PTFORM + LENGTH - 1
C
      RETURN
C
  900 CONTINUE
C
C     PARSE OF (VARIABLE) IS FALSE.
C
C     SET INDICATOR OF PARSE OF (VARIABLE) TO 0 FOR FALSE.
      IND = 0
C
      RETURN
      END
      SUBROUTINE LEVEL1 (MEMBER)
C
C
C     PROCESS LEVEL 1 CARDS OF INCLUDED FILE.
C
C
      PARAMETER ( MAXMEM = 40 )
      PARAMETER ( MAXFIL = 72 + MAXMEM )
C
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      MLOWUP(MAXMEM,3)
C
      CHARACTER*1      CARD(72)
      INTEGER          NFT
      DATA             NFT            /11/
      CHARACTER*1      NUM
      DATA             NUM            /'#'/
      CHARACTER*1      PER
      DATA             PER            /'%'/
C
      CHARACTER*112    FILES
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /BPATH/
C     NOPATH - TOTAL NUMBER OF PATHS.
C     LNPATH - LENGTH OF EACH PATH.
C     PATH   - ARRAY OF PATHS.
      COMMON  /BPATH/  NOPATH,
     1                 LNPATH(20),
     2                 PATH(72,20)
      CHARACTER*1      PATH
C
C
C
      DO 105 J=1,MAXMEM
             NSEQ =  ICHAR(MEMBER(J))
             MLOWUP(J,1) = MEMBER(J)
             MLOWUP(J,2) = MEMBER(J)
             MLOWUP(J,3) = MEMBER(J)
C            CHANGE ASCII UPPERCASE LETTERS TO LOWERCASE LETTERS.
             IF ( (NSEQ .GE.  65)  .AND.  (NSEQ .LE.  90) )
     1       MLOWUP(J,1) = CHAR(NSEQ+32)
C            CHANGE ASCII LOWERCASE LETTERS TO UPPERCASE LETTERS.
             IF ( (NSEQ .GE.  97)  .AND.  (NSEQ .LE. 122) )
     1       MLOWUP(J,2) = CHAR(NSEQ-32)
105   CONTINUE
C
      DO 140 K=1,NOPATH
      DO 110 J=1,MAXFIL
             FILES(J:J) = ' '
110   CONTINUE
      DO 120 J=1,LNPATH(K)
             FILES(J:J) = PATH(J,K)
120   CONTINUE
      DO 135 NLU=1,3
      L = LNPATH(K) + 1
      DO 130 J=1,MAXMEM
             FILES(L:L) = MLOWUP(J,NLU)
             L = L + 1
130   CONTINUE
      OPEN (NFT, ERR=135, FILE=FILES, FORM='FORMATTED', STATUS='OLD')
      GO TO 170
135   CONTINUE
140   CONTINUE
      PRINT 150, MLOWUP
150   FORMAT (/ ' ********** ERROR - FILE NOT FOUND FOR % INCLUDE '
     1  / 1X, 40A1 / 1X, 40A1 / 1X, 40A1 )
      PRINT 160
160   FORMAT (/ ' END OF FORTRAN PREPROCESSOR. ')
      STOP 750
170   CONTINUE
C
CMJR
      PRINT 88888, FILES
88888 FORMAT ( A112 )
CMJR
200   CONTINUE
C
      DO 250 J=1,72
             CARD(J) = ' '
250   CONTINUE
      READ (NFT,300,END=800) CARD
300   FORMAT (72A1)
C
      DO 400 J=1,72
             IPT = J
             IF ( CARD(J) .EQ. NUM )  GO TO 600
             IF ( CARD(J) .EQ. PER )  GO TO 700
400   CONTINUE
C
      DO 450 J=72,1,-1
             LAST = J
             IF ( CARD(J) .NE. ' ' )  GO TO 460
450   CONTINUE
460   CONTINUE
C
CC    NOCARD = NOCARD + 1
      WRITE (9,300) (CARD(J), J=1,LAST)
CC500 FORMAT (72A1, I5, 3X)
      GO TO 200
C
600   CONTINUE
C     CALL VARBLE TO PROCESS A CARD WITH A VARIABLE NAME.
      CALL VARBLE (CARD, IPT)
      GO TO 200
C
700   CONTINUE
C     CALL PERCT1 TO PROCESS A CONTROL CARD.
      CALL PERCT1 (CARD, IPT, NFT)
      GO TO 200
C
800   CONTINUE
      CLOSE (NFT, STATUS='KEEP')
      RETURN
      END
      SUBROUTINE LEVEL2 (MEMBER)
C
C
C     PROCESS LEVEL 2 CARDS OF INCLUDED FILE.
C
C
      PARAMETER ( MAXMEM = 40 )
      PARAMETER ( MAXFIL = 72 + MAXMEM )
C
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      MLOWUP(MAXMEM,3)
C
      CHARACTER*1      CARD(72)
      INTEGER          NFT
      DATA             NFT            /12/
      CHARACTER*1      NUM
      DATA             NUM            /'#'/
      CHARACTER*1      PER
      DATA             PER            /'%'/
C
      CHARACTER*112    FILES
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /BPATH/
C     NOPATH - TOTAL NUMBER OF PATHS.
C     LNPATH - LENGTH OF EACH PATH.
C     PATH   - ARRAY OF PATHS.
      COMMON  /BPATH/  NOPATH,
     1                 LNPATH(20),
     2                 PATH(72,20)
      CHARACTER*1      PATH
C
C
C
      DO 105 J=1,MAXMEM
             NSEQ =  ICHAR(MEMBER(J))
             MLOWUP(J,1) = MEMBER(J)
             MLOWUP(J,2) = MEMBER(J)
             MLOWUP(J,3) = MEMBER(J)
C            CHANGE ASCII UPPERCASE LETTERS TO LOWERCASE LETTERS.
             IF ( (NSEQ .GE.  65)  .AND.  (NSEQ .LE.  90) )
     1       MLOWUP(J,1) = CHAR(NSEQ+32)
C            CHANGE ASCII LOWERCASE LETTERS TO UPPERCASE LETTERS.
             IF ( (NSEQ .GE.  97)  .AND.  (NSEQ .LE. 122) )
     1       MLOWUP(J,2) = CHAR(NSEQ-32)
105   CONTINUE
C
      DO 140 K=1,NOPATH
      DO 110 J=1,MAXFIL
             FILES(J:J) = ' '
110   CONTINUE
      DO 120 J=1,LNPATH(K)
             FILES(J:J) = PATH(J,K)
120   CONTINUE
      DO 135 NLU=1,3
      L = LNPATH(K) + 1
      DO 130 J=1,MAXMEM
             FILES(L:L) = MLOWUP(J,NLU)
             L = L + 1
130   CONTINUE
      OPEN (NFT, ERR=135, FILE=FILES, FORM='FORMATTED', STATUS='OLD')
      GO TO 170
135   CONTINUE
140   CONTINUE
      PRINT 150, MLOWUP
150   FORMAT (/ ' ********** ERROR - FILE NOT FOUND FOR % INCLUDE '
     1  / 1X, 40A1 / 1X, 40A1 / 1X, 40A1 )
      PRINT 160
160   FORMAT (/ ' END OF FORTRAN PREPROCESSOR. ')
      STOP 750
170   CONTINUE
C
CMJR
      PRINT 88888, FILES
88888 FORMAT ( A112 )
CMJR
200   CONTINUE
C
      DO 250 J=1,72
             CARD(J) = ' '
250   CONTINUE
      READ (NFT,300,END=800) CARD
300   FORMAT (72A1)
C
      DO 400 J=1,72
             IPT = J
             IF ( CARD(J) .EQ. NUM )  GO TO 600
             IF ( CARD(J) .EQ. PER )  GO TO 700
400   CONTINUE
C
      DO 450 J=72,1,-1
             LAST = J
             IF ( CARD(J) .NE. ' ' )  GO TO 460
450   CONTINUE
460   CONTINUE
C
CC    NOCARD = NOCARD + 1
      WRITE (9,300) (CARD(J), J=1,LAST)
CC500 FORMAT (72A1, I5, 3X)
      GO TO 200
C
600   CONTINUE
C     CALL VARBLE TO PROCESS A CARD WITH A VARIABLE NAME.
      CALL VARBLE (CARD, IPT)
      GO TO 200
C
700   CONTINUE
C     CALL PERCT2 TO PROCESS A CONTROL CARD.
      CALL PERCT2 (CARD, IPT, NFT)
      GO TO 200
C
800   CONTINUE
      CLOSE (NFT, STATUS='KEEP')
      RETURN
      END
      SUBROUTINE LEVEL3 (MEMBER)
C
C
C     PROCESS LEVEL 3 CARDS OF INCLUDED FILE.
C
C
      PARAMETER ( MAXMEM = 40 )
      PARAMETER ( MAXFIL = 72 + MAXMEM )
C
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      MLOWUP(MAXMEM,3)
C
      CHARACTER*1      CARD(72)
      INTEGER          NFT
      DATA             NFT            /13/
      CHARACTER*1      NUM
      DATA             NUM            /'#'/
      CHARACTER*1      PER
      DATA             PER            /'%'/
C
      CHARACTER*112    FILES
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /BPATH/
C     NOPATH - TOTAL NUMBER OF PATHS.
C     LNPATH - LENGTH OF EACH PATH.
C     PATH   - ARRAY OF PATHS.
      COMMON  /BPATH/  NOPATH,
     1                 LNPATH(20),
     2                 PATH(72,20)
      CHARACTER*1      PATH
C
C
C
      DO 105 J=1,MAXMEM
             NSEQ =  ICHAR(MEMBER(J))
             MLOWUP(J,1) = MEMBER(J)
             MLOWUP(J,2) = MEMBER(J)
             MLOWUP(J,3) = MEMBER(J)
C            CHANGE ASCII UPPERCASE LETTERS TO LOWERCASE LETTERS.
             IF ( (NSEQ .GE.  65)  .AND.  (NSEQ .LE.  90) )
     1       MLOWUP(J,1) = CHAR(NSEQ+32)
C            CHANGE ASCII LOWERCASE LETTERS TO UPPERCASE LETTERS.
             IF ( (NSEQ .GE.  97)  .AND.  (NSEQ .LE. 122) )
     1       MLOWUP(J,2) = CHAR(NSEQ-32)
105   CONTINUE
C
      DO 140 K=1,NOPATH
      DO 110 J=1,MAXFIL
             FILES(J:J) = ' '
110   CONTINUE
      DO 120 J=1,LNPATH(K)
             FILES(J:J) = PATH(J,K)
120   CONTINUE
      DO 135 NLU=1,3
      L = LNPATH(K) + 1
      DO 130 J=1,MAXMEM
             FILES(L:L) = MLOWUP(J,NLU)
             L = L + 1
130   CONTINUE
      OPEN (NFT, ERR=135, FILE=FILES, FORM='FORMATTED', STATUS='OLD')
      GO TO 170
135   CONTINUE
140   CONTINUE
      PRINT 150, MLOWUP
150   FORMAT (/ ' ********** ERROR - FILE NOT FOUND FOR % INCLUDE '
     1  / 1X, 40A1 / 1X, 40A1 / 1X, 40A1 )
      PRINT 160
160   FORMAT (/ ' END OF FORTRAN PREPROCESSOR. ')
      STOP 750
170   CONTINUE
C
CMJR
      PRINT 88888, FILES
88888 FORMAT ( A112 )
CMJR
200   CONTINUE
C
      DO 250 J=1,72
             CARD(J) = ' '
250   CONTINUE
      READ (NFT,300,END=800) CARD
300   FORMAT (72A1)
C
      DO 400 J=1,72
             IPT = J
             IF ( CARD(J) .EQ. NUM )  GO TO 600
             IF ( CARD(J) .EQ. PER )  GO TO 700
400   CONTINUE
C
      DO 450 J=72,1,-1
             LAST = J
             IF ( CARD(J) .NE. ' ' )  GO TO 460
450   CONTINUE
460   CONTINUE
C
CC    NOCARD = NOCARD + 1
      WRITE (9,300) (CARD(J), J=1,LAST)
CC500 FORMAT (72A1, I5, 3X)
      GO TO 200
C
600   CONTINUE
C     CALL VARBLE TO PROCESS A CARD WITH A VARIABLE NAME.
      CALL VARBLE (CARD, IPT)
      GO TO 200
C
700   CONTINUE
C     CALL PERCT3 TO PROCESS A CONTROL CARD.
      CALL PERCT3 (CARD, IPT, NFT)
      GO TO 200
C
800   CONTINUE
      CLOSE (NFT, STATUS='KEEP')
      RETURN
      END
      SUBROUTINE LEVEL4 (MEMBER)
C
C
C     PROCESS LEVEL 4 CARDS OF INCLUDED FILE.
C
C
      PARAMETER ( MAXMEM = 40 )
      PARAMETER ( MAXFIL = 72 + MAXMEM )
C
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      MLOWUP(MAXMEM,3)
C
      CHARACTER*1      CARD(72)
      INTEGER          NFT
      DATA             NFT            /14/
      CHARACTER*1      NUM
      DATA             NUM            /'#'/
      CHARACTER*1      PER
      DATA             PER            /'%'/
C
      CHARACTER*112    FILES
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /BPATH/
C     NOPATH - TOTAL NUMBER OF PATHS.
C     LNPATH - LENGTH OF EACH PATH.
C     PATH   - ARRAY OF PATHS.
      COMMON  /BPATH/  NOPATH,
     1                 LNPATH(20),
     2                 PATH(72,20)
      CHARACTER*1      PATH
C
C
C
      DO 105 J=1,MAXMEM
             NSEQ =  ICHAR(MEMBER(J))
             MLOWUP(J,1) = MEMBER(J)
             MLOWUP(J,2) = MEMBER(J)
             MLOWUP(J,3) = MEMBER(J)
C            CHANGE ASCII UPPERCASE LETTERS TO LOWERCASE LETTERS.
             IF ( (NSEQ .GE.  65)  .AND.  (NSEQ .LE.  90) )
     1       MLOWUP(J,1) = CHAR(NSEQ+32)
C            CHANGE ASCII LOWERCASE LETTERS TO UPPERCASE LETTERS.
             IF ( (NSEQ .GE.  97)  .AND.  (NSEQ .LE. 122) )
     1       MLOWUP(J,2) = CHAR(NSEQ-32)
105   CONTINUE
C
      DO 140 K=1,NOPATH
      DO 110 J=1,MAXFIL
             FILES(J:J) = ' '
110   CONTINUE
      DO 120 J=1,LNPATH(K)
             FILES(J:J) = PATH(J,K)
120   CONTINUE
      DO 135 NLU=1,3
      L = LNPATH(K) + 1
      DO 130 J=1,MAXMEM
             FILES(L:L) = MLOWUP(J,NLU)
             L = L + 1
130   CONTINUE
      OPEN (NFT, ERR=135, FILE=FILES, FORM='FORMATTED', STATUS='OLD')
      GO TO 170
135   CONTINUE
140   CONTINUE
      PRINT 150, MLOWUP
150   FORMAT (/ ' ********** ERROR - FILE NOT FOUND FOR % INCLUDE '
     1  / 1X, 40A1 / 1X, 40A1 / 1X, 40A1 )
      PRINT 160
160   FORMAT (/ ' END OF FORTRAN PREPROCESSOR. ')
      STOP 750
170   CONTINUE
C
CMJR
      PRINT 88888, FILES
88888 FORMAT ( A112 )
CMJR
200   CONTINUE
C
      DO 250 J=1,72
             CARD(J) = ' '
250   CONTINUE
      READ (NFT,300,END=800) CARD
300   FORMAT (72A1)
C
      DO 400 J=1,72
             IPT = J
             IF ( CARD(J) .EQ. NUM )  GO TO 600
             IF ( CARD(J) .EQ. PER )  GO TO 700
400   CONTINUE
C
      DO 450 J=72,1,-1
             LAST = J
             IF ( CARD(J) .NE. ' ' )  GO TO 460
450   CONTINUE
460   CONTINUE
C
CC    NOCARD = NOCARD + 1
      WRITE (9,300) (CARD(J), J=1,LAST)
CC500 FORMAT (72A1, I5, 3X)
      GO TO 200
C
600   CONTINUE
C     CALL VARBLE TO PROCESS A CARD WITH A VARIABLE NAME.
      CALL VARBLE (CARD, IPT)
      GO TO 200
C
700   CONTINUE
C     CALL PERCT4 TO PROCESS A CONTROL CARD.
      CALL PERCT4 (CARD, IPT, NFT)
      GO TO 200
C
800   CONTINUE
      CLOSE (NFT, STATUS='KEEP')
      RETURN
      END
      SUBROUTINE LEVEL5 (MEMBER)
C
C
C     PROCESS LEVEL 5 CARDS OF INCLUDED FILE.
C
C
      PARAMETER ( MAXMEM = 40 )
      PARAMETER ( MAXFIL = 72 + MAXMEM )
C
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      MLOWUP(MAXMEM,3)
C
      CHARACTER*1      CARD(72)
      INTEGER          NFT
      DATA             NFT            /15/
      CHARACTER*1      NUM
      DATA             NUM            /'#'/
      CHARACTER*1      PER
      DATA             PER            /'%'/
C
      CHARACTER*112    FILES
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /BPATH/
C     NOPATH - TOTAL NUMBER OF PATHS.
C     LNPATH - LENGTH OF EACH PATH.
C     PATH   - ARRAY OF PATHS.
      COMMON  /BPATH/  NOPATH,
     1                 LNPATH(20),
     2                 PATH(72,20)
      CHARACTER*1      PATH
C
C
C
      DO 105 J=1,MAXMEM
             NSEQ =  ICHAR(MEMBER(J))
             MLOWUP(J,1) = MEMBER(J)
             MLOWUP(J,2) = MEMBER(J)
             MLOWUP(J,3) = MEMBER(J)
C            CHANGE ASCII UPPERCASE LETTERS TO LOWERCASE LETTERS.
             IF ( (NSEQ .GE.  65)  .AND.  (NSEQ .LE.  90) )
     1       MLOWUP(J,1) = CHAR(NSEQ+32)
C            CHANGE ASCII LOWERCASE LETTERS TO UPPERCASE LETTERS.
             IF ( (NSEQ .GE.  97)  .AND.  (NSEQ .LE. 122) )
     1       MLOWUP(J,2) = CHAR(NSEQ-32)
105   CONTINUE
C
      DO 140 K=1,NOPATH
      DO 110 J=1,MAXFIL
             FILES(J:J) = ' '
110   CONTINUE
      DO 120 J=1,LNPATH(K)
             FILES(J:J) = PATH(J,K)
120   CONTINUE
      DO 135 NLU=1,3
      L = LNPATH(K) + 1
      DO 130 J=1,MAXMEM
             FILES(L:L) = MLOWUP(J,NLU)
             L = L + 1
130   CONTINUE
      OPEN (NFT, ERR=135, FILE=FILES, FORM='FORMATTED', STATUS='OLD')
      GO TO 170
135   CONTINUE
140   CONTINUE
      PRINT 150, MLOWUP
150   FORMAT (/ ' ********** ERROR - FILE NOT FOUND FOR % INCLUDE '
     1  / 1X, 40A1 / 1X, 40A1 / 1X, 40A1 )
      PRINT 160
160   FORMAT (/ ' END OF FORTRAN PREPROCESSOR. ')
      STOP 750
170   CONTINUE
C
CMJR
      PRINT 88888, FILES
88888 FORMAT ( A112 )
CMJR
200   CONTINUE
C
      DO 250 J=1,72
             CARD(J) = ' '
250   CONTINUE
      READ (NFT,300,END=800) CARD
300   FORMAT (72A1)
C
      DO 400 J=1,72
             IPT = J
             IF ( CARD(J) .EQ. NUM )  GO TO 600
             IF ( CARD(J) .EQ. PER )  GO TO 700
400   CONTINUE
C
      DO 450 J=72,1,-1
             LAST = J
             IF ( CARD(J) .NE. ' ' )  GO TO 460
450   CONTINUE
460   CONTINUE
C
CC    NOCARD = NOCARD + 1
      WRITE (9,300) (CARD(J), J=1,LAST)
CC500 FORMAT (72A1, I5, 3X)
      GO TO 200
C
600   CONTINUE
C     CALL VARBLE TO PROCESS A CARD WITH A VARIABLE NAME.
      CALL VARBLE (CARD, IPT)
      GO TO 200
C
700   CONTINUE
C     CALL PERCT5 TO PROCESS A CONTROL CARD.
      CALL PERCT5 (CARD, IPT, NFT)
      GO TO 200
C
800   CONTINUE
      CLOSE (NFT, STATUS='KEEP')
      RETURN
      END
      SUBROUTINE LEVEL6 (MEMBER)
C
C
C     PROCESS LEVEL 6 CARDS OF INCLUDED FILE.
C
C
      PARAMETER ( MAXMEM = 40 )
C
      CHARACTER*1      MEMBER(MAXMEM)
C
C     TOO MANY LEVELS OF INCLUDED FILES.
C
      PRINT 940, MEMBER
940   FORMAT (/ ' ********** TOO MANY NESTED LEVELS'
     1        / ' FOR INCLUDED FILE ', 40A1)
C
      STOP 789
      END
      SUBROUTINE PERCT1 (CARD, IPT, NFT)
C
C     SUBROUTINE PERCT1 PROCESSES LEVEL 1 CONTROL CARDS.
C
      PARAMETER ( MAXMEM = 40 )
C
      CHARACTER*1      CARD(72)
      CHARACTER*1      PER
      DATA             PER           /'%'/
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      BLANK
      DATA             BLANK         /' '/
      CHARACTER*1      SEMICL
      DATA             SEMICL        /';'/
      CHARACTER*1      NUM
      DATA             NUM           /'#'/
      CHARACTER*1      EQUAL
      DATA             EQUAL         /'='/
      CHARACTER*1      QUOTE
      DATA             QUOTE         /''''/
      CHARACTER*1      TSTVAR(8)
      INTEGER          TNOLEN
      INTEGER          VARNO
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C              E.G., NOLEN(5) IS THE NUMBER OF VARIABLE NAMES
C              OF LENGTH 5.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /EXTRA/
C     WHEN LREPVR=0, # VARIABLES ARE NOT REPLACED WITH VALUES.
C     WHEN LREPVR=1, # VARIABLES ARE     REPLACED WITH VALUES.
C     NOVREP - NUMBER OF # SIGNS     NOT REPLACED WITH VALUES;
C            - WHEN LREPVR=1.
C     NOVNEW - NUMBER OF # VARIABLES THAT MAY NOT BE INITIALIZED;
C            - WHEN LREPVR=1.
C     LTABLE - TABLE FOR CHARACTERS (UPPER AND LOWER CASE LETTERS,
C            - NUMBERS) TO BE DETECTED.
C     ILOWER, IUPPER - LOWER AND UPPER CASE 'I'.
C     NLOWER, NUPPER - LOWER AND UPPER CASE 'N'.
C     CLOWER, CUPPER - LOWER AND UPPER CASE 'C'.
C     LLOWER, LUPPER - LOWER AND UPPER CASE 'L'.
C     ULOWER, UUPPER - LOWER AND UPPER CASE 'U'.
C     DLOWER, DUPPER - LOWER AND UPPER CASE 'D'.
C     ELOWER, EUPPER - LOWER AND UPPER CASE 'E'.
      COMMON  /EXTRA/  LREPVR,
     1                 NOVREP,
     2                 NOVNEW,
     3                 LTABLE(256),
     4                 ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
      CHARACTER*1      ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
C
C
C
100   CONTINUE
C
      IF (CARD(IPT).NE.PER)  THEN
         PRINT 150, CARD
150      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING % CONTROL STATEMENT. '
     2           / ' TESTED CHARACTER IS NOT PERCENT SIGN. '
     3           / 1X, 72A1)
         STOP 260
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      ITEST = IPT + 2
      IF (ITEST.GT.72)  GO TO 200
C
      IF ( (CARD(IPT  ).EQ.DUPPER) .OR. (CARD(IPT  ).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+1).EQ.CUPPER) .OR. (CARD(IPT+1).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+2).EQ.LUPPER) .OR. (CARD(IPT+2).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
C
C     MOVE POINTER IPT TO 'L' OF 'DCL'.
      IPT = IPT + 2
C
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL MOVESC (CARD, IPT, NFT)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
200   CONTINUE
C
      ITEST = IPT + 6
      IF (ITEST.GT.72)  GO TO 300
C
      IF ( (CARD(IPT  ).EQ.IUPPER) .OR. (CARD(IPT  ).EQ.ILOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+1).EQ.NUPPER) .OR. (CARD(IPT+1).EQ.NLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+2).EQ.CUPPER) .OR. (CARD(IPT+2).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+3).EQ.LUPPER) .OR. (CARD(IPT+3).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+4).EQ.UUPPER) .OR. (CARD(IPT+4).EQ.ULOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+5).EQ.DUPPER) .OR. (CARD(IPT+5).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+6).EQ.EUPPER) .OR. (CARD(IPT+6).EQ.ELOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
C
C     MOVE POINTER IPT TO 'E' OF 'INCLUDE'.
      IPT = IPT + 6
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
C     POINTER IPT SHOULD BE AT FIRST CHARACTER OF MEMBER NAME.
C
C     FIND LENGTH OF MEMBER NAME.
      CALL FINDLM (CARD, IPT, LENGTH)
C
C     SET MEMBER ARRAY TO MEMBER NAME.
      DO 240 II=1,MAXMEM
            MEMBER(II) = BLANK
240   CONTINUE
      JJ = IPT
      DO 250 II=1,LENGTH
            MEMBER(II) = CARD(JJ)
            JJ = JJ + 1
250   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF MEMBER NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 270, CARD
270      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING   % INCLUDE FILENAME ; '
     2           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     3           / 1X, 72A1)
         STOP 300
      ENDIF
C
C     CALL LEVEL2 TO PROCESS LEVEL 2 CARDS OF INCLUDED MEMBER.
      CALL LEVEL2 (MEMBER)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
300   CONTINUE
C
      IF (CARD(IPT).NE.NUM)  THEN
         PRINT 320, CARD
320      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT #. '
     4           / 1X, 72A1)
         STOP 320
      ENDIF
C
C     FIND LENGTH OF VARIABLE NAME.
      CALL FINDLV (CARD, IPT, LENGTH)
C
C     HAS VARIABLE NAME BEEN USED BEFORE?
C
C     COPY VARIABLE NAME TO TSTVAR ARRAY.
      JJ = IPT
      DO 350 II=1,LENGTH
            TSTVAR(II) = CARD(JJ)
            JJ = JJ + 1
350   CONTINUE
C
      TNOLEN = NOLEN(LENGTH)
      IF (TNOLEN.EQ.0)  GO TO 500
C
      NFOUND = 0
C
      DO 450 NN=1,NOVAR
            VARNO = NN
            IF (LENNAM(VARNO).NE.LENGTH)  GO TO 450
            NFOUND = NFOUND + 1
C
                  DO 400 II=1,LENGTH
                        IF (VARNAM(II,VARNO).NE.TSTVAR(II))  GO TO 430
400               CONTINUE
C
C           VARIABLE NAME HAS BEEN FOUND AT VARIABLE NUMBER VARNO.
            INITRE = 1
            GO TO 650
C
430         CONTINUE
C
            IF (NFOUND.EQ.TNOLEN)  GO TO 500
C
450   CONTINUE
C
C     PROCESS NEW VARIABLE NAME.
500   CONTINUE
      INITRE = 0
C
      NOVAR = NOVAR + 1
      IF (NOVAR.GT.500)  THEN
         PRINT 550, CARD
550      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' MORE THAN 500 DIFFERENT',
     4             ' PREPROCESSOR VARIABLES #VARNAME. '
     5           / 1X, 72A1)
         STOP 500
      ENDIF
      VARNO = NOVAR
      NOLEN(LENGTH) = NOLEN(LENGTH) + 1
      LENNAM(VARNO) = LENGTH
C
      JJ = IPT
      DO 600 II=1,LENGTH
            VARNAM(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
600   CONTINUE
C
650   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.EQUAL)  THEN
         PRINT 670, CARD
670      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT EQUAL SIGN. '
     4           / 1X, 72A1)
         STOP 360
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  GO TO 750
C
C     MOVE POINTER IPT TO FIRST CHARACTER OF
C     STRING OF CHARACTERS BETWEEN QUOTES,
C     I.E., VARIABLE VALUE.
      IPT = IPT + 1
C
C     FIND LENGTH OF STRING OF CHARACTERS BETWEEN QUOTES.
      CALL FINDLQ (CARD, IPT, LENGTH)
C
C     PROCESS VARIABLE VALUE.
C
      LENVAL(VARNO) = LENGTH
C
      JJ = IPT
      DO 700 II=1,LENGTH
            VARVAL(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
700   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE VALUE.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  THEN
         PRINT 720, CARD
720      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = ''VALUE'' ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT THE SECOND QUOTE. '
     4           / 1X, 72A1)
         STOP 400
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      GO TO 900
C
C     PROCESS FORMULA.
750   CONTINUE
C
C     STORE FORMULA AND
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL SETFR (CARD, IPT, NFT)
C
C     EVALUATE FORMULA AND
C     SET VARIABLE VALUE LENGTH AND VARIABLE VALUE.
      CALL SETVAR (VARNO)
C
900   CONTINUE
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 920, CARD
920      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     4           / 1X, 72A1)
         STOP 420
      ENDIF
C
      IF ( INITRE .EQ. 0 )  PRINT 930,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
      IF ( INITRE .EQ. 1 )  PRINT 940,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
930   FORMAT ('fortprep variable   initialized   ', 9A1, '= ''', 20A1)
940   FORMAT ('fortprep variable reinitialized   ', 9A1, '= ''', 20A1)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
      END
      SUBROUTINE PERCT2 (CARD, IPT, NFT)
C
C     SUBROUTINE PERCT2 PROCESSES LEVEL 2 CONTROL CARDS.
C
      PARAMETER ( MAXMEM = 40 )
C
      CHARACTER*1      CARD(72)
      CHARACTER*1      PER
      DATA             PER           /'%'/
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      BLANK
      DATA             BLANK         /' '/
      CHARACTER*1      SEMICL
      DATA             SEMICL        /';'/
      CHARACTER*1      NUM
      DATA             NUM           /'#'/
      CHARACTER*1      EQUAL
      DATA             EQUAL         /'='/
      CHARACTER*1      QUOTE
      DATA             QUOTE         /''''/
      CHARACTER*1      TSTVAR(8)
      INTEGER          TNOLEN
      INTEGER          VARNO
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C              E.G., NOLEN(5) IS THE NUMBER OF VARIABLE NAMES
C              OF LENGTH 5.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /EXTRA/
C     WHEN LREPVR=0, # VARIABLES ARE NOT REPLACED WITH VALUES.
C     WHEN LREPVR=1, # VARIABLES ARE     REPLACED WITH VALUES.
C     NOVREP - NUMBER OF # SIGNS     NOT REPLACED WITH VALUES;
C            - WHEN LREPVR=1.
C     NOVNEW - NUMBER OF # VARIABLES THAT MAY NOT BE INITIALIZED;
C            - WHEN LREPVR=1.
C     LTABLE - TABLE FOR CHARACTERS (UPPER AND LOWER CASE LETTERS,
C            - NUMBERS) TO BE DETECTED.
C     ILOWER, IUPPER - LOWER AND UPPER CASE 'I'.
C     NLOWER, NUPPER - LOWER AND UPPER CASE 'N'.
C     CLOWER, CUPPER - LOWER AND UPPER CASE 'C'.
C     LLOWER, LUPPER - LOWER AND UPPER CASE 'L'.
C     ULOWER, UUPPER - LOWER AND UPPER CASE 'U'.
C     DLOWER, DUPPER - LOWER AND UPPER CASE 'D'.
C     ELOWER, EUPPER - LOWER AND UPPER CASE 'E'.
      COMMON  /EXTRA/  LREPVR,
     1                 NOVREP,
     2                 NOVNEW,
     3                 LTABLE(256),
     4                 ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
      CHARACTER*1      ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
C
C
C
100   CONTINUE
C
      IF (CARD(IPT).NE.PER)  THEN
         PRINT 150, CARD
150      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING % CONTROL STATEMENT. '
     2           / ' TESTED CHARACTER IS NOT PERCENT SIGN. '
     3           / 1X, 72A1)
         STOP 260
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      ITEST = IPT + 2
      IF (ITEST.GT.72)  GO TO 200
C
      IF ( (CARD(IPT  ).EQ.DUPPER) .OR. (CARD(IPT  ).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+1).EQ.CUPPER) .OR. (CARD(IPT+1).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+2).EQ.LUPPER) .OR. (CARD(IPT+2).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
C
C     MOVE POINTER IPT TO 'L' OF 'DCL'.
      IPT = IPT + 2
C
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL MOVESC (CARD, IPT, NFT)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
200   CONTINUE
C
      ITEST = IPT + 6
      IF (ITEST.GT.72)  GO TO 300
C
      IF ( (CARD(IPT  ).EQ.IUPPER) .OR. (CARD(IPT  ).EQ.ILOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+1).EQ.NUPPER) .OR. (CARD(IPT+1).EQ.NLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+2).EQ.CUPPER) .OR. (CARD(IPT+2).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+3).EQ.LUPPER) .OR. (CARD(IPT+3).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+4).EQ.UUPPER) .OR. (CARD(IPT+4).EQ.ULOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+5).EQ.DUPPER) .OR. (CARD(IPT+5).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+6).EQ.EUPPER) .OR. (CARD(IPT+6).EQ.ELOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
C
C     MOVE POINTER IPT TO 'E' OF 'INCLUDE'.
      IPT = IPT + 6
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
C     POINTER IPT SHOULD BE AT FIRST CHARACTER OF MEMBER NAME.
C
C     FIND LENGTH OF MEMBER NAME.
      CALL FINDLM (CARD, IPT, LENGTH)
C
C     SET MEMBER ARRAY TO MEMBER NAME.
      DO 240 II=1,MAXMEM
            MEMBER(II) = BLANK
240   CONTINUE
      JJ = IPT
      DO 250 II=1,LENGTH
            MEMBER(II) = CARD(JJ)
            JJ = JJ + 1
250   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF MEMBER NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 270, CARD
270      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING   % INCLUDE FILENAME ; '
     2           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     3           / 1X, 72A1)
         STOP 300
      ENDIF
C
C     CALL LEVEL3 TO PROCESS LEVEL 3 CARDS OF INCLUDED MEMBER.
      CALL LEVEL3 (MEMBER)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
300   CONTINUE
C
      IF (CARD(IPT).NE.NUM)  THEN
         PRINT 320, CARD
320      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT #. '
     4           / 1X, 72A1)
         STOP 320
      ENDIF
C
C     FIND LENGTH OF VARIABLE NAME.
      CALL FINDLV (CARD, IPT, LENGTH)
C
C     HAS VARIABLE NAME BEEN USED BEFORE?
C
C     COPY VARIABLE NAME TO TSTVAR ARRAY.
      JJ = IPT
      DO 350 II=1,LENGTH
            TSTVAR(II) = CARD(JJ)
            JJ = JJ + 1
350   CONTINUE
C
      TNOLEN = NOLEN(LENGTH)
      IF (TNOLEN.EQ.0)  GO TO 500
C
      NFOUND = 0
C
      DO 450 NN=1,NOVAR
            VARNO = NN
            IF (LENNAM(VARNO).NE.LENGTH)  GO TO 450
            NFOUND = NFOUND + 1
C
                  DO 400 II=1,LENGTH
                        IF (VARNAM(II,VARNO).NE.TSTVAR(II))  GO TO 430
400               CONTINUE
C
C           VARIABLE NAME HAS BEEN FOUND AT VARIABLE NUMBER VARNO.
            INITRE = 1
            GO TO 650
C
430         CONTINUE
C
            IF (NFOUND.EQ.TNOLEN)  GO TO 500
C
450   CONTINUE
C
C     PROCESS NEW VARIABLE NAME.
500   CONTINUE
      INITRE = 0
C
      NOVAR = NOVAR + 1
      IF (NOVAR.GT.500)  THEN
         PRINT 550, CARD
550      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' MORE THAN 500 DIFFERENT',
     4             ' PREPROCESSOR VARIABLES #VARNAME. '
     5           / 1X, 72A1)
         STOP 500
      ENDIF
      VARNO = NOVAR
      NOLEN(LENGTH) = NOLEN(LENGTH) + 1
      LENNAM(VARNO) = LENGTH
C
      JJ = IPT
      DO 600 II=1,LENGTH
            VARNAM(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
600   CONTINUE
C
650   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.EQUAL)  THEN
         PRINT 670, CARD
670      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT EQUAL SIGN. '
     4           / 1X, 72A1)
         STOP 360
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  GO TO 750
C
C     MOVE POINTER IPT TO FIRST CHARACTER OF
C     STRING OF CHARACTERS BETWEEN QUOTES,
C     I.E., VARIABLE VALUE.
      IPT = IPT + 1
C
C     FIND LENGTH OF STRING OF CHARACTERS BETWEEN QUOTES.
      CALL FINDLQ (CARD, IPT, LENGTH)
C
C     PROCESS VARIABLE VALUE.
C
      LENVAL(VARNO) = LENGTH
C
      JJ = IPT
      DO 700 II=1,LENGTH
            VARVAL(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
700   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE VALUE.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  THEN
         PRINT 720, CARD
720      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = ''VALUE'' ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT THE SECOND QUOTE. '
     4           / 1X, 72A1)
         STOP 400
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      GO TO 900
C
C     PROCESS FORMULA.
750   CONTINUE
C
C     STORE FORMULA AND
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL SETFR (CARD, IPT, NFT)
C
C     EVALUATE FORMULA AND
C     SET VARIABLE VALUE LENGTH AND VARIABLE VALUE.
      CALL SETVAR (VARNO)
C
900   CONTINUE
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 920, CARD
920      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     4           / 1X, 72A1)
         STOP 420
      ENDIF
C
      IF ( INITRE .EQ. 0 )  PRINT 930,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
      IF ( INITRE .EQ. 1 )  PRINT 940,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
930   FORMAT ('fortprep variable   initialized   ', 9A1, '= ''', 20A1)
940   FORMAT ('fortprep variable reinitialized   ', 9A1, '= ''', 20A1)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
      END
      SUBROUTINE PERCT3 (CARD, IPT, NFT)
C
C     SUBROUTINE PERCT3 PROCESSES LEVEL 3 CONTROL CARDS.
C
      PARAMETER ( MAXMEM = 40 )
C
      CHARACTER*1      CARD(72)
      CHARACTER*1      PER
      DATA             PER           /'%'/
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      BLANK
      DATA             BLANK         /' '/
      CHARACTER*1      SEMICL
      DATA             SEMICL        /';'/
      CHARACTER*1      NUM
      DATA             NUM           /'#'/
      CHARACTER*1      EQUAL
      DATA             EQUAL         /'='/
      CHARACTER*1      QUOTE
      DATA             QUOTE         /''''/
      CHARACTER*1      TSTVAR(8)
      INTEGER          TNOLEN
      INTEGER          VARNO
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C              E.G., NOLEN(5) IS THE NUMBER OF VARIABLE NAMES
C              OF LENGTH 5.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /EXTRA/
C     WHEN LREPVR=0, # VARIABLES ARE NOT REPLACED WITH VALUES.
C     WHEN LREPVR=1, # VARIABLES ARE     REPLACED WITH VALUES.
C     NOVREP - NUMBER OF # SIGNS     NOT REPLACED WITH VALUES;
C            - WHEN LREPVR=1.
C     NOVNEW - NUMBER OF # VARIABLES THAT MAY NOT BE INITIALIZED;
C            - WHEN LREPVR=1.
C     LTABLE - TABLE FOR CHARACTERS (UPPER AND LOWER CASE LETTERS,
C            - NUMBERS) TO BE DETECTED.
C     ILOWER, IUPPER - LOWER AND UPPER CASE 'I'.
C     NLOWER, NUPPER - LOWER AND UPPER CASE 'N'.
C     CLOWER, CUPPER - LOWER AND UPPER CASE 'C'.
C     LLOWER, LUPPER - LOWER AND UPPER CASE 'L'.
C     ULOWER, UUPPER - LOWER AND UPPER CASE 'U'.
C     DLOWER, DUPPER - LOWER AND UPPER CASE 'D'.
C     ELOWER, EUPPER - LOWER AND UPPER CASE 'E'.
      COMMON  /EXTRA/  LREPVR,
     1                 NOVREP,
     2                 NOVNEW,
     3                 LTABLE(256),
     4                 ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
      CHARACTER*1      ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
C
C
C
100   CONTINUE
C
      IF (CARD(IPT).NE.PER)  THEN
         PRINT 150, CARD
150      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING % CONTROL STATEMENT. '
     2           / ' TESTED CHARACTER IS NOT PERCENT SIGN. '
     3           / 1X, 72A1)
         STOP 260
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      ITEST = IPT + 2
      IF (ITEST.GT.72)  GO TO 200
C
      IF ( (CARD(IPT  ).EQ.DUPPER) .OR. (CARD(IPT  ).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+1).EQ.CUPPER) .OR. (CARD(IPT+1).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+2).EQ.LUPPER) .OR. (CARD(IPT+2).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
C
C     MOVE POINTER IPT TO 'L' OF 'DCL'.
      IPT = IPT + 2
C
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL MOVESC (CARD, IPT, NFT)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
200   CONTINUE
C
      ITEST = IPT + 6
      IF (ITEST.GT.72)  GO TO 300
C
      IF ( (CARD(IPT  ).EQ.IUPPER) .OR. (CARD(IPT  ).EQ.ILOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+1).EQ.NUPPER) .OR. (CARD(IPT+1).EQ.NLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+2).EQ.CUPPER) .OR. (CARD(IPT+2).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+3).EQ.LUPPER) .OR. (CARD(IPT+3).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+4).EQ.UUPPER) .OR. (CARD(IPT+4).EQ.ULOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+5).EQ.DUPPER) .OR. (CARD(IPT+5).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+6).EQ.EUPPER) .OR. (CARD(IPT+6).EQ.ELOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
C
C     MOVE POINTER IPT TO 'E' OF 'INCLUDE'.
      IPT = IPT + 6
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
C     POINTER IPT SHOULD BE AT FIRST CHARACTER OF MEMBER NAME.
C
C     FIND LENGTH OF MEMBER NAME.
      CALL FINDLM (CARD, IPT, LENGTH)
C
C     SET MEMBER ARRAY TO MEMBER NAME.
      DO 240 II=1,MAXMEM
            MEMBER(II) = BLANK
240   CONTINUE
      JJ = IPT
      DO 250 II=1,LENGTH
            MEMBER(II) = CARD(JJ)
            JJ = JJ + 1
250   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF MEMBER NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 270, CARD
270      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING   % INCLUDE FILENAME ; '
     2           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     3           / 1X, 72A1)
         STOP 300
      ENDIF
C
C     CALL LEVEL4 TO PROCESS LEVEL 4 CARDS OF INCLUDED MEMBER.
      CALL LEVEL4 (MEMBER)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
300   CONTINUE
C
      IF (CARD(IPT).NE.NUM)  THEN
         PRINT 320, CARD
320      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT #. '
     4           / 1X, 72A1)
         STOP 320
      ENDIF
C
C     FIND LENGTH OF VARIABLE NAME.
      CALL FINDLV (CARD, IPT, LENGTH)
C
C     HAS VARIABLE NAME BEEN USED BEFORE?
C
C     COPY VARIABLE NAME TO TSTVAR ARRAY.
      JJ = IPT
      DO 350 II=1,LENGTH
            TSTVAR(II) = CARD(JJ)
            JJ = JJ + 1
350   CONTINUE
C
      TNOLEN = NOLEN(LENGTH)
      IF (TNOLEN.EQ.0)  GO TO 500
C
      NFOUND = 0
C
      DO 450 NN=1,NOVAR
            VARNO = NN
            IF (LENNAM(VARNO).NE.LENGTH)  GO TO 450
            NFOUND = NFOUND + 1
C
                  DO 400 II=1,LENGTH
                        IF (VARNAM(II,VARNO).NE.TSTVAR(II))  GO TO 430
400               CONTINUE
C
C           VARIABLE NAME HAS BEEN FOUND AT VARIABLE NUMBER VARNO.
            INITRE = 1
            GO TO 650
C
430         CONTINUE
C
            IF (NFOUND.EQ.TNOLEN)  GO TO 500
C
450   CONTINUE
C
C     PROCESS NEW VARIABLE NAME.
500   CONTINUE
      INITRE = 0
C
      NOVAR = NOVAR + 1
      IF (NOVAR.GT.500)  THEN
         PRINT 550, CARD
550      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' MORE THAN 500 DIFFERENT',
     4             ' PREPROCESSOR VARIABLES #VARNAME. '
     5           / 1X, 72A1)
         STOP 500
      ENDIF
      VARNO = NOVAR
      NOLEN(LENGTH) = NOLEN(LENGTH) + 1
      LENNAM(VARNO) = LENGTH
C
      JJ = IPT
      DO 600 II=1,LENGTH
            VARNAM(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
600   CONTINUE
C
650   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.EQUAL)  THEN
         PRINT 670, CARD
670      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT EQUAL SIGN. '
     4           / 1X, 72A1)
         STOP 360
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  GO TO 750
C
C     MOVE POINTER IPT TO FIRST CHARACTER OF
C     STRING OF CHARACTERS BETWEEN QUOTES,
C     I.E., VARIABLE VALUE.
      IPT = IPT + 1
C
C     FIND LENGTH OF STRING OF CHARACTERS BETWEEN QUOTES.
      CALL FINDLQ (CARD, IPT, LENGTH)
C
C     PROCESS VARIABLE VALUE.
C
      LENVAL(VARNO) = LENGTH
C
      JJ = IPT
      DO 700 II=1,LENGTH
            VARVAL(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
700   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE VALUE.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  THEN
         PRINT 720, CARD
720      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = ''VALUE'' ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT THE SECOND QUOTE. '
     4           / 1X, 72A1)
         STOP 400
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      GO TO 900
C
C     PROCESS FORMULA.
750   CONTINUE
C
C     STORE FORMULA AND
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL SETFR (CARD, IPT, NFT)
C
C     EVALUATE FORMULA AND
C     SET VARIABLE VALUE LENGTH AND VARIABLE VALUE.
      CALL SETVAR (VARNO)
C
900   CONTINUE
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 920, CARD
920      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     4           / 1X, 72A1)
         STOP 420
      ENDIF
C
      IF ( INITRE .EQ. 0 )  PRINT 930,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
      IF ( INITRE .EQ. 1 )  PRINT 940,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
930   FORMAT ('fortprep variable   initialized   ', 9A1, '= ''', 20A1)
940   FORMAT ('fortprep variable reinitialized   ', 9A1, '= ''', 20A1)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
      END
      SUBROUTINE PERCT4 (CARD, IPT, NFT)
C
C     SUBROUTINE PERCT4 PROCESSES LEVEL 4 CONTROL CARDS.
C
      PARAMETER ( MAXMEM = 40 )
C
      CHARACTER*1      CARD(72)
      CHARACTER*1      PER
      DATA             PER           /'%'/
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      BLANK
      DATA             BLANK         /' '/
      CHARACTER*1      SEMICL
      DATA             SEMICL        /';'/
      CHARACTER*1      NUM
      DATA             NUM           /'#'/
      CHARACTER*1      EQUAL
      DATA             EQUAL         /'='/
      CHARACTER*1      QUOTE
      DATA             QUOTE         /''''/
      CHARACTER*1      TSTVAR(8)
      INTEGER          TNOLEN
      INTEGER          VARNO
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C              E.G., NOLEN(5) IS THE NUMBER OF VARIABLE NAMES
C              OF LENGTH 5.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /EXTRA/
C     WHEN LREPVR=0, # VARIABLES ARE NOT REPLACED WITH VALUES.
C     WHEN LREPVR=1, # VARIABLES ARE     REPLACED WITH VALUES.
C     NOVREP - NUMBER OF # SIGNS     NOT REPLACED WITH VALUES;
C            - WHEN LREPVR=1.
C     NOVNEW - NUMBER OF # VARIABLES THAT MAY NOT BE INITIALIZED;
C            - WHEN LREPVR=1.
C     LTABLE - TABLE FOR CHARACTERS (UPPER AND LOWER CASE LETTERS,
C            - NUMBERS) TO BE DETECTED.
C     ILOWER, IUPPER - LOWER AND UPPER CASE 'I'.
C     NLOWER, NUPPER - LOWER AND UPPER CASE 'N'.
C     CLOWER, CUPPER - LOWER AND UPPER CASE 'C'.
C     LLOWER, LUPPER - LOWER AND UPPER CASE 'L'.
C     ULOWER, UUPPER - LOWER AND UPPER CASE 'U'.
C     DLOWER, DUPPER - LOWER AND UPPER CASE 'D'.
C     ELOWER, EUPPER - LOWER AND UPPER CASE 'E'.
      COMMON  /EXTRA/  LREPVR,
     1                 NOVREP,
     2                 NOVNEW,
     3                 LTABLE(256),
     4                 ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
      CHARACTER*1      ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
C
C
C
100   CONTINUE
C
      IF (CARD(IPT).NE.PER)  THEN
         PRINT 150, CARD
150      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING % CONTROL STATEMENT. '
     2           / ' TESTED CHARACTER IS NOT PERCENT SIGN. '
     3           / 1X, 72A1)
         STOP 260
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      ITEST = IPT + 2
      IF (ITEST.GT.72)  GO TO 200
C
      IF ( (CARD(IPT  ).EQ.DUPPER) .OR. (CARD(IPT  ).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+1).EQ.CUPPER) .OR. (CARD(IPT+1).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+2).EQ.LUPPER) .OR. (CARD(IPT+2).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
C
C     MOVE POINTER IPT TO 'L' OF 'DCL'.
      IPT = IPT + 2
C
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL MOVESC (CARD, IPT, NFT)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
200   CONTINUE
C
      ITEST = IPT + 6
      IF (ITEST.GT.72)  GO TO 300
C
      IF ( (CARD(IPT  ).EQ.IUPPER) .OR. (CARD(IPT  ).EQ.ILOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+1).EQ.NUPPER) .OR. (CARD(IPT+1).EQ.NLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+2).EQ.CUPPER) .OR. (CARD(IPT+2).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+3).EQ.LUPPER) .OR. (CARD(IPT+3).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+4).EQ.UUPPER) .OR. (CARD(IPT+4).EQ.ULOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+5).EQ.DUPPER) .OR. (CARD(IPT+5).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+6).EQ.EUPPER) .OR. (CARD(IPT+6).EQ.ELOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
C
C     MOVE POINTER IPT TO 'E' OF 'INCLUDE'.
      IPT = IPT + 6
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
C     POINTER IPT SHOULD BE AT FIRST CHARACTER OF MEMBER NAME.
C
C     FIND LENGTH OF MEMBER NAME.
      CALL FINDLM (CARD, IPT, LENGTH)
C
C     SET MEMBER ARRAY TO MEMBER NAME.
      DO 240 II=1,MAXMEM
            MEMBER(II) = BLANK
240   CONTINUE
      JJ = IPT
      DO 250 II=1,LENGTH
            MEMBER(II) = CARD(JJ)
            JJ = JJ + 1
250   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF MEMBER NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 270, CARD
270      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING   % INCLUDE FILENAME ; '
     2           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     3           / 1X, 72A1)
         STOP 300
      ENDIF
C
C     CALL LEVEL5 TO PROCESS LEVEL 5 CARDS OF INCLUDED MEMBER.
      CALL LEVEL5 (MEMBER)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
300   CONTINUE
C
      IF (CARD(IPT).NE.NUM)  THEN
         PRINT 320, CARD
320      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT #. '
     4           / 1X, 72A1)
         STOP 320
      ENDIF
C
C     FIND LENGTH OF VARIABLE NAME.
      CALL FINDLV (CARD, IPT, LENGTH)
C
C     HAS VARIABLE NAME BEEN USED BEFORE?
C
C     COPY VARIABLE NAME TO TSTVAR ARRAY.
      JJ = IPT
      DO 350 II=1,LENGTH
            TSTVAR(II) = CARD(JJ)
            JJ = JJ + 1
350   CONTINUE
C
      TNOLEN = NOLEN(LENGTH)
      IF (TNOLEN.EQ.0)  GO TO 500
C
      NFOUND = 0
C
      DO 450 NN=1,NOVAR
            VARNO = NN
            IF (LENNAM(VARNO).NE.LENGTH)  GO TO 450
            NFOUND = NFOUND + 1
C
                  DO 400 II=1,LENGTH
                        IF (VARNAM(II,VARNO).NE.TSTVAR(II))  GO TO 430
400               CONTINUE
C
C           VARIABLE NAME HAS BEEN FOUND AT VARIABLE NUMBER VARNO.
            INITRE = 1
            GO TO 650
C
430         CONTINUE
C
            IF (NFOUND.EQ.TNOLEN)  GO TO 500
C
450   CONTINUE
C
C     PROCESS NEW VARIABLE NAME.
500   CONTINUE
      INITRE = 0
C
      NOVAR = NOVAR + 1
      IF (NOVAR.GT.500)  THEN
         PRINT 550, CARD
550      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' MORE THAN 500 DIFFERENT',
     4             ' PREPROCESSOR VARIABLES #VARNAME. '
     5           / 1X, 72A1)
         STOP 500
      ENDIF
      VARNO = NOVAR
      NOLEN(LENGTH) = NOLEN(LENGTH) + 1
      LENNAM(VARNO) = LENGTH
C
      JJ = IPT
      DO 600 II=1,LENGTH
            VARNAM(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
600   CONTINUE
C
650   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.EQUAL)  THEN
         PRINT 670, CARD
670      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT EQUAL SIGN. '
     4           / 1X, 72A1)
         STOP 360
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  GO TO 750
C
C     MOVE POINTER IPT TO FIRST CHARACTER OF
C     STRING OF CHARACTERS BETWEEN QUOTES,
C     I.E., VARIABLE VALUE.
      IPT = IPT + 1
C
C     FIND LENGTH OF STRING OF CHARACTERS BETWEEN QUOTES.
      CALL FINDLQ (CARD, IPT, LENGTH)
C
C     PROCESS VARIABLE VALUE.
C
      LENVAL(VARNO) = LENGTH
C
      JJ = IPT
      DO 700 II=1,LENGTH
            VARVAL(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
700   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE VALUE.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  THEN
         PRINT 720, CARD
720      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = ''VALUE'' ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT THE SECOND QUOTE. '
     4           / 1X, 72A1)
         STOP 400
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      GO TO 900
C
C     PROCESS FORMULA.
750   CONTINUE
C
C     STORE FORMULA AND
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL SETFR (CARD, IPT, NFT)
C
C     EVALUATE FORMULA AND
C     SET VARIABLE VALUE LENGTH AND VARIABLE VALUE.
      CALL SETVAR (VARNO)
C
900   CONTINUE
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 920, CARD
920      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     4           / 1X, 72A1)
         STOP 420
      ENDIF
C
      IF ( INITRE .EQ. 0 )  PRINT 930,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
      IF ( INITRE .EQ. 1 )  PRINT 940,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
930   FORMAT ('fortprep variable   initialized   ', 9A1, '= ''', 20A1)
940   FORMAT ('fortprep variable reinitialized   ', 9A1, '= ''', 20A1)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
      END
      SUBROUTINE PERCT5 (CARD, IPT, NFT)
C
C     SUBROUTINE PERCT5 PROCESSES LEVEL 5 CONTROL CARDS.
C
      PARAMETER ( MAXMEM = 40 )
C
      CHARACTER*1      CARD(72)
      CHARACTER*1      PER
      DATA             PER           /'%'/
      CHARACTER*1      MEMBER(MAXMEM)
      CHARACTER*1      BLANK
      DATA             BLANK         /' '/
      CHARACTER*1      SEMICL
      DATA             SEMICL        /';'/
      CHARACTER*1      NUM
      DATA             NUM           /'#'/
      CHARACTER*1      EQUAL
      DATA             EQUAL         /'='/
      CHARACTER*1      QUOTE
      DATA             QUOTE         /''''/
      CHARACTER*1      TSTVAR(8)
      INTEGER          TNOLEN
      INTEGER          VARNO
C
C
C
C     DESCRIPTION OF COMMON /BLOCK/
C
C     NOCARD - NUMBER OF LAST CARD WRITTEN TO FT09F001.
C     NOVAR  - TOTAL NUMBER OF VARIABLES.
C     NOLEN  - NUMBERS OF VARIABLE NAMES OF PARTICULAR LENGTHS.
C              E.G., NOLEN(5) IS THE NUMBER OF VARIABLE NAMES
C              OF LENGTH 5.
C     VARNAM - VARIABLE NAMES.
C     LENNAM - VARIABLE NAME LENGTHS.
C     VARVAL - VARIABLE VALUES.
C     LENVAL - VARIABLE VALUE LENGTHS.
C
      COMMON  /BLOCK/  NOCARD,
     1                 NOVAR,
     2                 NOLEN(8),
     3                 VARNAM(8,500),
     4                 LENNAM(500),
     5                 VARVAL(16,500),
     6                 LENVAL(500)
C
      CHARACTER*1      VARNAM, VARVAL
C
C
C
C     DESCRIPTION OF COMMON /EXTRA/
C     WHEN LREPVR=0, # VARIABLES ARE NOT REPLACED WITH VALUES.
C     WHEN LREPVR=1, # VARIABLES ARE     REPLACED WITH VALUES.
C     NOVREP - NUMBER OF # SIGNS     NOT REPLACED WITH VALUES;
C            - WHEN LREPVR=1.
C     NOVNEW - NUMBER OF # VARIABLES THAT MAY NOT BE INITIALIZED;
C            - WHEN LREPVR=1.
C     LTABLE - TABLE FOR CHARACTERS (UPPER AND LOWER CASE LETTERS,
C            - NUMBERS) TO BE DETECTED.
C     ILOWER, IUPPER - LOWER AND UPPER CASE 'I'.
C     NLOWER, NUPPER - LOWER AND UPPER CASE 'N'.
C     CLOWER, CUPPER - LOWER AND UPPER CASE 'C'.
C     LLOWER, LUPPER - LOWER AND UPPER CASE 'L'.
C     ULOWER, UUPPER - LOWER AND UPPER CASE 'U'.
C     DLOWER, DUPPER - LOWER AND UPPER CASE 'D'.
C     ELOWER, EUPPER - LOWER AND UPPER CASE 'E'.
      COMMON  /EXTRA/  LREPVR,
     1                 NOVREP,
     2                 NOVNEW,
     3                 LTABLE(256),
     4                 ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
      CHARACTER*1      ILOWER, IUPPER,
     5                 NLOWER, NUPPER,
     6                 CLOWER, CUPPER,
     7                 LLOWER, LUPPER,
     8                 ULOWER, UUPPER,
     9                 DLOWER, DUPPER,
     A                 ELOWER, EUPPER
C
C
C
100   CONTINUE
C
      IF (CARD(IPT).NE.PER)  THEN
         PRINT 150, CARD
150      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING % CONTROL STATEMENT. '
     2           / ' TESTED CHARACTER IS NOT PERCENT SIGN. '
     3           / 1X, 72A1)
         STOP 260
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      ITEST = IPT + 2
      IF (ITEST.GT.72)  GO TO 200
C
      IF ( (CARD(IPT  ).EQ.DUPPER) .OR. (CARD(IPT  ).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+1).EQ.CUPPER) .OR. (CARD(IPT+1).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
      IF ( (CARD(IPT+2).EQ.LUPPER) .OR. (CARD(IPT+2).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 200
      ENDIF
C
C     MOVE POINTER IPT TO 'L' OF 'DCL'.
      IPT = IPT + 2
C
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL MOVESC (CARD, IPT, NFT)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
200   CONTINUE
C
      ITEST = IPT + 6
      IF (ITEST.GT.72)  GO TO 300
C
      IF ( (CARD(IPT  ).EQ.IUPPER) .OR. (CARD(IPT  ).EQ.ILOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+1).EQ.NUPPER) .OR. (CARD(IPT+1).EQ.NLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+2).EQ.CUPPER) .OR. (CARD(IPT+2).EQ.CLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+3).EQ.LUPPER) .OR. (CARD(IPT+3).EQ.LLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+4).EQ.UUPPER) .OR. (CARD(IPT+4).EQ.ULOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+5).EQ.DUPPER) .OR. (CARD(IPT+5).EQ.DLOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
      IF ( (CARD(IPT+6).EQ.EUPPER) .OR. (CARD(IPT+6).EQ.ELOWER) ) THEN
           CONTINUE
      ELSE
           GO TO 300
      ENDIF
C
C     MOVE POINTER IPT TO 'E' OF 'INCLUDE'.
      IPT = IPT + 6
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
C     POINTER IPT SHOULD BE AT FIRST CHARACTER OF MEMBER NAME.
C
C     FIND LENGTH OF MEMBER NAME.
      CALL FINDLM (CARD, IPT, LENGTH)
C
C     SET MEMBER ARRAY TO MEMBER NAME.
      DO 240 II=1,MAXMEM
            MEMBER(II) = BLANK
240   CONTINUE
      JJ = IPT
      DO 250 II=1,LENGTH
            MEMBER(II) = CARD(JJ)
            JJ = JJ + 1
250   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF MEMBER NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 270, CARD
270      FORMAT (/ ' ********** ERROR ',
     1             ' PROCESSING   % INCLUDE FILENAME ; '
     2           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     3           / 1X, 72A1)
         STOP 300
      ENDIF
C
C     CALL LEVEL6 TO PROCESS LEVEL 6 CARDS OF INCLUDED MEMBER.
      CALL LEVEL6 (MEMBER)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
C
C
300   CONTINUE
C
      IF (CARD(IPT).NE.NUM)  THEN
         PRINT 320, CARD
320      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT #. '
     4           / 1X, 72A1)
         STOP 320
      ENDIF
C
C     FIND LENGTH OF VARIABLE NAME.
      CALL FINDLV (CARD, IPT, LENGTH)
C
C     HAS VARIABLE NAME BEEN USED BEFORE?
C
C     COPY VARIABLE NAME TO TSTVAR ARRAY.
      JJ = IPT
      DO 350 II=1,LENGTH
            TSTVAR(II) = CARD(JJ)
            JJ = JJ + 1
350   CONTINUE
C
      TNOLEN = NOLEN(LENGTH)
      IF (TNOLEN.EQ.0)  GO TO 500
C
      NFOUND = 0
C
      DO 450 NN=1,NOVAR
            VARNO = NN
            IF (LENNAM(VARNO).NE.LENGTH)  GO TO 450
            NFOUND = NFOUND + 1
C
                  DO 400 II=1,LENGTH
                        IF (VARNAM(II,VARNO).NE.TSTVAR(II))  GO TO 430
400               CONTINUE
C
C           VARIABLE NAME HAS BEEN FOUND AT VARIABLE NUMBER VARNO.
            INITRE = 1
            GO TO 650
C
430         CONTINUE
C
            IF (NFOUND.EQ.TNOLEN)  GO TO 500
C
450   CONTINUE
C
C     PROCESS NEW VARIABLE NAME.
500   CONTINUE
      INITRE = 0
C
      NOVAR = NOVAR + 1
      IF (NOVAR.GT.500)  THEN
         PRINT 550, CARD
550      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' MORE THAN 500 DIFFERENT',
     4             ' PREPROCESSOR VARIABLES #VARNAME. '
     5           / 1X, 72A1)
         STOP 500
      ENDIF
      VARNO = NOVAR
      NOLEN(LENGTH) = NOLEN(LENGTH) + 1
      LENNAM(VARNO) = LENGTH
C
      JJ = IPT
      DO 600 II=1,LENGTH
            VARNAM(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
600   CONTINUE
C
650   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE NAME.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.EQUAL)  THEN
         PRINT 670, CARD
670      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT EQUAL SIGN. '
     4           / 1X, 72A1)
         STOP 360
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  GO TO 750
C
C     MOVE POINTER IPT TO FIRST CHARACTER OF
C     STRING OF CHARACTERS BETWEEN QUOTES,
C     I.E., VARIABLE VALUE.
      IPT = IPT + 1
C
C     FIND LENGTH OF STRING OF CHARACTERS BETWEEN QUOTES.
      CALL FINDLQ (CARD, IPT, LENGTH)
C
C     PROCESS VARIABLE VALUE.
C
      LENVAL(VARNO) = LENGTH
C
      JJ = IPT
      DO 700 II=1,LENGTH
            VARVAL(II,VARNO) = CARD(JJ)
            JJ = JJ + 1
700   CONTINUE
C
C     MOVE POINTER IPT TO LAST CHARACTER OF VARIABLE VALUE.
      IPT = IPT + LENGTH - 1
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      IF (CARD(IPT).NE.QUOTE)  THEN
         PRINT 720, CARD
720      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = ''VALUE'' ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT THE SECOND QUOTE. '
     4           / 1X, 72A1)
         STOP 400
      ENDIF
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER.
      CALL BLANKM (CARD, IPT, NFT)
C
      GO TO 900
C
C     PROCESS FORMULA.
750   CONTINUE
C
C     STORE FORMULA AND
C     MOVE POINTER IPT TO NEXT SEMICOLON.
      CALL SETFR (CARD, IPT, NFT)
C
C     EVALUATE FORMULA AND
C     SET VARIABLE VALUE LENGTH AND VARIABLE VALUE.
      CALL SETVAR (VARNO)
C
900   CONTINUE
C
      IF (CARD(IPT).NE.SEMICL)  THEN
         PRINT 920, CARD
920      FORMAT (/ ' ********** ERROR '
     1           / ' PROCESSING  % #VARNAME = VALUE ; ',
     2             ' CONTROL STATEMENT. '
     3           / ' TESTED CHARACTER IS NOT SEMICOLON. '
     4           / 1X, 72A1)
         STOP 420
      ENDIF
C
      IF ( INITRE .EQ. 0 )  PRINT 930,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
      IF ( INITRE .EQ. 1 )  PRINT 940,
     X     (VARNAM(II,VARNO), II=1,  LENNAM(VARNO)),
     X     (          BLANK , II=1,9-LENNAM(VARNO)),
     X     (VARVAL(II,VARNO), II=1,  LENVAL(VARNO)), QUOTE
C
930   FORMAT ('fortprep variable   initialized   ', 9A1, '= ''', 20A1)
940   FORMAT ('fortprep variable reinitialized   ', 9A1, '= ''', 20A1)
C
C     MOVE POINTER IPT TO NEXT NONBLANK CHARACTER ON CARD.
      CALL BLANKE (CARD, IPT)
      IF (IPT.EQ.73) RETURN
C
      GO TO 100
C
      END
