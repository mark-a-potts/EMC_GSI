       SUBROUTINE FCLIP(IFRAME,IXYXY,IXYNEW,IRETN)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C                .      .    .                                       .
C SUBPROGRAM:    FCLIP       CLIPPER OF ABSOLUTE VECTOR TO THE BOUNDS
C   PRGMMR: KRISHNA KUMAR     ORG: W/NP12    DATE: 1999-07-01
C
C ABSTRACT: CLIPPER OF ABSOLUTE VECTOR TO THE BOUNDS OF WINDOW
C   IN ORDER TO CHANGE TO FLOATING POINT COORDINATES.
C
C PROGRAM HISTORY LOG:
C   88-08-12  ORIGINAL AUTHOR DAVE SHIMOMURA
C   94-12-21  LUKE LIN       CONVERTED THIS CODE TO CFT-77.
C 1999-07-01  KRISHNA KUMAR  CONVERTED THIS CODE FROM CRAY TO
C                            IBM RS/6000
C
C USAGE:    CALL FCLIP(IFRAME,IXYXY,IXYNEW,IRETN)
C   INPUT ARGUMENT LIST:
C    IFRAME    - BOUNDARY OF THE WINDOW DEFINED BY TWO POINTS LOWER
C              - LEFT CORNER AND UPPER-RIGHT CORNER POINT.
C    IXYXY     - ARRAY OF FOUR REAL COORDINATES: X1,Y1, X2,Y2
C              - WHICH ARE THE END POINTS OF THE ABSOLUTE VECTOR
C
C   OUTPUT ARGUMENT LIST:
C     XYNEW    - XYNEW(4) ARRAY OF FOUR REAL END POINTS OF THE
C              - RESULTING CLIPPED VECTOR X1,Y1, X2,Y2
C     IRETN    - = 0  IF GIVEN VECTOR LAY ENTIRELY WITHIN WINDOW
C              - AND NO CLIPPING REQUIRED;
C              - = 1  IF GIVEN VECTOR LAY ENTIRELY OUTSIDE WINDOW
C              - = 2  IF CLIPPED PT1
C              - = 3  IF CLIPPED BOTH ENDS
C              - = 4  IF CLIPPED PT2
C
C
C   OUTPUT FILES:
C     FT06F001 - PRINT FILE.
C
C REMARKS:
C
C ATTRIBUTES:
C   LANGUAGE: F90
C   MACHINE:  IBM
C
C$$$
C
       REAL    XYRA(4)
       REAL    X1,Y1,X2,Y2
C
       INTEGER    IFRAME(4)
       INTEGER    ISWICH
       INTEGER    IWHCLP
       INTEGER    IXYNEW(4)
       INTEGER    IXYXY(4)
       INTEGER    KABVBT
       INTEGER    KBLOBT
       INTEGER    KRITBT
       INTEGER    KLEFBT
C
       INTEGER    KLIP1
       INTEGER    KLIP2
       INTEGER    KODE1,KODE2
       INTEGER    MQ
C
       DATA       KABVBT / 8 /
       DATA       KBLOBT / 4 /
       DATA       KRITBT / 2 /
       DATA       KLEFBT / 1 /
       DATA       KLIP1  / 2 /
       DATA       KLIP2  / 4 /
C
       EQUIVALENCE  (X1,XYRA(1))
       EQUIVALENCE  (Y1,XYRA(2))
       EQUIVALENCE  (X2,XYRA(3))
       EQUIVALENCE  (Y2,XYRA(4))
C
C      . . .   S T A R T   . . .
C
       IRETN = 0
       DO  I = 1,4
         XYRA(I) = FLOAT(IXYXY(I))
       ENDDO
C
       X1FRAM = FLOAT(IFRAME(1))
       Y1FRAM = FLOAT(IFRAME(2))
       X2FRAM = FLOAT(IFRAME(3))
       Y2FRAM = FLOAT(IFRAME(4))
C
       IWHCLP = 0
       ISWICH = 0
C      ... ALTERNATING SWITCH FOR WHICH END IS BEING CLIPPED
C
       KODE2 = 0
       IF(X2 .LT. X1FRAM) KODE2 = IOR(KODE2,KLEFBT)
       IF(X2 .GT. X2FRAM) KODE2 = IOR(KODE2,KRITBT)
       IF(Y2 .LT. Y1FRAM) KODE2 = IOR(KODE2,KBLOBT)
       IF(Y2 .GT. Y2FRAM) KODE2 = IOR(KODE2,KABVBT)
C
  211  CONTINUE
       KODE1 = 0
       IF(X1 .LT. X1FRAM) KODE1 = IOR(KODE1,KLEFBT)
       IF(X1 .GT. X2FRAM) KODE1 = IOR(KODE1,KRITBT)
       IF(Y1 .LT. Y1FRAM) KODE1 = IOR(KODE1,KBLOBT)
       IF(Y1 .GT. Y2FRAM) KODE1 = IOR(KODE1,KABVBT)
C
C      ... TEST FOR GOOD VECTOR ENTIRELY WITHIN WINDOW
C
       IF((KODE1 + KODE2) .EQ. 0) THEN
C
C      ... AFTER BOTH ENDS ARE SET TO WITHIN BOUNDS
C      ... OR COULD HAVE COME DIRECTLY W/ NO CLIPPING REQUIRED
C
         IRETN = IWHCLP
         IF(IRETN .EQ. 6) IRETN = 3
C      ... WHICH SETS BOTH-ENDS-CLIPPED CODE = 3
C
          IF(ISWICH .NE. 0) THEN
C
            IXYNEW(1) = NINT(X2)
            IXYNEW(2) = NINT(Y2)
            IXYNEW(3) = NINT(X1)
            IXYNEW(4) = NINT(Y1)
          ELSE
C      ... ELSE, WORK POINTS ARE IN ORIGINAL SEQUENCE
           DO   I = 1,4
            IXYNEW(I) = NINT(XYRA(I))
           ENDDO
          ENDIF
C
       ELSE
C
C      ... TEST FOR BAD VECTOR ENTIRELY OUTSIDE WINDOW
C
         MQ = IAND(KODE1,KODE2)
         IF(MQ .NE. 0)THEN
C
C      ... COMES HERE IF VECTOR ENTIRELY OUTSIDE
C      ... PERHAPS AFTER SOME CLIPPING
          IRETN = 1
          DO   I = 1,4
           IXYNEW(I) = IXYXY(I)
          ENDDO
         ELSE
C      ... OTHERWISE, THIS VECTOR IS LIKELY TO BE AN INTERSECTION
C      ... OF THE BOUNDS OF THE WINDOW
C      ... THIS LOGIC WORKS WITH PT1 OUTSIDE OF WINDOW
C      ... AND MOVES INWARD LOOKING FOR ENTRANCE.
C      ... IS PT1 OUTSIDE?
         IF(KODE1 .EQ. 0) THEN
C      ...  PT1 IS INSIDE, SO INTERCHANGE ENDS
          ISWICH = ISWICH + 1
          ISWICH = MOD(ISWICH,2)
C
          MQ = KODE1
          KODE1 = KODE2
          KODE2 = MQ
C
          HOLD = X1
          X1 = X2
          X2 = HOLD
C
          HOLD = Y1
          Y1 = Y2
          Y2 = HOLD
C      ... WHICH EXHANGED HEAD AND TAIL POINTS
C      ...   SO NOW PT1 IS OUTSIDER ...
C
         ENDIF
C      ... COMES HERE WITH PT1 THE OUTSIDER
C
         IF((IAND(KODE1,KLEFBT)) .EQ. 0)THEN
          IF((IAND(KODE1,KRITBT)) .EQ. 0)THEN
           IF((IAND(KODE1,KBLOBT)) .EQ. 0)THEN
            IF((IAND(KODE1,KABVBT)) .EQ. 0)THEN
            ELSE
C              PUSH TOWARD TOP EDGE ...
              X1 = X1 + (X2-X1)*(Y2FRAM-Y1)/(Y2-Y1)
              Y1 = Y2FRAM
            ENDIF
           ELSE
C            PUSH TOWARD BOTTOM EDGE ...
             X1 = X1 + (X2-X1)*(Y1FRAM-Y1)/(Y2-Y1)
             Y1 = Y1FRAM
           ENDIF
          ELSE
C           PUSH TOWARD RIGHT EDGE ...
            Y1 = Y1 + (Y2-Y1)*(X2FRAM-X1)/(X2-X1)
            X1 = X2FRAM
          ENDIF
         ELSE
C         PUSH TOWARD LEFT EDGE ...
          Y1 = Y1 + (Y2-Y1)*(X1FRAM-X1)/(X2-X1)
          X1 = X1FRAM
         ENDIF
C
C      ... COMES HERE AFTER MOVING PT1 TO WINDOW BNDRY
C
         IF(ISWICH .NE. 0)THEN
C        ...ISWICH=1, SO PT2 FO ORIGINAL WAS CLIPPED OFF
           IWHCLP = IOR(IWHCLP,KLIP2)
         ELSE
C        ... ORIGINAL PT1 END HAS BEEN CLIPPED OFF ...
           IWHCLP = IOR(IWHCLP,KLIP1)
         ENDIF
C
C          NOW JUMP WAY BACK TO RECOMPUTE FOR THE CHNGD POINT
C
         GO TO 211
         ENDIF
       ENDIF
       RETURN
       END
