C          DATA SET INT2CH     AT LEVEL 001 AS OF 04/16/93
       SUBROUTINE INT2CH(INTG,CTEXT,NCHAR,CPLMIZ)
C$$$  SUBPROGRAM DOCUMENTATION  BLOCK
C                .      .    .                                       .
C SUBPROGRAM:  INT2CH        CONVERTS BINARY INTEGER TO CHARACTER.
C   PRGMMR: KRISHNA KUMAR    ORG: NP12     DATE:1999-07-01
C
C ABSTRACT: CONVERTS AN INTEGER (INTEGER*4) INTO A CHARACTER STRING
C   (CHARACTER*12) UNDER FORMAT CONTROL WHICH SPECIFIES THE FILL
C   CHARACTERS, THE SIGN CHARACTERS, AND POSITIONING.
C   A SLIGHTLY MODIFIED VERSION OF BIN2EB FOR IBM-FORTRAN77.
C
C PROGRAM HISTORY LOG:
C   87-05-08  SHIMOMURA
C   88-01-06  HENRICHSEN UPDATED DOCKBLOCK AND USE W3AI24 FOR LOGICAL
C             COMPAIR.
C 1999-07-01  KRISHNA KUMAR CONVERTED THIS CODE FROM CRAY TO 
C             IBM RS/6000.
C
C USAGE:    CALL INT2CH(INTG,CTEXT,NCHAR,CPLMIZ)
C
C   INPUT ARGUMENT LIST:
C     INTG     - THE GIVEN BINARY INTEGER*4
C     NCHAR    - NUMBER OF EBCDIC CHARS DESIRED IN THE CONVERTED
C              - AND FORMATTED NUMBER-ZONE.   ACCEPTABLE RANGE
C              - FOR NCHAR IS 1 TO 12
C              - (NCHAR MUST COUNT SIGN POSITION IF SIGN DESIRED)
C     CPLMIZ   - A 4-CHAR STRING  (FOR EXAMPLE,  CPLMIZ='A+-+' )
C              - FIRST  CHAR IS FORMAT CODE (SEE TABLE BELOW)
C              - SECOND CHAR IS CHAR DESIRED FOR POSITIVE SIGN
C              - THIRD  CHAR IS CHAR DESIRED FOR NEGATIVE SIGN
C              - FOURTH CHAR IS CHAR DESIRED FOR SIGN OF ZERO-VALUED
C              - INTG.
C              - A '9' IN THE SECOND, THIRD, OR FOURTH CHAR POSITION
C              - MEANS TO OMIT THAT SIGN
C
C   OUTPUT ARGUMENT LIST:
C     CTEXT    - RESULTING 12-CHARACTER STRING.  THE VALUE OF THE
C              - GIVEN INTEGER EXPRESSED AS EBCDIC CHARACTERS.
C              - USER SHOULD DECLARE CTEXT AS CHARACTER*12
C
C
C   RETURN CONDITIONS:
C
C     IF NCHAR IS .LE. 0  OR IF FORMAT CODE IN CPLMIZ IS UNKNOWN,
C     THEN THE ERROR IN THE ARGUMENT IS INDICATED BY RETURNING WITH
C     CTEXT = '************'
C
C REMARKS:
C
C     ----------------------------------------------------------------
C              F O R M A T    D E S C R I P T I O N
C
C     FORMAT  JUSTIFIED   LEADING FILL        FILL OUTSIDE        FIXED
C      CODE  W/I 12-CHAR  CHAR ABV HI-        NCHAR-WIDE           OR
C               CTEXT     ORDER DIGIT         FIELD               MOVING
C                         W/I NCHAR-WIDTH                         SIGN**
C
C      'L'      LEFT       ZERO CHAR.     BINARY ZEROS TO RIGHT   FIXED
C      'R'      RIGHT      ZERO CHAR.     BINARY ZEROS TO LEFT    FIXED
C
C      'A'      LEFT       ZERO CHAR.     BLANK CHARS  TO RIGHT   FIXED
C      'B'      RIGHT      ZERO CHAR.     BLANK CHARS  TO LEFT    FIXED
C
C      'I'      LEFT       BLANK CHAR.    BLANK CHARS  TO RIGHT   MOVING
C      'J'      RIGHT      BLANK CHAR.    BLANK CHARS  TO LEFT    MOVING
C
C      'S'      LEFT       ASTERISK       BLANK CHARS  TO RIGHT   FIXED
C      'U'      LEFT       ASTERISK       BLANK CHARS  TO RIGHT   MOVING
C
C      'E'      LEFT       ASTERISK       BLANK CHARS  TO RIGHT   FIXED
C      'F'      LEFT       ASTERISK       BLANK CHARS  TO RIGHT   MOVING
C
C      'W'      LEFT       POUND SIGN'#'  BLANK CHARS  TO RIGHT   FIXED
C      'Y'      LEFT       POUND SIGN'#'  BLANK CHARS  TO RIGHT   MOVING
C
C     ** WHERE "FIXED" SIGN-POSITION IS THE HI-ORDER CHAR POSITION
C       WITHIN THE NCHAR-WIDE FIELD, WHICH CAN BE LEFT- OR RIGHT-
C       JUSTIFIED WITHIN THE 12-CHAR WIDE CTEXT,
C       WHILE THE "MOVING" SIGN IS POSITIONED ADJACENT TO THE HI-ORDER
C       DIGIT OF THE CONVERTED NUMBER.
C       WHEN SIGN IS REQUESTED, IT HAS PRIORITY OVER A DIGIT OCCUPYING
C       THE SAME CHAR POSITION.
C
C     THE LOGIC OF THE CONVERSION BEGINS WITH THE UNITS DIGIT OF THE
C       GIVEN INTG AND WORKS TOWARD HIGHER-ORDER SIGNIFICANT DIGITS
C       UNTIL NCHAR IS SATISFIED.  SO IF NCHAR IS NOT WIDE ENOUGH
C       FOR THE VALUE IN INTG, THEN THE MOST SIGNIFICANT DIGITS
C       ARE LOST.
C
C     FORMAT CODES 'E' AND 'F' DIFFER FROM SIMILAR 'S' AND 'U' IN
C       THAT 'E' AND 'F' YIELDS A MINIMUM OF 2 CHARACTERS IN THE
C       RESULTING NUMBER.  IF ONLY A UNITS POSITION OF SIGNIFICANCE
C       THEN IT INSERTS A LEADING ZERO-CHARACTER BEFORE SWITCHING
C       TO THE ASTERISK FILL-CHARACTER OR SIGN AS APPROPRIATE.
C
C     *     *     *     *     *     *     *     *     *     *     *
C      CAUTION:
C      ... IF YOU ARE SUBSTITUTING THIS SUBROUTINE FOR BIN2EB,
C      ... THEN, BEWARE OF:  LENGTH OF THE RESULTING CTEXT
C      ...   USED TO BE 8-BYTES IN INTEGER*4 IBCD(2) ARRAY
C      ...   NOW IS 12-BYTES IN CHARACTER*12 CTEXT, SO A RIGHT-
C      ...   JUSTIFIED ANSWER WILL BE FARTHER DOWN THE STRING;
C
C      ...   AND THE FORMAT SPECIFIER WHICH USED TO BE 3-BYTES
C      ...   LONG "LPLMI" HAS BEEN CHANGED TO CHARACTER*4 CPLMIZ
C      ...   WITH THE ADDITION OF A SIGN FOR ZERO-VALUED INTG.
C
C      ...   YOU MUST DECLARE CHARACTER*12 CTEXT
C      ...   AND              CHARACTER*4  CPLMIZ
C
C     *     *     *     *     *     *     *     *     *     *     *
C     -----------------------------------------------------------------
C
C
C ATTRIBUTES:
C   LANGUAGE: F90.
C   MACHINE:  IBM
C
C$$$
C
C
       CHARACTER*12  CDIGIT
C      ... WHERE CDIGIT IS WORK AREA FOR RESULTING CHARACTER STRING
       CHARACTER*12  CTEXT
C      ... WHERE CTEXT IS RESULTING CHARACTER STRING
C      ... CAUTION: RESULTING CTEXT IS A FIELD OF 12 CHARACTERS
C      ...   WITHIN WHICH NCHAR CHARS ARE CONVERTED DIGITS
C      ...   WITH FILL AS SPECIFIED IN FORMAT CODE CPLMIZ.
C
       CHARACTER*4  CLITS
       CHARACTER*4  CPLMIZ
C      ... WHERE CPLMIZ IS FORMAT CODE FOR RESULTS ...
C      ...   CODE + SIGN-FOR-POS + SIGN-FOR-NEG + SIGN-FOR-ZERO
C
       CHARACTER*1  CPLUS
       CHARACTER*1  CMINUS
       CHARACTER*1  CZERO
       CHARACTER*1  FILLCH
       CHARACTER*1  FMTCOD
       CHARACTER*1  IFMTCD(12)
       CHARACTER*1  SIGNCH
C
       INTEGER*4  INTG
C      ... WHERE INTG IS GIVEN I*4 BINARY INTEGER TO BE CONVERTED.
       INTEGER*4  K0EBCD
C      ... WHERE K0EBCD IS EBCDIC CODED ZERO DIGIT
       INTEGER*4  MAXCH
       INTEGER*4  NCHAR
C      ... WHERE NCHAR IS NUMBER OF CHARS DESIRED CONVERTED
C
       LOGICAL*4  W3AI24
C
C      ... LOGICAL SWITCHES ...
C
       LOGICAL*1  SIGNQ
       LOGICAL*1  LZIP
       LOGICAL*1  SWFIXS
       LOGICAL*1  SIGNIN
       LOGICAL*1  SWZR
       LOGICAL*1  SWTS
C
C
       EQUIVALENCE  (CLITS(1:1),FMTCOD)
       EQUIVALENCE  (CLITS(2:2),CPLUS)
       EQUIVALENCE  (CLITS(3:3),CMINUS)
       EQUIVALENCE  (CLITS(4:4),CZERO)
C
       DATA       IFMTCD        /'L','I','R','J','A','B',
     1                          'S','W','U','Y','E','F'/
       DATA       K0EBCD       / Z'00000030' /
       DATA       MAXCH        / 12 /
C
C      . . .   S T A R T   . . .
C
       INUMB = INTG
       CLITS = 'A+-*'
       CLITS = CPLMIZ
       MAXI = NCHAR
C      ... TEST FOR ACCEPTABLE RANGE OF NCHAR
       IF(MAXI .LE. 0) GO TO 25
       IF(MAXI .GT. MAXCH) MAXI = MAXCH
C      ... INITIALIZE WORK BUFFER FOR TRAILING BLANK CHAR FILL ...
           DO  10  I = 1,12
              CDIGIT(I:I) = ' '
  10       CONTINUE
C
       SIGNQ = .FALSE.
       LZIP  = .FALSE.
       IF(INUMB .GT. 0) THEN
C        ... COMES HERE IF INUMB IS POSITIVE-VALUED ...
         IF(CPLUS .NE. '9') THEN
C          ... A SIGN CHARACTER IS DESIRED ON THIS POSITIVE-VALUED INUMB
           SIGNCH = CPLUS
           SIGNQ = .TRUE.
         ENDIF
C
       ELSE IF (INUMB .EQ. 0) THEN
         IF(CZERO .NE. '9') THEN
C          ...  A SIGN CHARACTER IS DESIRED ON THIS ZERO-VALUED INUMB
           SIGNCH = CZERO
           SIGNQ = .TRUE.
         ENDIF
C
       ELSE
C      ... COMES HERE IF INUMB WAS NEGATIVE-VALUED ...
         INUMB = IABS(INUMB)
         IF(CMINUS .NE. '9') THEN
C          ...  A SIGN IS DESIRED ON THIS NEGATIVE INUMB
           SIGNCH = CMINUS
           SIGNQ = .TRUE.
         ENDIF
       ENDIF
C
             ASSIGN 20 TO IHERE
           DO 20 II = 1,12
               KEY = II
              IF(W3AI24(FMTCOD,IFMTCD(II),1))GO TO 30
  20       CONTINUE
C      ... OTHERWISE, GIVEN FORMAT CODE IS NOT DEFINED ...
  25   CONTINUE
       CDIGIT = '************'
       GO TO 500
  30   CONTINUE
              GO TO (300,400,330,360,310,340,
     1               610,630,620,640,710,720) KEY
C
  300  CONTINUE
C      ... COMES HERE FOR 'L' FORMAT CODE ...
       FILLCH = '0'
C      ... FOR LEADING ZERO-CHARACTER FILL
           DO  304 I = 1,12
               CDIGIT(I:I) = CHAR(0)
  304      CONTINUE
C      ... FOR TRAILING BINARY-ZERO FILL
       SWFIXS = .TRUE.
C      ... INDICATES SIGN IS IN FIXED POSITION
       GO TO 401
C
  310  CONTINUE
C      ... COMES HERE FOR 'A' FORMAT CODE ...
       FILLCH = '0'
C      ... FOR LEADING ZERO-CHARACTER FILL
C      ... FOR TRAILING BLANK CHAR FILL; ALREADY INITIALIZED.
       SWFIXS = .TRUE.
C      ... INDICATES SIGN IS IN FIXED POSITION
       GO TO 401
C
  610  CONTINUE
C      ... COMES HERE FOR 'S' FORMAT CODE ...
       FILLCH = '*'
C      ... FOR LEADING STAR-CHARACTER FILL
C      ... FOR TRAILING BLANK CHAR FILL; ALREADY INITIALIZED.
       SWFIXS = .TRUE.
C      ... INDICATES SIGN IS IN FIXED POSITION
       GO TO 401
C
  620  CONTINUE
C      ... COMES HERE FOR 'U' FORMAT CODE ...
       FILLCH = '*'
C      ... FOR LEADING STAR-CHARACTER FILL
C      ... FOR TRAILING BLANK CHAR FILL; ALREADY INITIALIZED.
       SWFIXS = .FALSE.
C      ... INDICATES SIGN IS IN FLOATING POSITION
       GO TO 401
C
  710  CONTINUE
C      ... COMES HERE FOR 'E' FORMAT CODE ...
       FILLCH = '*'
C      ... FOR LEADING STAR-CHARACTER FILL
C      ... FOR TRAILING BLANK FILL; ALREADY INITIALIZED.
       SWFIXS = .TRUE.
C      ... INDICATES SIGN IS IN FIXED POSITION
       LZIP = .TRUE.
       GO TO 401
C
  720  CONTINUE
C      ... COMES HERE FOR 'F' FORMAT CODE ...
       FILLCH = '*'
C      ... FOR LEADING STAR-CHARACTER FILL
C      ... FOR TRAILING BLANK FILL; ALREADY INITIALIZED.
       SWFIXS = .FALSE.
C      ... INDICATES SIGN IS IN FLOATING POSITION
       LZIP = .TRUE.
       GO TO 401
C
  630  CONTINUE
C      ... COMES HERE FOR 'W' FORMAT CODE ...
       FILLCH = '#'
C      ... FOR LEADING POUND-SIGN-CHARACTER FILL
C      ... FOR TRAILING BLANK FILL; ALREADY INITIALIZED.
       SWFIXS = .TRUE.
C      ... INDICATES SIGN IS IN FIXED POSITION
       GO TO 401
C
  640  CONTINUE
C      ... COMES HERE FOR 'Y' FORMAT CODE ...
       FILLCH = '#'
C      ... FOR LEADING POUND-SIGN-CHARACTER FILL
C      ... FOR TRAILING BLANK FILL; ALREADY INITIALIZED.
       SWFIXS = .FALSE.
C      ... INDICATES SIGN IS IN FLOATING POSITION
       GO TO 401
C
  330  CONTINUE
C      ... COMES HERE FOR 'R' FORMAT CODE ...
       FILLCH = '0'
C      ... FOR LEADING ZERO-CHARACTER FILL
           DO  334 I = 1,122
              CDIGIT(I:I) = CHAR(0)
  334      CONTINUE
C      ... FOR TRAILING BINARY-ZERO FILL
       SWFIXS = .TRUE.
C      ... INDICATES SIGN IS IN FIXED POSITION
       LSHF = 0
       GO TO 402
C
  340  CONTINUE
C      ... COMES HERE FOR 'B' FORMAT CODE ...
       FILLCH = '0'
C      ... FOR LEADING ZERO-CHARACTER FILL
C      ... FOR TRAILING BLANK FILL; ALREADY INITIALIZED.
       SWFIXS = .TRUE.
C      ... INDICATES SIGN IS IN FIXED POSITION
       LSHF = 0
       GO TO 402
C
  360  CONTINUE
C      ... COMES HERE FOR 'J' FORMAT CODE ...
       FILLCH = ' '
C      ... FOR LEADING BLANK-CHARACTER FILL
C      ... FOR TRAILING BLANK FILL; ALREADY INITIALIZED.
       SWFIXS = .FALSE.
C      ... INDICATES SIGN IS IN FLOATING POSITION
       LSHF = 0
       GO TO 402
C
  400  CONTINUE
C      ... COMES HERE FOR 'I' FORMAT CODE ...
       FILLCH = ' '
C      ... FOR LEADING BLANK-CHARACTER FILL
C      ... FOR TRAILING BLANK FILL; ALREADY INITIALIZED.
       SWFIXS = .FALSE.
C      ... INDICATES SIGN IS IN FLOATING POSITION
       GO TO 401
C
C
  401  CONTINUE
       LSHF = MAXCH - MAXI
  402  CONTINUE
       SIGNIN = .FALSE.
C      ... WHERE SIGNIN IS SET WHEN SIGN IS PUT INTO RESULT
       SWZR = .FALSE.
C      ... WHERE SWZR IS SET WHEN ONLY HI-ORDER ZEROS REMAIN
       SWTS = .FALSE.
C      ... WHERE SWTS IS SET WHEN SWZR IS SET, TO TEST SIGN ON NXT LOOP
C
           DO  422  ICOW = 1,MAXI
              ISS = MAXCH + 1 - ICOW
              ISS = ISS - LSHF
              IF(ICOW .NE. MAXI) GO TO 409
C        ... OTHERWISE, ICOW=MAXI; I AM AT LEFTMOST CHAR W/I DATA FLD
              IF(SIGNIN) GO TO 409
              IF(.NOT. SIGNQ) GO TO 409
C        ... OTHERWISE, PUT SIGN-CHARACTER IN AND JUMP OUT
              CDIGIT(ISS:ISS) = SIGNCH
             GO TO 500
C
  409        CONTINUE
              IF(.NOT. SWZR) GO TO 413
C        ... ELSE, SWZR HAD BEEN SET; ONLY HI ORDER ZEROS REMAIN
              IF(SWFIXS) GO TO 411
              IF(.NOT. SWTS) GO TO 411
C        ... ELSE, SWTS HAD BEEN SET ...
              SWTS = .FALSE.
              IF(.NOT. SIGNQ) GO TO 411
C        ... ELSE, THERE IS A SIGN-CHARACTER TO BE INSERTED HERE
              CDIGIT(ISS:ISS) = SIGNCH
              SIGNIN = .TRUE.
             GO TO 422
C
  411        CONTINUE
C        ... COMES HERE IF LEADING FILL CHARACTER TO BE PUT HERE
               CDIGIT(ISS:ISS) = FILLCH
             GO TO 422
C
  413        CONTINUE
C        ... CONVERT ONE DIGIT HERE ...
               IDEC = MOD(INUMB,10)
               I1EBCD = IDEC + K0EBCD
C        ... WHERE I1EBCD IS ONE EBCDI CHAR CODE IN I*4 RIGHT-JUSTIFIED
               CDIGIT(ISS:ISS) = CHAR(I1EBCD)
               INUMB = INUMB / 10
C        ... TO REDUCE WORK NUMBER VALUE  BY ONE DECIMAL DIGIT
               IF(INUMB .NE. 0) GO TO 422
               IF(LZIP .AND. (ICOW .EQ. 1)) GO TO 422
C        ... TO PRESERVE AT LEAST TWO CHARACTERS WHEN FORMAT 'E' OR 'F'
C        ... OTHERWISE, NO MORE LEADING SIGNIF DIGITS ...
               SWZR = .TRUE.
               SWTS = .TRUE.
  422      CONTINUE
       GO TO 500
C
  500  CONTINUE
       CTEXT = CDIGIT
       RETURN
       END
