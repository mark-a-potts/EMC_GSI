      SUBROUTINE CLABEL(Z,IMAX,JMAX,S,A,B,M,IJFOX,LPLMI,IFF)
C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:  CLABEL        PUTS STRIP LABELS ON CONTOURS
C   PRGMMR: KRISHNA KUMAR          ORG: NP12    DATE:1999-07-01
C
C ABSTRACT: FINDS WITHIN A GIVEN RECTANGULAR ARRAY OF THE FORM
C   Z(IMAX,JMAX) AND A FIXED I COLUMN OR J ROW (IJFOX) ALL OF THE
C   CONTOUR LABELS THAT CUT THIS FIXED I COLUMN (NORTH/SOUTH LABELS)
C   OR J ROW (EAST/WEST LABELS).  WHENEVER IJFOX IS POSITIVE,A FIXED
C   J ROW IS DESIRED. WHENEVER IJFOX IS NEGATIVE, A FIXED I COLUM IS
C   DESIRED.  IN ADDITION BASED ON THE SCALE OF THE GRID (SCALE),
C   THIS SUBROUTINE RESTRICTS THE NUMBER OF CONTOUR LABELS ALLOWED
C   PER I OR J DISTANCE WHEN PREPARING THE LABELS FOR OUTPUT.
C
C PROGRAM HISTORY LOG:
C   ??-??-??  DICK SCHURR
C   93-04-07  LILLY CONVERT SUBROUTINE TO FORTRAN 77
C 1999-07-01  KRISHNA KUMAR    ASSIGNED THE RIGHT VALUE FOR INDEF
C                              (FROM RANGE FUNCTION) FOR IBM
C                              RS/6000 SP USING COMPILE OPTION
C                              xlf -qintsize=8 -qrealsize=8
C                              AND CONVERTED THIS CODE FROM CRAY 
C                              TO IBM RS/6000.
C
C USAGE:    CALL CLABEL( Z, IMAX, JMAX, S, A, B, M, IJFORX, LPLMI, IFF )
C
C   INPUT ARGUMENT LIST:
C     Z        -   REAL*4 ARRAY  Z(IMAX,JMAX) THAT CONTAINS THE
C              -   GRID POINT FIELD IN WHICH CONTOURS ARE TO BE
C              -   LABELED.
C     IMAX     -   THE I DIMENSION OF Z.
C     JMAX     -   THE J DIMENSION OF Z.
C     S        -   IS THE DOTS PER GRID INTERVAL DIVIDED BY 60.
C     A        -   REAL*4 ADDITIVE CONSTANT FOR SCALING THE FIELD.
C     B        -   REAL*4 MULTIPLICTIVE CONSTANT FOR SCALING FIELD.
C              -   WHERE TRUE Z VALUE = (XVAL + A)* B
C     M        -   INTEGER   M(2) ARRAY WHERE:
C              -   M(1) IS USED TO SET A LOGICAL FLAG.
C              -   IF M(1) NOT EQUAL TO ZERO, THEN THE FLAG IS ON AND
C              -   ONLY CONTOURS EQUAL TO THE VALUE OF M(1) ARE LABELED.
C              -   M(2) IS THE NUMBER OF CHARACTERS DESIRED WHEN
C              -   THE TRUE VALUE CONVERTED TO EBCDIC FOR CONTOUR LABEL.
C     IJFOX    -   THE INTEGER VALUE OF THE FIXED ROW OR COLUMN ALONG
C              -   WHICH THE CONTOUR LABELS WILL BE PLACED.
C              -   IF POSITIVE,LABELS ARE PLACED ALONG AJ ROW.
C              -   IF NEGATIVE,LABELS ARE PLACED ALONG AN I COLOUM.
C     LPLMI    -   THE FORMAT SELECTOR FOR SUBROUTINE BIN2EB TO CONVERT
C              -   THE Z VALUE TO EBCDIC .IE. 'A99','S+-'.
C     IFF      -   CHARACTER*8 IFF(5) ARRAY WHICH CONTAINS THE FORMAT
C              -   STATEMENT FOR ENCODE OF CONTOUR LABELS.
C
C   INPUT FILES:
C     FT55F001 -  A FILE WHICH CONTAINS VARIAN/FAX LABELS.
C
C   OUTPUT FILES:
C     FT55F001 -   SAME AS INPUT FILE.
C
C REMARKS: THIS SUBROUTINE KNOWN AS DSCLABEL WAS LAST MODIFIED BY
C     PETER HENRICHSEN 27 APR 1982.
C     NOTE: A SPECIAL USE OF THIS SUBROUTINE. WHEN M(1) IS NOT ZERO
C     ONLY THE CONTOUR EQUAL TO THE VALUE OF M(1) WILL BE LABELED.
C     IF M(1) = 580 THEN ONLY THE 580 CONTOUR WILL BE LABELED.
C     A SPECIAL CASE  FOR LABELING THE ZERO LINE IS
C     IF M(1) = 999 THEN ONLY THE 0 CONTOUR WILL BE LABELED.
C
C ATTRIBUTES:
C   LANGUAGE: F90
C   MACHINE:  IBM
C
C$$$
C
C   INPUT VIA COMMON:
C     /PUTARG/ -   PUTHGT,PUTANG,IPRPUT(2),ITAPUT
C              -   PUTHGT,PUTANG,IPRPUT,ITAPUT ARE ARGUEMENTS FOR PUTLAB
C     /ADJ3  / -   IRTCOR,IUPCOR
C              -   IRTCOR,IUPCOR ARE ADJUSTIVE CONSTANTS FOR POSITION-
C              -   ING THE CONTOUR LABELS.
C
      COMMON/PUTARG/PUTHGT,PUTANG,IPRPUT(2),ITAPUT
      COMMON/ADJ3/IRTCOR,IUPCOR
C
      CHARACTER*12  LTEXT
      CHARACTER*12  MTEXT
      CHARACTER*4   LPLMI
C
      REAL      IDEF
      REAL      INDEF
      REAL      Z(IMAX,JMAX)
C
      CHARACTER*8 IFF(5)
      CHARACTER*4 IDECP
      INTEGER     ITEXT(3)
      INTEGER     JTEXT(3)
      INTEGER     M(2)
      INTEGER     JPRPUT(2)
C
      LOGICAL    LINDEF
      LOGICAL    LONLY1
C
C///  DATA IDECP/4H.   /
      DATA IDECP/'.   '/
      DATA ITEXT  /0,0,0/
C///  DATA INDEF  /Z'7FFFFFFF'/
C///  DATA IMSK1  /Z'FF000000'/
C///  DATA IMSK2  /Z'FFFF0000'/
      DATA INDEF  / 1.0E307 /
      DATA IMSK1  /Z'FFFFFFFFFF000000'/
      DATA IMSK2  /Z'FFFFFFFFFFFF0000'/
C
C///  EQUIVALENCE(LTEXT,ITEXT(1))
C///  EQUIVALENCE(MTEXT,JTEXT(1))
C
C     ...WHERE UP AND RIGHT ARE DIR REL TO LABEL NUMBERS VIEWED NATURALY
      IJFIX = IJFOX
      LINDEF = .FALSE.
      LONLY1 = .FALSE.
C
C     ...CHECK TO SEE IF ONLY CERTAIN CONTOURS ARE TO BE LABELED........
C
       IF(M(1).NE.0) LONLY1 = .TRUE.
       IF(.NOT.LONLY1) GO TO 05
       KONST = M(1)
      IF(M(1).EQ.999) KONST = 0
   5  CONTINUE
      KCON4=20
      KCON5=30
      IISFC=0
      IF(M(2).EQ.9) IISFC=1
      ICLOSE=0
      IMIN=1
      JMIN=1
      KBEG=IMIN+2
      KLIM=IMAX-2
      ITYPE=0
      IF(IJFIX.GE.0) GO TO 10
      IJFIX=-IJFIX
      KBEG=JMIN+2
      KLIM=JMAX-4
      ITYPE=1
  10  Q=S*20.
      REM=1.
      KCON6=(FLOAT(IJFIX-1)*Q*3.)+0.5
C     ...WHERE KCON6 IS TRUE LOCN (IN DOTS) OF THE PT ON FIXED COORD.
      ICAL1 = KCON6 + IRTCOR
C     ...THIS ICAL1 IS IDOTS FOR PUTNLAB FOR CONST I CASE, BUT NOT FOR J
      Q1=1./(2.*Q*Q)
      Q2=(Q+1.)/2.
      Q3=1./Q
      N=8
      KLAST=0
      KSTART=KBEG
      IF(ITYPE.EQ.1) GO TO 15
      DO 11 K=KBEG,KLIM
      IDEF=Z(K,IJFIX)
      IF(IDEF.NE.INDEF)  GO TO 12
      KSTART=KSTART+1
  11  CONTINUE
      GO TO 500
   12 L = Z(KSTART,IJFIX) + 10000.0
      GO TO 20
  15  DO 16 K=KBEG,KLIM
      IDEF=Z(IJFIX,K)
      IF(IDEF.NE.INDEF) GO TO 17
      KSTART=KSTART+1
  16  CONTINUE
      GO TO 500
  17  L=Z(IJFIX,KSTART)+10000.
  20  DO 200 K=KSTART,KLIM
      Q4=REM/2.
      Q5=1.-REM
      X=Q-Q5
      IINC=X
      REM=X-FLOAT(IINC)
C
C     CHECK FOR IMBEDDED GRID
C
      IF(ITYPE.EQ.1) GO TO 25
C     ...COMES HERE IF WORKING ALONG A ROW TO TEST ONE (K) GRID INTERVAL
C     ...  FOR VALID POINTS FOR SEARCHING WITHIN,
C     ...  AND TO COMPUTE STARTING VALUE OF THE GIVEN FIELD AT THE
C     ...   FIRST INCREMENT W/I THE GRID INTERVAL
      IF(Z(K,IJFIX) .EQ. INDEF) GO TO 33
      IF(Z(K+1,IJFIX) .EQ. INDEF) GO TO 33
C     ...OTHERWISE, BOTH INTERIOR PTS OK, SO WILL SEARCH W/I THIS INTERV
C     ...   DID WE JUST COME IN FROM AN INDEF REGION QQ
      IF( .NOT. LINDEF) GO TO 21
C     ...OTHERWISE, PRECEDING INTERVAL WAS IN INDEF REGION,
C     ...   SO RESET L (TRUNCATED VALUE OF FIELD AT STARTING PT)
      LINDEF = .FALSE.
      L = Z(K,IJFIX) + 10000.0
   21 CONTINUE
      YD2 = 0
      IF(Z(K-1,IJFIX) .EQ. INDEF) GO TO 23
      IF(Z(K+2,IJFIX) .EQ. INDEF) GO TO  23
C     ...OTHERWISE, BOTH EXTERIOR PTS OK ALSO, SO 4 GOOD PTS ...
      YD2=(Z(K+2,IJFIX)-Z(K+1,IJFIX)-Z(K,IJFIX)+Z(K-1,IJFIX))*Q1
   23 CONTINUE
      YD1=(Z(K+1,IJFIX)-Z(K,IJFIX))*Q3-(Q2*YD2)+Q5*YD2
      YVAL = Z(K,IJFIX) + Q5*Q4*YD1 + 10000.0
      GO TO 35
   25 CONTINUE
C     ...COMES HERE IF DOING A COLUMN TO TEST ONE (K) GRID INTERVAL
C     ...  FOR VALID POINTS FOR SEARCHING WITHIN,
C     ...  AND TO COMPUTE STARTING VALUE OF THE GIVEN FIELD AT THE
C     ...   FIRST INCREMENT W/I THE GRID INTERVAL
      IF(Z(IJFIX,K) .EQ. INDEF) GO TO 33
      IF(Z(IJFIX,K+1) .EQ. INDEF) GO TO 33
C     ...OTHERWISE, BOTH INTERIOR PTS OK, SO WILL SEARCH W/I THIS INTERV
C     ...   DID WE JUST COME IN FROM AN INDEF REGION QQ
      IF(.NOT. LINDEF) GO TO 27
C     ...OTHERWISE, PRECEDING INTERVAL WAS IN INDEF REGION,
C     ...   SO RESET L (TRUNCATED VALUE OF FIELD AT STARTING PT)
      LINDEF = .FALSE.
      L = Z(IJFIX,K) + 10000.
   27 CONTINUE
      YD2 = 0
      IF(Z(IJFIX,K-1) .EQ. INDEF) GO TO 29
      IF(Z(IJFIX,K+2) .EQ. INDEF) GO TO 29
C     ...OTHERWISE, BOTH EXTERIOR PTS OK ALSO, SO 4 GOOD POINTS
      YD2=(Z(IJFIX,K+2)-Z(IJFIX,K+1)-Z(IJFIX,K)+Z(IJFIX,K-1))*Q1
   29 CONTINUE
      YD1=(Z(IJFIX,K+1)-Z(IJFIX,K))*Q3-(Q2*YD2)+Q5*YD2
      YVAL=Z(IJFIX,K)+Q5*Q4*YD1+10000.
      GO TO 35
   33 CONTINUE
C     ...COMES HERE IF EITHER INTERIOR PT IS INDEF...
      LINDEF = .TRUE.
      GO TO 200
  35  DO 130 KK=1,IINC
      MM=YVAL
      IF((MM-L).EQ.0) GO TO 125
C
C     COMPUTE A LABEL
C
      XVAL=MM-10000
      IF((IABS(MM)-IABS(L)).LT.0) XVAL=L-10000
      KCON1=(KK-1)*3
      KCON7=(FLOAT(K-1)*Q*3.0)+0.5
      IF(ITYPE.EQ.1) GO TO 40
      JCAL = KCON6 + IRTCOR
      ICAL = KCON7 + KCON1 + IUPCOR
      ICAL1 = ICAL
      GO TO 45
   40 CONTINUE
      JCAL = KCON7 + KCON1 + IUPCOR
C     ...THIS JCAL IS JDOTS FOR PUTNLAB FOR CONST I CASE.
      ICAL = JCAL
   45 CONTINUE
      HOLD = B * (XVAL + A)
      ITEXT(1) = SIGN((ABS(HOLD) + 0.05),HOLD)
      KPOSX = KCON4
      KAFOS=KCON5
      IF((ICAL-KLAST).LT.KPOSX) GO TO 125
      IF((ICAL-KLAST).LT.KAFOS) GO TO 150
C///
      JPRPUT(1)=IPRPUT(1)
      JPRPUT(2)=IPRPUT(2)
      ICLOSE=0
      GO TO 160
 150  CONTINUE
      IF(ICLOSE.EQ.0) GO TO 151
      GO TO 152
 151  CONTINUE
C///  JPRPUT=1
      JPRPUT(1)=IPRPUT(1)
      JPRPUT(2)=1
      ICLOSE=1
      GO TO 160
 152  CONTINUE
C///  JPRPUT=IPRPUT
      JPRPUT(1)=IPRPUT(1)
      JPRPUT(2)=IPRPUT(2)
      ICLOSE=0
 160  CONTINUE
      KLAST=ICAL
      INTG=ITEXT(1)
C
C     CHECK TO SEE IF ONLY ONE CONTOUR LINE IS TO BE LABELED.
C
      IF(.NOT.LONLY1) GO TO 120
C
C     NOW CHECK FOR VALUE OF CONTOUR TO BE LABELED.
C
      IF(INTG.NE.KONST) GO TO 125
C
 120  CONTINUE
      NCHAR = M(2)
      IF(IISFC.EQ.1) GO TO 121
      GO TO 123
C
C     FORMAT PRECIP STRIP LABELS-SPECIAL CASE
C
 121  CONTINUE
      NCHAR=3
C*    CALL BIN2EB(INTG,JTEXT,NCHAR,LPLMI)
      CALL BIN2EB(INTG,MTEXT,NCHAR,LPLMI)
C///
      CALL GBYTES(MTEXT,JTEXT,0,32,0,4)
      IPUU=IAND(JTEXT(1),IMSK1)
      IPTH=IAND(ISHFT(JTEXT(1),8),IMSK2)
      WRITE(LTEXT(1:4),FMT='(A1,A1,A2)')IPUU,IDECP,IPTH
      MCHAR=4
      IF(INTG.GT.25) MCHAR=3
      CALL PUTLAB(ICAL1,JCAL,PUTHGT,LTEXT,PUTANG,MCHAR,JPRPUT,ITAPUT)
      GO TO 125
C
C     FORMAT STRIP LABEL
C
 123  CONTINUE
      IF(NCHAR.EQ.9) NCHAR=3
C*    CALL BIN2EB(INTG,JTEXT,NCHAR,LPLMI)
      CALL BIN2EB(INTG,MTEXT,NCHAR,LPLMI)
C     PRINT *,' CLABEL: INTG=',INTG,' NCH=',NCHAR,' MTEXT=',MTEXT
C///
C///  CALL GBYTES(MTEXT,JTEXT,0,32,0,4)
C///
      N=12
C///  WRITE(LTEXT,FMT=IFF)JTEXT(1)
      WRITE(LTEXT,FMT=IFF)MTEXT
      CALL PUTLAB(ICAL1,JCAL,PUTHGT,LTEXT,PUTANG,N,JPRPUT,ITAPUT)
 125  L=MM
      YD1=YD1+YD2
      YVAL=YVAL+YD1
 130  CONTINUE
 200  CONTINUE
 500  RETURN
      END
